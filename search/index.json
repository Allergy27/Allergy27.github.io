[{"content":"2024级新生第四次考核题解 考核链接：https://vjudge.net/contest/663008\n题目类型 A：签到题 B：暴力 C：模拟、排序 D：优先队列 E：BFS\n说明：\nPython代码全是由C++版本用GPT转译而来，逻辑上没有问题但不保证是在python下的最优实现 B题暴力并非最优解，但是可行解，且在比赛过程中能做上就是最好的 未提供C代码，请善用GPT等工具或尽快掌握C++的基础语法 C++代码统一模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Copyright 2024 Allergy /* @author Allergy * @email Allergy527@gmail.com * @workspace Atcoder\\10.13New\\a.cpp * @date 2024/10/13 17:21:44 */ #include\u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x)\u0026amp;(-(x))) // #define int int64_t using namespace std; // NOLINT using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; void solve(){ } signed main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); cin \u0026gt;\u0026gt; t; return 0; } Python代码统一模板 1 2 3 4 5 6 7 def solve(): pass if __name__ == \u0026#34;__main__\u0026#34;: t = 1 # t = int(input().strip()) for _ in range(t): solve() A 因为Taffy很 本质上是一道模拟题，按题意从高到低走一遍即可，检测到比前一位小就返回NO\nC++代码 1 2 3 4 5 6 7 8 9 10 11 void solve() { string s; cin \u0026gt;\u0026gt; s; for (int i = 1; i \u0026lt; s.size(); ++i) { if (s[i] \u0026gt;= s[i - 1]) { cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; return; } } cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; } Python代码 1 2 3 4 5 6 7 def solve(): s = input().strip() for i in range(1, len(s)): if s[i] \u0026gt;= s[i - 1]: print(\u0026#34;No\u0026#34;) return print(\u0026#34;Yes\u0026#34;) B 回合制 假设我们从小到大遍历，那么算法时间复杂度为$O(n^2)$，显然跑题目的 $10^{18}$ 会超。 不妨换个想法，我们从最大值开始跑，也就是先检查 $R-L$ 是否满足题意，接着检查 $R-L-1$ ，以此类推\n诶，有同学会问为什么这样就不会超呢？ 我们可以简单思考一下，一开始质数的间隔小，接着间隔越来越大： 2 3 5 7 11 13 17 19 23 29 31 37 41 43 49 我们可以大胆猜测每隔 $5000$ 个肯定有两个是质数，而即便是 $5000$ ，$5000*5000\\approx10^7 $ ，这个数量级肯定是不会超的。至于详细证明见维基百科： https://en.wikipedia.org/wiki/Prime_gap C++代码 1 2 3 4 5 6 7 8 9 10 11 12 void solve() { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int w = r - l; w \u0026gt; 0; w--) { //从最宽的情况遍历 for (int j = l; j \u0026lt; r - w + 1; ++j) { if (__gcd(j, j + w) == 1) { //调用库函数求最大公约数 cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } } } } Python代码 1 2 3 4 5 6 7 8 9 import math def solve(): l, r = map(int, input().split()) for w in range(r - l, 0, -1): #从最宽的情况遍历 for j in range(l, r - w + 1): if math.gcd(j, j + w) == 1: #调用库函数求最大公约数 print(w) return C 可爱狗 首先，两个颜色相同的狗不会摸头，而题目保证了给定输入是偶数，那么如果每种颜色都为偶数个，则可以两两分组而不产生摸头。 接着我们讨论有颜色不为偶数的情况，由容斥原理，只会有两种颜色为奇数。 不妨假设 R 和 G 为奇数，那么取得最小摸头速度的情况只会是取min_diff(R,G)或min_diff(R,B)+min_diff(G,B)，比较后取较小者 (这里的min_diff并非库函数，仅是举例)\n有同学可能会问，为什么 R 和 G 不会取 B 中的同一个值？ 这点也不难理解，如果最优解时R和G取同一个B值，那答案是一定取min_diff(R,G)的，证明不困难，就留给各位了 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; qwq(3); for (int i = 0; i \u0026lt; 2 * n; i++) { int x; char y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; switch (y) { case \u0026#39;R\u0026#39;: qwq[0].emplace_back(x); break; case \u0026#39;G\u0026#39;: qwq[1].emplace_back(x); break; case \u0026#39;B\u0026#39;: qwq[2].emplace_back(x); break; default: break; } } for (auto \u0026amp;x : qwq) sort(x.begin(), x.end()); int r = qwq[0].size(), g = qwq[1].size(), b = qwq[2].size(); if (r % 2 == 0 \u0026amp;\u0026amp; g % 2 == 0 \u0026amp;\u0026amp; b % 2 == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; ln; return; } if (r % 2 == 0) { swap(r, b); swap(qwq[0], qwq[2]); } else if (g % 2 == 0) { swap(g, b); swap(qwq[1], qwq[2]); } // lambda 表达式，在外面写函数也可以 auto check = [\u0026amp;](vector\u0026lt;int\u0026gt; p, vector\u0026lt;int\u0026gt; q) -\u0026gt; int { //即min_diff函数 int point_p = 0, point_q = 0; int len_p = p.size(), len_q = q.size(); int ans = ll_inf; while (point_p \u0026lt; len_p \u0026amp;\u0026amp; point_q \u0026lt; len_q) { ans = min(ans, abs(p[point_p] - q[point_q])); if (p[point_p] \u0026lt; q[point_q]) { ++point_p; } else { ++point_q; } } return ans; }; int ans = check(qwq[0], qwq[1]); if (b \u0026gt; 2) { ans = min(ans, check(qwq[0], qwq[2]) + check(qwq[1], qwq[2])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import sys def solve(): n = int(input().strip()) qwq = [[] for _ in range(3)] for _ in range(2 * n): x, y = input().strip().split() x = int(x) if y == \u0026#39;R\u0026#39;: qwq[0].append(x) elif y == \u0026#39;G\u0026#39;: qwq[1].append(x) elif y == \u0026#39;B\u0026#39;: qwq[2].append(x) for lst in qwq: lst.sort() r, g, b = len(qwq[0]), len(qwq[1]), len(qwq[2]) if r % 2 == 0 and g % 2 == 0 and b % 2 == 0: print(0) return if r % 2 == 0: qwq[0], qwq[2] = qwq[2], qwq[0] elif g % 2 == 0: qwq[1], qwq[2] = qwq[2], qwq[1] def check(p, q): point_p, point_q = 0, 0 len_p, len_q = len(p), len(q) ans = sys.maxsize while point_p \u0026lt; len_p and point_q \u0026lt; len_q: ans = min(ans, abs(p[point_p] - q[point_q])) if p[point_p] \u0026lt; q[point_q]: point_p += 1 else: point_q += 1 return ans ans = check(qwq[0], qwq[1]) if len(qwq[2]) \u0026gt; 2: ans = min(ans, check(qwq[0], qwq[2]) + check(qwq[1], qwq[2])) print(ans) D 外卖小哥 我们从后往前看，在第m小时时，我们只能点0小时后结算的订单，m-1时，则可以点0到1小时的订单，依次类推,第0小时可以点0到m小时的订单。也就是我们从后向前遍历，每次取最大值接即可。 由于我们的时间复杂度被限制在$O(nlogn)$，所以必须用$logn$时间取得最大值，我们采用优先队列(最大堆)存储。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void solve() { int n, m, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; qwq; for (int i = 0; i \u0026lt; n; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; qwq[x].emplace_back(y); } priority_queue\u0026lt;int\u0026gt; que; for (int i = 0; i \u0026lt;= m; ++i) { if (qwq.count(i)) for (auto x : qwq[i]) que.push(x); if (!que.empty()) { int t = que.top(); que.pop(); ans += t; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import heapq def solve(): n, m = map(int, input().split()) qwq = {} for _ in range(n): x, y = map(int, input().split()) if x not in qwq: qwq[x] = [] qwq[x].append(y) que = [] ans = 0 for i in range(m + 1): if i in qwq: for val in qwq[i]: heapq.heappush(que, -val) if que: ans += -heapq.heappop(que) print(ans) E 西天取经 跑一遍 广度优先搜索(BFS) 即可，每次更新当前路的最短路径，并且为当前路存一个方案数，代表从东土大唐到该点有多少条方案，每次遇到最短路相同的情况将方案数相加，否则接着跑BFS即可\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void solve() { int n, m, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; qwq(n + 1); vector\u0026lt;int\u0026gt; dis(n + 1, ll_inf), num(n + 1); // bfs距离,方案数 for (int i = 0; i \u0026lt; m; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; qwq[x].emplace_back(y); qwq[y].emplace_back(x); } queue\u0026lt;int\u0026gt; que; que.push(1); dis[1] = 0; num[1] = 1; while (!que.empty()) { int t = que.front(); que.pop(); for (auto x : qwq[t]) { if (dis[x] \u0026gt; dis[t] + 1) { dis[x] = dis[t] + 1; num[x] = num[t]; que.push(x); } else if (dis[x] == dis[t] + 1) { num[x] = (num[x] + num[t]) % mod; } } } cout \u0026lt;\u0026lt; num[n] \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from collections import deque MOD = 10**9 + 7 def solve(): n, m = map(int, input().split()) qwq = [[] for _ in range(n + 1)] dis = [float(\u0026#39;inf\u0026#39;)] * (n + 1) num = [0] * (n + 1) for _ in range(m): x, y = map(int, input().split()) qwq[x].append(y) qwq[y].append(x) que = deque([1]) dis[1] = 0 num[1] = 1 while que: t = que.popleft() for x in qwq[t]: if dis[x] \u0026gt; dis[t] + 1: dis[x] = dis[t] + 1 num[x] = num[t] que.append(x) elif dis[x] == dis[t] + 1: num[x] = (num[x] + num[t]) % MOD print(num[n]) ","date":"2024-10-12T00:00:00Z","image":"https://allergy527.github.io/p/flashmen_solve/Snipaste_2024-10-18_13-49-01_hu10178239590808334018.png","permalink":"https://allergy527.github.io/p/flashmen_solve/","title":"2024级新生第四次考核题解"},{"content":"Boyer-Moore算法介绍 概述 Boyer-Moore算法（BM算法）是由Robert S. Boyer和J Strother Moore在1977年提出的一种字符串匹配算法。该算法在查找一个子串在主串中首次出现的位置时表现非常出色，尤其在处理较长的文本时具有高效性。它之所以高效，是因为在匹配过程中可以跳过一些无意义的字符，从而减少比较次数。\nBM算法的核心思想是通过分析文本和模式串之间的关系，提前预测某些字符的匹配结果，并在可能的情况下进行大步跳跃，以尽量避免不必要的字符比较。BM算法主要通过两个启发式规则来实现跳跃：坏字符规则和好后缀规则。\n核心思想 1. 坏字符规则（Bad Character Rule） 坏字符规则主要是指在比较过程中，当模式串中的某个字符与主串中的字符不匹配时，可以根据主串中的不匹配字符跳过一些可能不会匹配的位置。其基本原理是将模式串向右移动，直到该不匹配字符在模式串中的下一个匹配位置出现，或者模式串完全移过该不匹配字符。坏字符规则可以避免逐一比较，提升算法效率。\n2. 好后缀规则（Good Suffix Rule） 好后缀规则是当模式串的一部分在主串中匹配时，如果发现有一部分匹配，接下来发生了不匹配的情况，那么可以利用已经匹配的部分（即好后缀）来判断模式串应如何继续向右移动。好后缀规则的目的是确保尽可能大幅度地移动模式串，而不是简单地一位一位地滑动。\n这两个规则的结合使得BM算法能够在大部分情况下避免逐字符比较，尤其是在长文本和较短模式串的情况下，效率尤为明显。\nBM算法的复杂度 BM算法的时间复杂度依赖于文本和模式串的具体内容。它在最坏情况下的时间复杂度为O(mn)，其中m是模式串的长度，n是主串的长度。但在实际使用中，由于它的跳跃特性，BM算法的平均时间复杂度接近于O(n/m)，这使得它在大多数实际应用场景中非常高效。\n应用场景 BM算法特别适用于文本搜索、DNA序列比对、编辑器中的查找替换功能等。其高效的匹配性能使它在处理大规模文本数据时，成为一种常用的字符串匹配算法之一。\n代码样例(rust实现) 该代码实现随机生成两段DNA序列并在找到可以匹配的部分后输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //@author Allergy //@workspace study/bm.rs //@data 2024/10/10 19:15:05 use rand::Rng; fn cin() -\u0026gt; String { let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() } fn main() { let t = 1; //let t = cin().parse::\u0026lt;i32\u0026gt;().unwrap(); let _ = (0..t).for_each(|_| solve()); } fn solve() { let (a, b) = cin() .split_whitespace() .fold((0, 0), |x, y| (x.1, y.parse::\u0026lt;usize\u0026gt;().unwrap())); let trans = |x: char| match x { \u0026#39;A\u0026#39; =\u0026gt; \u0026#39;T\u0026#39;, \u0026#39;T\u0026#39; =\u0026gt; \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39; =\u0026gt; \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39; =\u0026gt; \u0026#39;C\u0026#39;, _ =\u0026gt; \u0026#39; \u0026#39;, }; let show = |qwq: \u0026amp;Vec\u0026lt;char\u0026gt;| { qwq.iter().for_each(|x| print!(\u0026#34;{}\u0026#34;, x)); println!() }; let dna_init = random_dna(a); let dna = dna_init.iter().map(|x| trans(*x)).collect::\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;(); let pattern = random_dna(b); show(\u0026amp;dna_init); println!(\u0026#34;↓\u0026#34;); show(\u0026amp;pattern); boyer_moore(\u0026amp;dna, \u0026amp;pattern); } fn random_dna(length: usize) -\u0026gt; Vec\u0026lt;char\u0026gt; { let nucleotides = [\u0026#39;A\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;G\u0026#39;]; // DNA碱基 let mut rng = rand::thread_rng(); // 创建随机数生成器 // 随机生成指定长度的DNA序列 let sequence: String = (0..length) .map(|_| nucleotides[rng.gen_range(0..4)]) // 随机选择ATCG中的一个 .collect(); sequence.chars().collect() } fn boyer_moore(text: \u0026amp;Vec\u0026lt;char\u0026gt;, pattern: \u0026amp;Vec\u0026lt;char\u0026gt;) { // 坏字符规则：生成坏字符表 let bad_str = |pattern: \u0026amp;Vec\u0026lt;char\u0026gt;, qwq: \u0026amp;mut Vec\u0026lt;i32\u0026gt;| { qwq.iter_mut().for_each(|x| *x = -1); let m = pattern.len(); for i in 0..m { qwq[pattern[i] as usize] = i as i32; } }; // 好后缀规则 let good_suffix = |pattern: \u0026amp;Vec\u0026lt;char\u0026gt;,qwq:\u0026amp;mut Vec\u0026lt;i32\u0026gt;|{ } let n = text.len(); let m = pattern.len(); if m == 0 { println!(\u0026#34;模式串为空，返回0\u0026#34;); return; } // 坏字符表（ASCII字符集大小256） let mut bad_char = vec![-1; 256]; bad_str(\u0026amp;pattern, \u0026amp;mut bad_char); // 开始匹配 let mut i = 0; while i \u0026lt;= n - m { let mut j = m - 1; let mut check = false; //从末位开始判断 while pattern[j] == text[i + j] { if j == 0 { check = true; break; } j -= 1; } if check { println!(\u0026#34;成功匹配，索引位于{}\u0026#34;, i + 1); i += if i + m \u0026lt; n { (m as i32 - bad_char[text[i + m] as usize]) as usize } else { 1 }; } else { i += 1.max(j as i32 - bad_char[text[i + j] as usize]) as usize; } } } ","date":"2024-10-12T00:00:00Z","image":"https://allergy527.github.io/p/boyer-moore-algorithm/Snipaste_2024-10-10_18-54-01_hu10235375344337538124.png","permalink":"https://allergy527.github.io/p/boyer-moore-algorithm/","title":"bm算法介绍"}]