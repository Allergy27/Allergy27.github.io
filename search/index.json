[{"content":"","date":"2025-05-31T00:00:00Z","permalink":"https://allergy27.github.io/p/union_find_set/","title":"高级数据结构-并查集"},{"content":" 算法导论对线段树这样介绍到：NULL\n是的，很遗憾算法导论并没有介绍到线段，树但无疑线段树是 Acmer 的常用数据结构\n我们需要掌握的主要有：区间查询、区间加乘操作、线段树分裂、可持久化线段树\n而上述的主要是模板，在实际应用中需要注意如何能抽象出线段树模型\n线段树是什么算法 既然算法导论没有介绍，那就需要重新认识一下线段树\n线段树是利用了分治思想的一种数据结构，可以称之为升级版树状数组\n常用的场景在上面已经介绍，这里不多赘述\n线段树要怎么构建 分治原理： 线段树将区间递归划分为若干子区间，每个节点对应区间预计算信息，将区间操作降低为 O(logn)\n基础处理 考虑将一个数组转换为完全二叉树，即开辟 4 倍空间的数组，然后叶子节点即为节点 i - j 的信息\n我们考虑一对叶子节点，其信息分别为 l - m ， m - r\n而它的父亲表示的即为 l - r 的信息，最后根节点存储的即为 0 - n 的信息\n要实现这样的处理只需要从叶子节点向根节点不断转移即可\n通过这样的处理，对某个区间的处理就变成了从根节点向下搜索，最多只需 O(logn) 的复杂度即可完成：\n区间修改 区间查询 单点修改 另：注意到单点查询与区间查询等价，故一般不会去单独实现单点查询\nLazy数组优化区间修改 如果每次操作都从 0 - n ，且不进行优化，则复杂度达到 O(nq) ，同时拥有较大常数\n我们需要额外的信息来记录每个节点是否有待处理的更改，并只在查询到它的时候更新\n我们将记录这一信息的数组记为 Lazy 数组，其含义如上\n如何代码构建： 构建思路及实现 我们需要知道如何构建一颗线段树，按照超级大神 Jiangly 的板子，我们可以将线段树分成下面几部分：\n节点信息存储 子区间信息合并 区间修改（如果有） 区间查询 单点修改 而对这几部分的实现就是一颗线段树最重要的部分，也是各种不同实现最相通的部分\n我们来看一段代码实现:\n过长，手动展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include\u0026lt;bits/stdc++.h\u0026gt; template\u0026lt;class T\u0026gt; struct Info { T sum = 0; T max = 0; // Could be initialized to -INF depending on the minimum value needed int cnt = 0; explicit Info() {} explicit Info(T x) : sum(x), max(x), cnt(1) {} }; Info operator+(const Info \u0026amp;a, const Info \u0026amp;b) { // Merge operation for combining two Info objects Info c; c.sum = a.sum + b.sum; c.max = std::max(a.max, b.max); c.cnt = a.cnt + b.cnt; return c; } template\u0026lt;class T\u0026gt; struct SegmentTree { int n; std::vector\u0026lt;T\u0026gt; tag; std::vector\u0026lt;Info\u0026gt; info; explicit SegmentTree(int n_) : n(n_), tag(4 * n_), info(4 * n_) {} void pull(int p) { // Update parent node\u0026#39;s info from its children info[p] = info[p \u0026lt;\u0026lt; 1] + info[p \u0026lt;\u0026lt; 1 | 1]; } void add(int p, T v) { // Apply an update to a node tag[p] += v; // Accumulate the lazy tag info[p].sum += v * info[p].cnt; // Update sum with the value multiplied by count info[p].max += v; // Update max by adding the value } void push(int p) { // Propagate lazy tag to children add(p \u0026lt;\u0026lt; 1, tag[p]); add(p \u0026lt;\u0026lt; 1 | 1, tag[p]); tag[p] = 0; // Clear the tag after propagation } Info query(int p, int l, int r, int tl, int tr) { if (l \u0026gt;= tr || r \u0026lt;= tl) return Info(); // No overlap with query range if (l \u0026gt;= tl \u0026amp;\u0026amp; r \u0026lt;= tr) return info[p]; // Complete overlap with query range int m = l + r \u0026gt;\u0026gt; 1; push(p); // Ensure children are up-to-date before querying return query(p \u0026lt;\u0026lt; 1, l, m, tl, tr) + query(p \u0026lt;\u0026lt; 1 | 1, m, r, tl, tr); } void range_add(int p, int l, int r, int tl, int tr, T v) { if (l \u0026gt;= tr || r \u0026lt;= tl) return; // No overlap with update range if (l \u0026gt;= tl \u0026amp;\u0026amp; r \u0026lt;= tr) return add(p, v); // Complete overlap with update range int m = l + r \u0026gt;\u0026gt; 1; push(p); // Ensure children are up-to-date before updating range_add(p \u0026lt;\u0026lt; 1, l, m, tl, tr, v); range_add(p \u0026lt;\u0026lt; 1 | 1, m, r, tl, tr, v); pull(p); // Update current node after children are updated } void modify(int p, int l, int r, int x, const Info \u0026amp;v) { if (r - l == 1) { // Leaf node reached info[p] = v; return; } int m = l + r \u0026gt;\u0026gt; 1; push(p); // Ensure children are up-to-date before modification if (x \u0026lt; m) modify(p \u0026lt;\u0026lt; 1, l, m, x, v); else modify(p \u0026lt;\u0026lt; 1 | 1, m, r, x, v); pull(p); // Update current node after modification } // Convenience methods for external use Info query(int tl, int tr) { return query(1, 0, n, tl, tr); } void range_add(int tl, int tr, T v) { range_add(1, 0, n, tl, tr, v); } void modify(int x, const Info \u0026amp;v) { modify(1, 0, n, x, v); } }; 分步理解如何构建 Step1. 节点信息存储 我们利用一个新的数据结构 Info 去实现节点信息的存储，其包含我们所有需要的信息：\n例如 最大值、最小值、区间和、区间异或、区间乘、最大子段和……\nStep2. 子区间信息合并 这一步即转移的方式，通过重载 operator+ 来实现：\n例如 最大值转移c.max = std::max(a.max, b.max)，和转移c.sum = a.sum + b.sum\n还需要在向上传递时进行一步合并：\n1 2 3 void pull(int p){ info[p] = info[p \u0026lt;\u0026lt; 1] + info[p \u0026lt;\u0026lt; 1 | 1]; } Step3. 区间修改 如果有区间修改，则需要多一步简单的单点修改：\n1 2 3 4 5 void add(int p, T v){ tag[p] += v; info[p].max += v; /* ... */ } 并在向下搜索区间时如果目标区间完全包含该区间则对其应用修改\nStep4. 区间查询 这一步和区间修改相似，都需要应用 push() ，但无需向上传递修改\n先讲解在上一步没有提到的区间划分：\nif(l \u0026gt;= tr || r \u0026lt;= tl) 这一步指超出范围了，实际上也不会有这个情况，随便返回即可\nif(l \u0026gt;= tl \u0026amp;\u0026amp; r \u0026lt;= tr) 这一步说明已经可以完全覆盖，返回值即可\nStep5. 单点修改 这一步的区间比较不同，因为我们只需要确定到某一个点即可，改为：\nif(r - l == x)\n以及寻找部分改为一个类似二分的结构，以上就是线段树的构建\n线段树怎么样应用 ","date":"2025-05-31T00:00:00Z","permalink":"https://allergy27.github.io/p/segment_tree/","title":"高级数据结构-线段树"},{"content":"前言 比赛链接：https://codeforces.com/contest/2110\n题目类型 A：模拟 B：字符串处理 C：贪心 D：二分 E：欧拉路径 F：结论\nC++模板（除主函数部分）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;bits/stdc++.h\u0026gt; #define judge(x) std::cout \u0026lt;\u0026lt; ((x) ? \u0026#34;Yes\\n\u0026#34;:\u0026#34;No\\n\u0026#34;); using ll = int64_t; using PII = std::pair\u0026lt;int, int\u0026gt;; int main(){ std::cin.tie(nullptr) -\u0026gt; std::ios::sync_with_stdio(false); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void{ int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; }; while(_--)solve(); return; } A 题意：给定 n 个整数，每次可以删除一个数\n判断最少删除多少次能使得 max(a) + min(a) 被 2 整除\n做法:\n排序，因为奇偶性相同才能被2整除，找到最大和最小奇数 取较小值 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; qwq(n); for(auto \u0026amp;x : qwq)std::cin \u0026gt;\u0026gt; x; std::sort(qwq.begin(), qwq.end()); int maxodd = -1, minodd = -1, maxeve = -1, mineve = -1; int ans = n - 1; for(int i=0;i\u0026lt;n;++i){ if(qwq[i] \u0026amp; 1){ maxodd = i; if(minodd == -1)minodd = i; }else{ maxeve = i; if(mineve == -1)mineve = i; } } ans = std::min(ans, n - maxodd + minodd - 1); ans = std::min(ans, n - maxeve + mineve - 1); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } B 题意：给你一个匹配的括号序列，判断能否通过删除两个字符来使其失配\n做法:\n观察发现相邻括号序列可以失配，判断是否存在相邻括号 如果第一个数 $\\leq$ 中位数，则一定可以操作后变中位数 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { std::string s; std::cin \u0026gt;\u0026gt; s; int n = s.size(); std::vector\u0026lt;int\u0026gt; qwq(n, 1); int cnt = 0; for(int i = 0;i \u0026lt; n;++i){ if(s[i] == \u0026#39;)\u0026#39;)qwq[i] = qwq[i - 1] - 1; else qwq[i] = qwq[i - 1] + 1; cnt += qwq[i] == 0; } judge(cnt \u0026gt; 1); }; while (_--) solve(); return 0; } C 题意：FlyBrid，给定管道，判断能否钻过\n每次只能升高，管道 [l , r] ，给定 n 个操作序列\n改变-1，使得满足条件，如果不能报告-1\n做法:\n从前往后遍历，将操作存入栈，判断是否需要上升 需要就上升，不需要就不管 最后将 -1 全改为 0 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n ; std::vector\u0026lt;int\u0026gt; qwq(n); for(auto \u0026amp;x : qwq)std::cin \u0026gt;\u0026gt; x; std::vector\u0026lt;PII\u0026gt; h(n); for(auto \u0026amp;[x,y] : h)std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int nl = 0; std::stack\u0026lt;int\u0026gt; stk; for(int i=0 ;i\u0026lt;n; ++i){ if(qwq[i] == -1) stk.push(i); else nl += qwq[i]; auto [x, y] = h[i]; while(nl \u0026lt; x){ if(stk.empty()){ std::cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } qwq[stk.top()] = 1; ++nl; stk.pop(); } while(nl + (stk.size()) \u0026gt; y){ if(stk.empty()){ std::cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } qwq[stk.top()] = 0; stk.pop(); } } for(auto x:qwq)std::cout \u0026lt;\u0026lt; std::max(x,0) \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; while (_--) solve(); return 0; } D 题意：给定一个图，节点有电池，携带电池大于边权可以通过\n问最少携带多少电池可以到达 n\n做法:\n二分答案，n + m 遍历去检查 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 int main(){ std::cin.tie(nullptr) -\u0026gt; std::ios::sync_with_stdio(false); int _ = 1; std::cin \u0026gt;\u0026gt; _; const int INF = 0x3f3f3f3f; auto solve = [\u0026amp;]() -\u0026gt; void{ int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; qvq(n); for(auto \u0026amp;x:qvq)std::cin \u0026gt;\u0026gt; x; std::vector\u0026lt;std::vector\u0026lt;PII\u0026gt;\u0026gt; qwq(n); for(int i= 0;i\u0026lt;m; ++i){ int s, t, w; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; w; --s,--t; qwq[s].push_back({t , w}); } auto check = [\u0026amp;](int x) -\u0026gt; bool{ std::vector\u0026lt;int\u0026gt; dis(n); for(int i = 0;i\u0026lt;n;++i){ if(i \u0026gt; 0 \u0026amp;\u0026amp; dis[i] == 0)continue; dis[i] += qvq[i]; dis[i] = std::min(dis[i] , x); for(auto [v,w]: qwq[i]){ if(w \u0026lt;= dis[i])dis[v] = std::max(dis[v] , dis[i]); } } return (dis.back() \u0026gt; 0); }; if(!check(INF)){ std::cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } int l = 0 , r = INF; while(l \u0026lt; r){ int m = l + r \u0026gt;\u0026gt; 1; if(check(m)){ r = m ; }else{ l = m + 1 ; } } std::cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; while(_--)solve(); return 0; } E 题意：给定一堆音符，音符有音高、音色\n问能否排列成连续有音符要么音高相同要么音色相同但音高音色不同时相同\n做法:\n将音高划分到左边，音色划分到右边，构建二分图，答案即找欧拉路径 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 int main(){ std::cin.tie(nullptr) -\u0026gt; std::ios::sync_with_stdio(false); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void{ int n, m; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; v(n) , p(n); std::unordered_map\u0026lt;int, int\u0026gt; vm,pm; int vi = 0, pi = 0; for(int i=0 ;i\u0026lt;n; ++i){ int x, y; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if(!vm.contains(x))vm[x] = vi++; if(!pm.contains(y))pm[y] = pi++; v[i] = vm[x], p[i] = pm[y] + n; } std::vector\u0026lt;int\u0026gt; deg(2 * n); std::vector\u0026lt;std::vector\u0026lt;PII\u0026gt;\u0026gt; qwq(2 * n); for(int i = 0; i \u0026lt; n ;++i){ qwq[v[i]].push_back({p[i], i}); qwq[p[i]].push_back({v[i], i}); ++deg[v[i]]; ++deg[p[i]]; } std::vector\u0026lt;int\u0026gt; ans; int s = 0; while(s \u0026lt; 2 * n \u0026amp;\u0026amp; deg[s] % 2 == 0)++s; if(s == 2 * n){ s = 0; while(!deg[s]) ++s; } int cnt = 0; for(int i = 0; i \u0026lt; 2 * n; ++i)cnt += deg[i] % 2; if(cnt \u0026gt; 2){ std::cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; return; } std::vector\u0026lt;int\u0026gt; cur(2 * n); std::vector\u0026lt;int\u0026gt; vis(n); auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;dfs, int x) -\u0026gt; void{ for(int \u0026amp;j = cur[x]; j \u0026lt; qwq[x].size() ; ++j){ auto [y, i] = qwq[x][j]; if(!vis[i]){ vis[i] = true; dfs(dfs, y); ans.emplace_back(i); } } }; dfs(dfs, s); if(ans.size() != n){ std::cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; return; } std::cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; for(auto x:ans) std::cout \u0026lt;\u0026lt; x + 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; while(_--)solve(); return 0; } F 题意：求解从0到i的 max f(x, y);\nf(x , y) = (x % y + y % x)\n做法:\n注意到： f(x, y) \u0026lt;= max(x, y); 计算 f(bi, bj) 时, bmax 一定被选择 若 bi \u0026lt; bj ，bj \u0026lt; bi * 2 ，则 f(bi, bj) = bi 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int main(){ std::cin.tie(nullptr) -\u0026gt; std::ios::sync_with_stdio(false); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void{ int n, m; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; qwq(n); for(auto \u0026amp;x:qwq)std::cin \u0026gt;\u0026gt; x; auto f = [](int x, int y){ return x%y + y%x; }; int mx = 0,ans = 0; for(int i = 0 ;i \u0026lt; n; ++i){ int x = qwq[i]; if (x \u0026lt;= mx ) ans = std::max(ans, f(x, mx)); else if(x \u0026lt; 2 * mx) ans = std::max(ans, x); else for(int j = 0 ; j \u0026lt; i; ++j)ans = std::max(ans, f(x, qwq[j])); mx = std::max(mx, x); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; while(_--)solve(); return 0; } ","date":"2025-05-28T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_1026_div2/","title":"CodeForces Round 1026 Div2 A-E 题解"},{"content":"前言 比赛链接：https://codeforces.com/contest/2102\n参考代码：https://github.com/Allergy27/Allergy-to-not-study/tree/main/cpp/CF/cf%201027%20div3\n题目类型 A：数学 B：贪心 C：贪心 D：排序 E：排序 F：排序 G：排序\nA 题意：给定一个数 n\n判断是否可以找到 $ (a + b) ^ 2 \\eq n $\n输出 a , b 或报告 -1 代表无法找到\n做法:\n数学，等价于判断该数是否是完全平方数 做根号，再乘回去，不相等说明 -1 若相等则输出这个数和 0 的和即可 B 题意：给定01字符串\n判断将其任意排列后能否可以找到 k 对回文串\n做法:\n思维题 首先注意到答案不会是奇数 两两各自配对是最大值， 取较大值 - n/2 得到最小值 计算答案能否得到即可 C 题意：给定数组，可以进行任意次删除\n不连续的数重新构成新数组，问最多构建多少数组\n做法:\n可以发现每有相隔为2的数答案就加一 由于题目本来也排好序了，遍历过去即可 D 题意：如何选最小矩形将给定矩形内的数包围\n可以进行一次操作将某个数更换位置\n做法:\n可以发现无非是要对四个角进行处理 处理方式有简单复杂之分，考虑下面操作 先按 x / y 排序，升降各处理一次 计算排除掉首个元素时的答案 统计最小值 E 题意：树上的每个点有个值，每次可以向根寻找\n交替减值加值，问每个点最大值为？\n做法:\n方法一： 可以发现是树上DP的经典题 从根节点向下搜，统计该点的答案 再比较是否需要向上选取 向上选取需要比较父亲答案减去值是否为正 为正说明向上选比较好 方法二： 可以发现是最大右子段和的模板题 我们预处理两颗能求解最大子段和的线段树 对于子段和的解释： 如果自根向下寻找，那么根节点在左边 于是根据题目要求，我们求解的是最大右子段和 线段树维护两个信息，和以及右子段和 对于两颗树的解释： 如果该节点为奇，所有奇节点的值都为负值 对于偶节点同理，所以需要两个树来求解 接着只需要bfs向下遍历并求解即可 F 题意：给定 x y k ，以及操作f(x, a) = x * a , g(x, a) = x / a\ng(x)仅在 x % a == 0 时可用，问最少对 x ,y 几次操作后相等\n做法:\n首先最优解一定是将两者变成最小公倍数 我们 DP 计算如何变成最小公倍数 首先预处理出因子，然后计算能否转移 转移的条件是乘上 k 足够大 由于多组样例下复杂度也许超了，所以最好预处理一下因子 G 题意：给定空数组，以及一个操作可以向数组首或尾添加一个数\n有相同的相邻数会合并为他们的和，问能否通过 k 次操作变为给定数组\n做法:\n首先注意到一个数最理想的合并方式一定是若干个奇数底不断合并得来 这等价于求解其 lowbit ，我们将每个数的 lowbit 预处理出来，并计算奇数底 由于转移可以从前往后，也可以从后往前，我们需要分解前后缀求解 先考虑从前往后，我们不难发现两个相同奇数底会产生一定影响 具体来说，3 6 共有 3 作为奇数底，而此时想要形成 6 就不能是3 3 因为前面的 3 会和其合并 我们通过观察可以发现同底且后面的较大时需要减去前面的 lowbit 值 * 2 再 + 1 原因可以这么理解：必须以前面的底数乘 lowbit 后的新值乘二去计算新次数 而至少可以直接将自己摆上 最后枚举从中间的每个点向左右扩展所需要的次数即可 ","date":"2025-05-27T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_1027_div3/","title":"CodeForces Round 1027 Div3 A-G 题解"},{"content":"前言 比赛链接：https://atcoder.jp/contests/abc406\n题目类型 A：签到 B：贪心 C：前缀和 D：Set E：Dp F：DFS序 + 树状数组\nC++模板（除主函数部分）\r1 2 3 4 5 6 7 8 9 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln \u0026#39;\\n\u0026#39; #define PII std::pair\u0026lt;int, int\u0026gt; #define judge(x) std::cout \u0026lt;\u0026lt; ((x) ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;) using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; A 题意：给定两个时分，判断是否前一个大于后一个\n做法:\n转成分比较即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m, a, b; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; judge(n * 60 + m \u0026gt;= a * 60 + b); }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } B 题意： 问进行 N 次乘法操作，每次 *$A_i$, 位数是否小于 K\n做法:\n按题意模拟，需要注意将乘法写成除法来比较避免溢出 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; ll ans = 1, tmp = 1; for (int i = 0; i \u0026lt; m; ++i) tmp *= 10; for (int i = 0; i \u0026lt; n; ++i) { ll x; std::cin \u0026gt;\u0026gt; x; if (ans \u0026gt; tmp / x) { ans = 1; } else { ans *= x; if (ans \u0026gt;= tmp) ans = 1; } } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } C 题意：给定一组数，定义先递增再下降再递增的序列为波浪形序列\n求给定数组有多少子序列为波浪形序列\n做法:\n求出递增的部分，相邻递增部分的乘积和即为所求 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /* Copyright 2025 Allergy * @author Allergy * @email Allergy527@gmail.com * @workspace cpp\\Atcoder\\abc 406\\c.cpp * @date 2025/05/17 20:21:31 */ #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln \u0026#39;\\n\u0026#39; #define judge(x) std::cout \u0026lt;\u0026lt; ((x) ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;) using ll = int64_t; using PLL = std::pair\u0026lt;ll, ll\u0026gt;; using PII = std::pair\u0026lt;int, int\u0026gt;; using PDD = std::pair\u0026lt;double, double\u0026gt;; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) std::cin \u0026gt;\u0026gt; x; std::vector\u0026lt;int\u0026gt; ck; for (int i = 1; i \u0026lt; n; ++i) ck.emplace_back(qwq[i] \u0026gt; qwq[i - 1]); std::vector\u0026lt;PLL\u0026gt; tmp; tmp.push_back({ck[0], 1}); for (int i = 1; i \u0026lt; n - 1; ++i) { if (ck[i] == tmp.back().first) tmp.back().second += 1; else tmp.push_back({ck[i], 1}); } int len = tmp.size(); ll ans = 0; int st = tmp[0].first == 0 ? 3 : 2; for (int i = st; i \u0026lt; len; i += 2) ans += tmp[i].second * tmp[i - 2].second; std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } D 题意：N * M 的方格有一堆垃圾，给定q个查询\n每次查询某行或某列有多少垃圾，并删去，模拟查询\n做法:\n两个Set分别记录当前行或列都有哪些数 每次删的时候模拟即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m, k; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; std::vector\u0026lt;std::set\u0026lt;int\u0026gt;\u0026gt; h(n), w(m); // 一定要用set而不是unordered_set，不然erase操作会超时 for (int i = 0; i \u0026lt; k; ++i) { int x, y; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; --x, --y; h[x].insert(y); w[y].insert(x); } int q; std::cin \u0026gt;\u0026gt; q; for (int i = 0; i \u0026lt; q; ++i) { int op, x; std::cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; x -= 1; if (op == 1) { std::cout \u0026lt;\u0026lt; h[x].size() \u0026lt;\u0026lt; ln; for (auto p : h[x]) w[p].erase(x); h[x].clear(); } else { std::cout \u0026lt;\u0026lt; w[x].size() \u0026lt;\u0026lt; ln; for (auto p : w[x]) h[p].erase(x); w[x].clear(); } } }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } E 题意：求 1~N 所有满足 popcount = K 的数的和\n做法:\n数学计算，具体计算过程挖个坑，以后再补（ 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { const int MOD = 998244353; std::vector\u0026lt;int\u0026gt; fac, inv_fac; int max_n = 1; fac = {1}; inv_fac = {1}; max_n = 0; auto preprocess = [\u0026amp;](int n) -\u0026gt; void { if (n \u0026lt;= max_n) return; fac.resize(n + 1); inv_fac.resize(n + 1); for (int i = max_n + 1; i \u0026lt;= n; ++i) fac[i] = 1LL * fac[i - 1] * i % MOD; inv_fac[n] = 1; int base = fac[n], power = MOD - 2; while (power) { if (power \u0026amp; 1) inv_fac[n] = 1LL * inv_fac[n] * base % MOD; base = 1LL * base * base % MOD; power \u0026gt;\u0026gt;= 1; } for (int i = n - 1; i \u0026gt; max_n; --i) inv_fac[i] = 1LL * inv_fac[i + 1] * (i + 1) % MOD; max_n = n; }; auto comb = [\u0026amp;](int n, int k) -\u0026gt; int { if (k \u0026lt; 0 || k \u0026gt; n) return 0; preprocess(n); // 确保已经预处理到n return 1LL * fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD; }; int a, b, c, d; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int ans = 0; for (int i = 0; i \u0026lt;= b; ++i) { // 多出来几个 B ? int m = b - i; ll ab = comb(a + m - 1, a - 1); ll bcd = comb(c + d + i, c); (ans += static_cast\u0026lt;int\u0026gt;(ab * bcd % MOD)) %= MOD; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } F 题意：给定 一颗树，每个结点有权值\n给定两个操作：\n将 x 节点的权值变为y 将 x 边断开，输出两个联通分量的权值和之差 做法:\n先计算DFS序 每个节点断开后连通分量的权值转化为区间和 利用树状数组或者线段树维护去进行计算即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;ll\u0026gt; fen(n * 2 + 1); auto query = [\u0026amp;](int i) -\u0026gt; ll { ll ans = 0; for (int j = i; j; j -= lowbit(j)) ans += fen[j]; return ans; }; auto add = [\u0026amp;](int i, ll x) -\u0026gt; void { for (int j = i; j \u0026lt;= 2 * n; j += lowbit(j)) fen[j] += x; }; auto range_sum = [\u0026amp;](int x, int y) -\u0026gt; ll { return query(y) - query(x - 1); }; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; qwq(n + 1); std::vector\u0026lt;PII\u0026gt; edges; for (int i = 0; i \u0026lt; n - 1; ++i) { int u, v; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; edges.push_back({u, v}); qwq[u].emplace_back(v); qwq[v].emplace_back(u); } std::cin \u0026gt;\u0026gt; m; std::vector\u0026lt;PII\u0026gt; tmp(n + 1); int z = 0; std::vector\u0026lt;int\u0026gt; depth(n + 1, -1); depth[1] = 0; auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;dfs, int i, int fa) -\u0026gt; void { tmp[i].first = ++z; for (auto x : qwq[i]) { if (x != fa) { depth[x] = depth[i] + 1; dfs(dfs, x, i); } } tmp[i].second = ++z; }; dfs(dfs, 1, 1); for (int i = 1; i \u0026lt; 2 * n + 1; ++i) add(i, 1); for (int i = 0; i \u0026lt; m; ++i) { int op; std::cin \u0026gt;\u0026gt; op; if (op == 1) { int x, w; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; w; add(tmp[x].first, w); add(tmp[x].second, w); } else { int y; std::cin \u0026gt;\u0026gt; y; auto [a, b] = edges[y - 1]; y = std::max(a, b); std::cout \u0026lt;\u0026lt; std::abs(query(2 * n) - 2 * range_sum(tmp[y].first, tmp[y].second)) / 2 \u0026lt;\u0026lt; ln; } } }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } ","date":"2025-05-17T00:00:00Z","permalink":"https://allergy27.github.io/p/abc_406/","title":"AtCoder Beginner Contest 406 A-F 题解"},{"content":"前言 比赛链接：https://atcoder.jp/contests/abc405\n题目类型 A：签到 B：贪心 C：前缀和 D：BFS E：组合数\nC++模板（除主函数部分）\r1 2 3 4 5 6 7 8 9 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln \u0026#39;\\n\u0026#39; #define PII std::pair\u0026lt;int, int\u0026gt; #define judge(x) std::cout \u0026lt;\u0026lt; ((x) ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;) using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; A 题意：给定 R X ，判断：\nR == 1 时是否 1600 \u0026lt;= X \u0026lt;= 2999\nR == 2 时是否 1200 \u0026lt;= X \u0026lt;= 2399\n做法:\n按题意输出 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; judge((m == 1 \u0026amp;\u0026amp; 1600 \u0026lt;= n \u0026amp;\u0026amp; n \u0026lt;= 2999) || (m == 2 \u0026amp;\u0026amp; 1200 \u0026lt;= n \u0026amp;\u0026amp; n \u0026lt;= 2399)); }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } B 题意： 给定一个长度为 $N$ 的整数序列 $A = (A_1, A_2, \\dots, A_N)$ 和一个正整数 $M$\n每次删除 $A$ 的最后一个元素，求使 $A$ 包含从 $1$ 到 $M$ 的所有整数为假最少需要的运算次数。\n做法:\n从前往后遍历，找到第一次能使得 $A$ 包含从 $1$ 到 $M$ 的所有整数的索引 输出长度 - 索引 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; qwq(m); int tmp = 0, ans = 0; for (int i = 0; i \u0026lt; n; ++i) { int x; std::cin \u0026gt;\u0026gt; x; if (qwq[x - 1]++ == 0 \u0026amp;\u0026amp; ++tmp == m) ans = n - i; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } C 题意：给定 $A = (A_1, A_2, \\dots, A_N)$\n计算 $\\displaystyle \\sum_{1\\leq i\u003c j\\leq N} A_iA_j$\n做法:\n转化成前缀和，求解即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;ll\u0026gt; qwq(n), qaq(n + 1); for (auto \u0026amp;x : qwq) std::cin \u0026gt;\u0026gt; x; for (int i = 0; i \u0026lt; n; ++i) qaq[i + 1] = qaq[i] + qwq[i]; ll ans = 0; for (int i = 0; i \u0026lt; n; ++i) ans += qwq[i] * (qaq[n] - qaq[i + 1]); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } D 题意：给定入口出口，打印出口方向，使得按方向走一定能到某一出口\n做法:\nBFS搜即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;std::string\u0026gt; ss(n); for (int i = 0; i \u0026lt; n; ++i) std::cin \u0026gt;\u0026gt; ss[i]; std::vector qwq(n + 2, std::vector\u0026lt;char\u0026gt;(m + 2)); std::queue\u0026lt;PII\u0026gt; que; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { if (ss[i][j] == \u0026#39;E\u0026#39;) que.push({i + 1, j + 1}); qwq[i + 1][j + 1] = ss[i][j]; } } // BFS const int WAY[5] = {-1, 0, 1, 0, -1}; const char QWQ[4] = {\u0026#39;v\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;^\u0026#39;, \u0026#39;\u0026gt;\u0026#39;}; while (!que.empty()) { auto [x, y] = que.front(); que.pop(); for (int i = 0; i \u0026lt; 4; ++i) { int p = x + WAY[i], q = y + WAY[i + 1]; if (qwq[p][q] == \u0026#39;.\u0026#39;) { qwq[p][q] = QWQ[i]; que.push({p, q}); } } } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) std::cout \u0026lt;\u0026lt; qwq[i][j]; std::cout \u0026lt;\u0026lt; ln; } }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } D 题意：给定 A个A球，B个B球，C个C球，D个D球\nA 球在 C、D 左边，B 在 D 左边\n求有多少排法\n做法:\n先放AD，再放B，计算有多少多出来的 B 球 多出来的B‘ + D 就是 C 可以放的位置 利用公式 $\\binom{n}{n+m}$ 计算即可 其中 m 表示要放的数量，n表示放好的数量 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { const int MOD = 998244353; std::vector\u0026lt;int\u0026gt; fac, inv_fac; int max_n = 1; fac = {1}; inv_fac = {1}; max_n = 0; auto preprocess = [\u0026amp;](int n) -\u0026gt; void { if (n \u0026lt;= max_n) return; fac.resize(n + 1); inv_fac.resize(n + 1); for (int i = max_n + 1; i \u0026lt;= n; ++i) fac[i] = 1LL * fac[i - 1] * i % MOD; inv_fac[n] = 1; int base = fac[n], power = MOD - 2; while (power) { if (power \u0026amp; 1) inv_fac[n] = 1LL * inv_fac[n] * base % MOD; base = 1LL * base * base % MOD; power \u0026gt;\u0026gt;= 1; } for (int i = n - 1; i \u0026gt; max_n; --i) inv_fac[i] = 1LL * inv_fac[i + 1] * (i + 1) % MOD; max_n = n; }; auto comb = [\u0026amp;](int n, int k) -\u0026gt; int { if (k \u0026lt; 0 || k \u0026gt; n) return 0; preprocess(n); // 确保已经预处理到n return 1LL * fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD; }; int a, b, c, d; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int ans = 0; for (int i = 0; i \u0026lt;= b; ++i) { // 多出来几个 B ? int m = b - i; ll ab = comb(a + m - 1, a - 1); ll bcd = comb(c + d + i, c); (ans += static_cast\u0026lt;int\u0026gt;(ab * bcd % MOD)) %= MOD; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } ","date":"2025-05-11T00:00:00Z","permalink":"https://allergy27.github.io/p/abc_405/","title":"AtCoder Beginner Contest 405 A-E 题解"},{"content":"前言 比赛链接：https://codeforces.com/contest/2102\n题目类型 A：数学 B：贪心 C：构造 D：排序\n差半小时搓求逆序对，可惜\nC++模板（除主函数部分）\r1 2 3 4 5 6 7 8 9 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln \u0026#39;\\n\u0026#39; #define PII std::pair\u0026lt;int, int\u0026gt; #define judge(x) std::cout \u0026lt;\u0026lt; ((x) ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;) using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; A 题意：给定四个整数 n 、 m 、 p 和 q\n判断是否存在数组中所有元素的和等于 m ，每 p 个连续元素之和等于 q 的整数数组 $a_1, a_2, \\ldots, a_n$ (元素可以是负数)\n做法:\n数学，每 p 个的和为 q 那么如果 $m \\neq n\\div p \\times q$ 并且 $ p \\mid n$，则不存在 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m, p, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; judge(!(n / p * q != m \u0026amp;\u0026amp; (n % p == 0))); }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } B 题意：给你一个数组 $a_1, a_2, \\ldots, a_n$\n每次可以将其中的任意数 $a_i := -a_i$\n判断能否让 $a_1$ 变为中位数 即第 $\\left\\lceil \\frac{n}{2} \\right\\rceil$ 大的数\n做法:\n思维题，先将所有数变绝对值后排序 如果第一个数 $\\leq$ 中位数，则一定可以操作后变中位数 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) { std::cin \u0026gt;\u0026gt; x; x = std::abs(x); } int tmp = qwq[0]; std::sort(qwq.begin(), qwq.end()); judge(qwq[n / 2] \u0026gt;= tmp); }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } C 题意：给定n*n网格，其中包含 1 - n*n 的排列\n求出排列后所有子网格的MEX和最大\n做法:\n正中央的数会被最多网格包裹，将小的放中间大的放外面 可以排一个螺旋矩阵 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n; std::vector qwq(n, std::vector\u0026lt;int\u0026gt;(n)); int num = n * n - 1; int left = 0, right = n - 1, top = 0, bottom = n - 1; while (left \u0026lt;= right \u0026amp;\u0026amp; top \u0026lt;= bottom) { for (int i = left; i \u0026lt;= right; ++i) qwq[top][i] = num--; top++; for (int i = top; i \u0026lt;= bottom; ++i) qwq[i][right] = num--; right--; for (int i = right; i \u0026gt;= left; --i) qwq[bottom][i] = num--; bottom--; for (int i = bottom; i \u0026gt;= top; --i) qwq[i][left] = num--; left++; } for (auto x : qwq) { for (auto y : x) std::cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; ln; } }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } D 题意：给定操作 a,b,c,d = c,d,a,b\n将数组排序为字典序最小\n做法:\n奇偶不会改变，单独拿出来 观察发现每三个数之间是循环移位排序，且不影响奇偶不同的位 正常排序，逆序对数为奇则交换最后两位 重新排回去即可 点击展开代码（树状数组求逆序对）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n; // FenwickTree std::vector\u0026lt;int\u0026gt; fen(n + 1); auto add = [\u0026amp;](int i, int w) -\u0026gt; void { for (int x = i; x \u0026lt;= n; x += lowbit(x)) fen[x] += w; }; auto query = [\u0026amp;](int i) -\u0026gt; int { int ans = 0; for (int x = i; x; x -= lowbit(x)) ans += fen[x]; return ans; }; auto qwq_sort = [\u0026amp;](std::vector\u0026lt;int\u0026gt; \u0026amp;qwq) -\u0026gt; void { std::fill(fen.begin(), fen.end(), 0); int tmp = 0, n = qwq.size(); for (int i = n - 1; i \u0026gt;= 0; --i) { tmp += query(qwq[i]); add(qwq[i], 1); } std::sort(qwq.begin(), qwq.end()); if ((tmp % 2) \u0026amp;\u0026amp; n \u0026gt;= 2) std::swap(qwq[n - 1], qwq[n - 2]); }; std::vector\u0026lt;int\u0026gt; qwq; std::array\u0026lt;std::vector\u0026lt;int\u0026gt;, 2\u0026gt; tmp; for (int i = 0; i \u0026lt; n; ++i) { int x; std::cin \u0026gt;\u0026gt; x; tmp[i \u0026amp; 1].emplace_back(x); } qwq_sort(tmp[0]), qwq_sort(tmp[1]); std::array\u0026lt;int, 2\u0026gt; cnt = {0, 0}; for (int i = 0; i \u0026lt; n; ++i) qwq.emplace_back(tmp[i \u0026amp; 1][cnt[i \u0026amp; 1]++]); if (qwq[n - 4] \u0026gt; qwq[n - 2]) { std::swap(qwq[n - 4], qwq[n - 2]); std::swap(qwq[n - 3], qwq[n - 1]); } for (auto x : qwq) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cout \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; _; return 0; } 点击展开代码（归并排序求逆序对）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 int merge_sort(std::vector\u0026lt;int\u0026gt;\u0026amp; qwq, int l, int r) { if (l \u0026gt;= r) return 0; int mid = l + (r - l) / 2; int cnt = 0; // 统计奇偶性 (cnt += merge_sort(qwq, l, mid)) %= 2; (cnt += merge_sort(qwq, mid + 1, r)) %= 2; // merge std::vector\u0026lt;int\u0026gt; tmp(r - l + 1); int i = l, j = mid + 1, k = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (qwq[i] \u0026lt;= qwq[j]) { tmp[k++] = qwq[i++]; } else { tmp[k++] = qwq[j++]; (cnt += mid - i + 1) %= 2; } } while (i \u0026lt;= mid) tmp[k++] = qwq[i++]; while (j \u0026lt;= r) tmp[k++] = qwq[j++]; for (i = l, k = 0; i \u0026lt;= r; ++i, ++k) qwq[i] = tmp[k]; return cnt; } void qwq_sort(std::vector\u0026lt;int\u0026gt;\u0026amp; qwq) { int n = qwq.size(); int now = merge_sort(qwq, 0, n - 1); if ((now % 2) \u0026amp;\u0026amp; (n \u0026gt;= 2)) std::swap(qwq[n - 1], qwq[n - 2]); } int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; qwq(n), ans; for (auto\u0026amp; x : qwq) std::cin \u0026gt;\u0026gt; x; auto to = [\u0026amp;](int i) { std::swap(ans[i], ans[i + 2]); std::swap(ans[i + 1], ans[i + 3]); }; std::vector tmp(2, std::vector\u0026lt;int\u0026gt;()); for (int i = 0; i \u0026lt; n; ++i) tmp[i \u0026amp; 1].emplace_back(qwq[i]); for (int i = 0; i \u0026lt; 2; ++i) qwq_sort(tmp[i]); int cnt[] = {0, 0}; for (int i = 0; i \u0026lt; n; ++i) ans.emplace_back(tmp[i \u0026amp; 1][cnt[i \u0026amp; 1]++]); if (ans[n - 4] \u0026gt; ans[n - 2]) to(n - 4); for (auto x : ans) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } ","date":"2025-05-11T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_1024_div2/","title":"CodeForces Round 1024 Div2 A-D 题解"},{"content":"前言 比赛链接：https://ac.nowcoder.com/acm/contest/109081\n题目类型 A：输入 B：贪心 C：深搜 D：贪心 E：树形DP F: 数学\n吃完饭才开始打，一开始没进状态吧 D做差了，可以写得更好的 E - G 赛时没看，打杀机去了（ C++模板（除主函数部分）\r1 2 3 4 5 6 7 8 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln std::endl #define PII std::pair\u0026lt;int, int\u0026gt; using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; A 题意：给你一些编号，然后给你一串 X/Y 形式的数字，找出对应 X 最大的编号\n做法:\n考察输入输出的题，简单题简单做，方法很多 可以用 scanf(\u0026quot;%d/%d\u0026quot;) 来取数，也可以 cin \u0026gt;\u0026gt; int \u0026gt;\u0026gt; char \u0026gt;\u0026gt; int 来取数 另外，对于py可以 map(int,s.split('/')) 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;char\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) std::cin \u0026gt;\u0026gt; x; int ans = 0, res = 0; for (int i = 0; i \u0026lt; n; ++i) { int tmp, _nm; char _s; std::cin \u0026gt;\u0026gt; tmp \u0026gt;\u0026gt; _s \u0026gt;\u0026gt; _nm; if (tmp \u0026gt; res) res = tmp, ans = i; } std::cout \u0026lt;\u0026lt; qwq[ans] \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } B 题意：给定行和列值，每次能将一整行/列变为指定值，不能重复使用\n求矩阵经过变化后最大值\n做法:\n官解直接排序后反复覆盖，每次从最小值开始处理即可 我的解是先把行排上，然后看每个列能增加多少 二分看能排到谁然后用前缀和运算得到答案 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; r(n); std::vector\u0026lt;int\u0026gt; c(m); for (auto \u0026amp;x : r) std::cin \u0026gt;\u0026gt; x; for (auto \u0026amp;x : c) std::cin \u0026gt;\u0026gt; x; std::sort(r.begin(), r.end()); std::sort(c.begin(), c.end()); int ans = 0; for (int i = 0; i \u0026lt; m; ++i) ans += c[i] * n; std::vector\u0026lt;int\u0026gt; qaq(m + 1); for (int i = 0; i \u0026lt; m; ++i) qaq[i + 1] = qaq[i] + c[i]; for (int i = 0; i \u0026lt; n; ++i) { int p = std::lower_bound(c.begin(), c.end(), r[i]) - c.begin(); ans += r[i] * p - qaq[p]; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } C 题意：A B 在树上赛跑，从 k 开始跑，到叶子节点时只能回头\nA 先跑一步，之后 A B 同时跑，问 B 何时追上 A\n做法:\n转换为以 k 为根的树深度为多少 DFS即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; qwq(n); for (int i = 1; i \u0026lt; n; ++i) { int u, v; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; qwq[u - 1].emplace_back(v - 1); qwq[v - 1].emplace_back(u - 1); } auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;dfs, int u, int fa, int ans) -\u0026gt; int { int res = ans; for (auto x : qwq[u]) { if (x == fa) continue; res = std::max(res, dfs(dfs, x, u, ans + 1)); } return res; }; std::cout \u0026lt;\u0026lt; dfs(dfs, m - 1, m - 1, 1) \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } D 题意：给定长度为1-16的二进制字符串，每个都可以无限拼接自己\n问是否有一个索引所有字符串在该位都是1\n做法:\n先计算最小公倍数，这个数就是所有需要考察的索引 接着合并每个同长度的字符串 然后遍历索引，看看各个长度下该位置是否为1 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int end = 720720; // LCM of 1-16 : 16 * 9 * 5 * 7 * 11 * 13 int n, m; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; find(16); for (int i = 0; i \u0026lt; 16; ++i) find[i] = (1 \u0026lt;\u0026lt; (i + 1)) - 1; for (int i = 0; i \u0026lt; n; ++i) { std::string s; std::cin \u0026gt;\u0026gt; s; int sz = s.size(), tmp = 0; for (int x = 0; x \u0026lt; sz; ++x) tmp |= (s[x] - \u0026#39;0\u0026#39;) \u0026lt;\u0026lt; x; find[sz - 1] \u0026amp;= tmp; } for (int i = 0; i \u0026lt; end; ++i) { bool flag = true; for (int x = 0; x \u0026lt; 16; ++x) { int tmp = i % (x + 1); if (!(find[x] \u0026amp; (1 \u0026lt;\u0026lt; tmp))) { flag = false; break; } } if (flag) { std::cout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; ln; return; } } std::cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } E 题意：在 C 的基础上，现在可以往树上多加一条边\n问有多少种加边的方案可以让两人不相邻\n做法:\n关键在于发现如果形成 4 5 6 的环则有办法不相邻 题目转化为有多少简单路径长度为 3 4 5 树上DP去找即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; // std::cin \u0026gt;\u0026gt; _; auto solve = [\u0026amp;]() -\u0026gt; void { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; --m; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; qwq(n); for (int i = 1; i \u0026lt; n; ++i) { int u, v; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; qwq[u - 1].emplace_back(v - 1); qwq[v - 1].emplace_back(u - 1); } std::vector dp(n, std::vector\u0026lt;int\u0026gt;(5)); // dp[u][k] 父节点到 u 长度为 k ,有多少条 int ans = 0; auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;dfs, int u, int fa) -\u0026gt; void { dp[u][0] = 1; for (auto v : qwq[u]) { if (v == fa) continue; dfs(dfs, v, u); for (int i = 2; i \u0026lt; 5; ++i) { // 到父节点 + 到子节点路径为2/3/4 for (int j = 0; j \u0026lt;= i; ++j) ans += dp[u][j] * dp[v][i - j]; } for (int i = 0; i \u0026lt; 4; ++i) // 到字节点路径都统计到父节点上 dp[u][i + 1] += dp[v][i]; } return; }; dfs(dfs, m, m); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; return 0; } F 题意：将 1-n 的排列重新排列为环形数组，相邻差为奇素数\n输出这个排列\n做法:\n考虑一个奇素数 p ，那么这个排列即为： 1 1+p 1+2p 1+3p ... 1+kp 最后肯定会大于n，所以考虑取模 会变成形如 n - p + 1 ，所以只要 n-p 也是奇素数即可 题目转化为判断是否存在奇素数 p , n-p 也是奇素数 线性筛筛完判断即可 特别的，n \u0026lt; 8 是无解的，需要特判，比如 6 会错误的找到 p = 3 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int _ = 1; std::cin \u0026gt;\u0026gt; _; auto sieve = [](int n) -\u0026gt; std::pair\u0026lt;std::vector\u0026lt;int\u0026gt;, std::vector\u0026lt;bool\u0026gt;\u0026gt; { std::vector\u0026lt;int\u0026gt; prime; std::vector\u0026lt;bool\u0026gt; not_prime(n + 1); for (int i = 2; i \u0026lt;= n; ++i) { if (!not_prime[i]) prime.emplace_back(i); for (auto x : prime) { if (i * x \u0026gt; n) break; not_prime[i * x] = true; if (i % x == 0) break; } } return {prime, not_prime}; }; auto [prime, not_prime] = sieve(270000); for (int i = 0; i \u0026lt; 3; ++i) not_prime[i] = true; auto solve = [\u0026amp;]() { int n, m; std::cin \u0026gt;\u0026gt; n; for (auto x : prime) { if (n \u0026lt; 8 || x \u0026gt;= n) { std::cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; ln; return; } if (!not_prime[n - x] \u0026amp;\u0026amp; !not_prime[x]) { int tmp = 1; for (int i = 0; i \u0026lt; n; ++i) { std::cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; \u0026#39; \u0026#39;; ((tmp += x - 1) %= n) += 1; } std::cout \u0026lt;\u0026lt; ln; return; } } }; while (_--) solve(); std::cin \u0026gt;\u0026gt; _; } ","date":"2025-05-10T00:00:00Z","permalink":"https://allergy27.github.io/p/nc_pre_138/","title":"牛客练习赛138 题解A-F"},{"content":"前言 比赛链接：https://codeforces.com/contest/2098\n题目类型 A：贪心 B：排序 C：贪心 D：并查集\n马上比赛，全用的C++了\nC++模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln std::endl #define int int64_t #define PII std::pair\u0026lt;int, int\u0026gt; using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; void solve() { } signed main() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); int t = 1; std::cin \u0026gt;\u0026gt; t; while (t--) solve(); std::cin \u0026gt;\u0026gt; t; return 0; } A 题意：找出排序后各位分别≥9876543210的最小数\n做法:\n贪心做，每次找大于等于9 - i的最小数，不难想到二分找（其实遍历也行，范围只有10 然后记得每次找完要删 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 void solve() { std::string n; std::cin \u0026gt;\u0026gt; n; std::map\u0026lt;int, int\u0026gt; qwq; for (auto x : n) qwq[x - \u0026#39;0\u0026#39;]++; for (int i = 0; i \u0026lt; 10; ++i) { auto x = qwq.lower_bound(9 - i); std::cout \u0026lt;\u0026lt; x-\u0026gt;first; if (--x-\u0026gt;second == 0) qwq.erase(x); } std::cout \u0026lt;\u0026lt; ln; } B 题意：定义f(x)为 $\\sum^{n - 1}_{i=0}|x - a_i|$\n求最多删去 k 的情况下，最多有多少x满足f(x)在当前情况下为最小值\n做法:\n思维题，想到其实就是求中位数 排序，找到左右中位数位置，然后相减 点击展开代码\r1 2 3 4 5 6 7 8 9 void solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) std::cin \u0026gt;\u0026gt; x; std::sort(qwq.begin(), qwq.end()); int l = (n - m - 1) / 2, r = m + (n - m) / 2; std::cout \u0026lt;\u0026lt; qwq[r] - qwq[l] + 1 \u0026lt;\u0026lt; ln; } C 题意：共 n 人猜 $a_i$ 的天气，需要根据每个人的预测预测 $a_{i+1}$ 和 $a_{i+2}$ 两天\n问是否有一种方案能保证一定能预测对 $a_{i+1}$ 和 $a_{i+2}$ 两天\n做法:\n如果有两个相同的天，就能通过10 11 或者 01 11 来确定前面天或者后面天 如果前面被确定且当前天被确定就一定能预测 如果前面被确定且当前天只有一个则传递确定性 不能预测报告 No 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void solve() { int n, m; std::cin \u0026gt;\u0026gt; n; std::map\u0026lt;int, int\u0026gt; qwq; for (int i = 0; i \u0026lt; n; ++i) { int x; std::cin \u0026gt;\u0026gt; x; ++qwq[x]; } bool ck = false; int pre = -1; for (auto [x, y] : qwq) { if ((y \u0026gt;= 4) || (ck \u0026amp;\u0026amp; x == pre + 1 \u0026amp;\u0026amp; y \u0026gt;= 2)) { std::cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; ln; return; } ck = (ck \u0026amp;\u0026amp; x == pre + 1) || y \u0026gt;= 2; pre = x; } std::cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; ln; } D 题意：给定k个奇数放入网格中，需要放入剩下的偶数，问多少种方法能保证形成一笔画\n(一笔画指从头到尾相邻不重叠)\n做法:\n可以转换为连通分量问题 曼哈顿距离≠2报告 0 不然在可以放置的两个位置连边（也可能一个位置，也连） 判断各个联通分量大小，等于边数不自环就 $*2$ ，小于报告 0 ，大于按乘法原理乘 记得 %= 1e9 + 7 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 void solve() { const int MOD = 1e9 + 7; int n, m, k; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; UFSet uf(n * m); auto to = [\u0026amp;](int x, int y) { return (x - 1) * m + y; }; std::vector\u0026lt;PII\u0026gt; qwq(k + 1); for (auto \u0026amp;[x, y] : qwq) std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; std::vector\u0026lt;int\u0026gt; cnt(n * m + 1), ring(n * m + 1); for (int i = 1; i \u0026lt;= k; ++i) { auto [x1, y1] = qwq[i - 1]; auto [x2, y2] = qwq[i]; if (std::abs(x1 - x2) + std::abs(y1 - y2) != 2) { std::cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; ln; return; } // 确定要连的边 int u, v; if (std::abs(x1 - x2) == 1) // 斜向 u = to(x1, y2), v = to(x2, y1); else if (x1 == x2) u = to(x1, (y1 + y2) / 2), v = to(x1, (y1 + y2) / 2); else u = to((x1 + x2) / 2, y1), v = to((x1 + x2) / 2, y1); if (!uf.same(u, v)) { cnt[uf.find(u)] += cnt[uf.find(v)]; // 连通分量大小 ring[uf.find(u)] |= ring[uf.find(v)]; uf.merge(u, v); } ++cnt[uf.find(u)]; if (u == v) ring[uf.find(u)] = 1; } int ans = 1; for (int i = 0; i \u0026lt;= n * m; ++i) { if (uf.find(i) != i) continue; int tmp = uf.size(i); if (tmp \u0026lt; cnt[i]) { // 点小于边 ans = 0; break; } else if (tmp == cnt[i]) { // 点等于边 if (!ring[i]) (ans *= 2) %= MOD; // 没自环就*2 } else { (ans *= tmp) %= MOD; // 不然就乘法原理 } } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } ","date":"2025-05-09T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_1021_div2/","title":"CodeForces Round 1021 Div2 A-D 题解"},{"content":"CodeForces Round 988 Div3 A-E 题解 比赛链接：https://codeforces.com/contest/2037\n题目类型 A：签到-哈希表 B：签到-哈希集合 C：思维-构造 D：优先队列 E：交互-观察\n说明 写给自己看的，全文Rust代码，善用GPT翻译 D做差了，E赛时没敲上 还是D题没发挥好导致的，节奏断了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 数组模拟哈希表即可\n做法:\n数组模拟哈希表，每个值$/2$后加入答案 点击展开代码\r1 2 3 4 5 6 7 8 9 10 fn solve() { let n = cin!(usize); let qwq = cin!([usize; n]); let mut qaq = vec![0; n + 1]; for i in 0..n { qaq[qwq[i]] += 1; } let ans = qaq.into_iter().map(|x| x / 2).sum::\u0026lt;usize\u0026gt;(); println!(\u0026#34;{ans}\u0026#34;) } B 哈希集合\n做法:\n类似Leetcode两数之和问题，一次遍历 每次没能找到相乘为目标值的放入集合 能找到就输出 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize) - 2; let qwq = cin!([usize; n + 2]); let mut qaq = std::collections::HashSet::new(); for i in \u0026amp;qwq { if n % i == 0 \u0026amp;\u0026amp; qaq.contains(\u0026amp;(n / *i)) { println!(\u0026#34;{} {}\u0026#34;, i, n / i); return; } qaq.insert(i); } } C 构造\n做法:\n偶数一定合数，构造偶数即可 奇偶分组，找最小的满足奇偶相加为合数的数 发现是 4 5 构造即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn solve() { let n = cin!(usize); if n \u0026lt; 5 { println!(\u0026#34;-1\u0026#34;); } else { for i in 1..=n { if i != 5 \u0026amp;\u0026amp; i % 2 == 1 { print!(\u0026#34;{} \u0026#34;, i); } } print!(\u0026#34;5 4 \u0026#34;); for i in 1..=n { if i != 4 \u0026amp;\u0026amp; i % 2 == 0 { print!(\u0026#34;{} \u0026#34;, i); } } println!() } } D 事件合并后放入优先队列\n做法:\n先合并事件，按坐标从小到大排序 增益记作 0 事件，障碍记作 1 事件 每次需要跨障碍从队列中取出最大的 若空则 -1 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 fn solve() { let (l, m, n) = cin!(usize, usize, usize); let mut qwq = Vec::with_capacity(l); for _ in 0..l { qwq.push(cin!(usize, usize)); } let mut qaq = Vec::with_capacity(m); for _ in 0..m { qaq.push(cin!(usize, usize)); } // 合并事件: 增益 障碍 结束 终点 let mut events = Vec::new(); for \u0026amp;(l, r) in \u0026amp;qwq { events.push((l, 1, r - l + 1)); } for \u0026amp;(x, v) in \u0026amp;qaq { events.push((x, 0, v)); } events.push((n, 2, 0)); // 终点 events.sort_unstable_by(|a, b| a.0.cmp(\u0026amp;b.0)); let mut k = 1; let mut heap = std::collections::BinaryHeap::new(); let mut ans = 0; for (_, t, v) in events { if t == 0 { heap.push(v); } else if t == 1 { while k \u0026lt;= v { if let Some(top) = heap.pop() { k += top; ans += 1; } else { println!(\u0026#34;-1\u0026#34;); return; } } } else { println!(\u0026#34;{ans}\u0026#34;); } } } E 交互题\n反思:\n依然是漏判情况导致出锅\n做法:\n先找第一个满足不为0的，找不到就输出 -1 再看这个值是多少，往前面填111100这样 接着后面的值更大说明是 1 相等说明是 0 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn solve() { let n = cin!(usize); let query = |l: usize, r: usize| { println!(\u0026#34;? {} {}\u0026#34;, l + 1, r + 1); std::io::Write::flush(\u0026amp;mut std::io::stdout()).unwrap(); cin!(i64) }; let mut qwq = Vec::new(); let mut zro = -1; for i in 1..n { let x = query(0, i); if zro == -1 { if x != 0 { qwq.resize((i as i64 - x) as usize, 1); qwq.resize(i, 0); zro = x; qwq.push(1); } } else if x == zro { qwq.push(0); } else { zro = x; qwq.push(1); } } if zro != -1 { print!(\u0026#34;! \u0026#34;); qwq.iter().for_each(|\u0026amp;x| print!(\u0026#34;{}\u0026#34;, x)); println!() } else { println!(\u0026#34;! IMPOSSIBLE\u0026#34;) } } ","date":"2024-11-17T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_988_div3/","title":"CodeForces_988_div3"},{"content":"CodeForces Round 987 Div2 A-D 题解 比赛链接：https://codeforces.com/contest/2031\n题目类型 A：签到-LIS B：签到-思维 C：思维-构造 D：前后缀分解\n说明 写给自己看的，全文Rust代码，善用GPT翻译 发挥不够好，还是昏昏沉沉的，会的太少了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题-LIS\n反思:\n赛时看出是单调栈，没看出最长递增子序列难绷 签到没签上，意难平 做法:\n最长不下降子序列，有提前写好的二分+单调栈板子 找出最长不下降子序列长度，把其他部分变得和这个序列一样即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fn solve() { let n = cin!(usize); println!(\u0026#34;{}\u0026#34;, n - lis(cin!([usize; n])).len()); } fn lis\u0026lt;T: Ord + Copy\u0026gt;(nums: Vec\u0026lt;T\u0026gt;) -\u0026gt; Vec\u0026lt;T\u0026gt; { nums.iter().fold(vec![], |mut x, \u0026amp;y| { if x.is_empty() || *x.last().unwrap() \u0026lt;= y { x.push(y) } else { let i = x.partition_point(|\u0026amp;v| v \u0026lt;= y); x[i] = y; } x }) } B 签到-思维\n做法:\n索引和值相差超过1肯定就不行 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize); let p = cin!([i32; n]); let mut flag = \u0026#34;YES\u0026#34;; for (i, elem) in p.iter().enumerate() { if elem.abs_diff(i as i32 + 1) \u0026gt; 1 { flag = \u0026#34;NO\u0026#34;; break; } } println!(\u0026#34;{flag}\u0026#34;); } C 思维-构造\n做法:\n偶数只要一直1 1 2 2 ..即可 考虑最小的奇数情况： 找到三个数a b c，满足a*a+b*b=c*c即可 不难发现最小的时候即3 4 5，对应完全平方数9 16 25 但25时，一共26个数，为偶数，不满足条件，需要到27 我们构造1 2 2 .. 5 5 1 6 6 .. 11 11 12 13 13 1 12 即可 此时即为最小的满足条件的奇数情况 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn solve() { let n = cin!(usize); if n % 2 == 0 { for i in 0..n / 2 { print!(\u0026#34;{} {} \u0026#34;, i + 1, i + 1); } println!() } else if n \u0026lt; 27 { println!(\u0026#34;-1\u0026#34;); } else { print!(\u0026#34;1 2 2 3 3 4 4 5 5 1 6 6 7 7 8 8 9 9 10 10 11 11 12 13 13 1 12 \u0026#34;); for i in 14..=n / 2 { print!(\u0026#34;{} {} \u0026#34;, i, i); } println!() } } D 前后缀分解+前缀和\n做法:\n从前往后维护向前跳最高为多少 从后往前维护向后跳最矮为多少 接着进行一次遍历 每当遇到最小值，将前面的值全部初始化为最小值的向前跳最大值 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 fn solve() { let n = cin!(usize); let qwq = cin!([i32; n]); let mut pre = vec![-1; n + 1]; for i in 0..n { pre[i + 1] = pre[i].max(qwq[i]) } let mut suf = vec![n as i32 + 1; n + 1]; for i in (0..n).rev() { suf[i] = suf[i + 1].min(qwq[i]) } let mut ans = vec![-1; n]; let mut last = 0; for i in 1..=n { //往右找不到更小值，说明当前值最小 if pre[i] \u0026lt;= suf[i] { for elem in ans.iter_mut().take(i).skip(last) { *elem = pre[i]; } last = i; } } ans.iter().for_each(|x| print!(\u0026#34;{x} \u0026#34;)); println!() } ","date":"2024-11-15T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_987_div2/","title":"CodeForces_987_div2"},{"content":"Day 1. Number Theory 主要讲素数相关的一些内容\nLesson 课程内容部分\n分段筛法 Problem:\n题目大意：求区间 [L,R] 中的素数，$[L,R]$ 范围在 $10^{12}$ 左右，$R-L \\leq 10^{6}$\nSolution:\n分段筛法：\n先用线性筛筛出$[2,\\sqrt{R}]$区间内的素数\n再找到左右区间，区间内每个点检验是否是筛出的小区间的素数的倍数 左端点向上取整，右端点向下取整，避免超出索引\n莫比乌斯函数 核心思想：包含-排除思想，在容斥原理中有深刻应用\n算法核心:\n$\\mu(1) = 1$\n$\\mu(n) = (-1)^k$ n为k个质数的乘积\n$\\mu(n) = 0$ n含平方因子\n另外，稍微改改就变成欧拉函数了\nProblem:\n截图\n题目大意：\nSolution:\n莫比乌斯函数\nBurnside\u0026rsquo;s 引理 Problem:\n截图\n题目大意：\nSolution:\n-todo-\nPolya定理 Problem:\n截图\n题目大意：\nSolution:\n-todo-\nMiller-Robin 素性测试 Problem:\n截图\n题目大意：\nSolution:\n-todo-\nPollard-Rho 算法 Problem:\n截图\n题目大意：\nSolution:\n-todo-\nDay 2. FFT and FWHT 主要讲FFT相关的一些内容\nLesson 代办\n","date":"2024-11-15T00:00:00Z","permalink":"https://allergy27.github.io/p/camp_learning/","title":"训练营"},{"content":"CodeForces Round 986 Div2 A-C 题解 比赛链接：https://codeforces.com/contest/2028\n题目类型 A：签到-模拟 B：模拟、数学 C：前后缀分解、前缀和\n说明 写给自己看的，全文Rust代码，善用GPT翻译 发挥不够好，还是昏昏沉沉的，会的太少了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题-模拟\n做法:\n题目数据量小，考虑模拟，假设重复足够次数，然后看看会不会碰上即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 fn solve() { let (_, a, b) = cin!(usize, i64, i64); let s = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let mut tmp = (0, 0); for _ in 0..1000 { // 假设最多重复1000次 for i in \u0026amp;s { match i { \u0026#39;N\u0026#39; =\u0026gt; { tmp.1 += 1; } \u0026#39;E\u0026#39; =\u0026gt; { tmp.0 += 1; } \u0026#39;S\u0026#39; =\u0026gt; { tmp.1 -= 1; } \u0026#39;W\u0026#39; =\u0026gt; { tmp.0 -= 1; } _ =\u0026gt; unreachable!(), } if tmp == (a, b) { println!(\u0026#34;YES\u0026#34;); return; } } } println!(\u0026#34;NO\u0026#34;); } B 模拟+数学\n反思:\n赛时完全没想到怎么举特例，疯魔了 状态不是很好，什么都做不上 还在打草稿的时候把x-1写成x伏笔了 做法:\n先举特例，b=0: c\u0026gt;=n 答案即 n-2 c\u0026gt;=n-2 答案即 n-1 剩余情况无解，输出-1 以及 c\u0026gt;=n ,输出n 剩下为一般情况，需要在区间内找最大的x，使得b(x-1)+c在区间内 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn solve() { let (n, b, c) = cin!(i64, i64, i64); if b == 0 { if c \u0026gt;= n { println!(\u0026#34;{}\u0026#34;, n - 2); } else if c \u0026gt;= n - 2 { println!(\u0026#34;{}\u0026#34;, n - 1); } else { println!(\u0026#34;-1\u0026#34;); } } else if c \u0026gt;= n { println!(\u0026#34;{}\u0026#34;, n); } else { println!(\u0026#34;{}\u0026#34;, n - 0.max(1 + (n - c - 1) / b)); } } C 前后缀分解+前缀和\n做法:\n因为切成m+1份是固定的，所以枚举从前往后切i个的右端点，以及从右往左切i个的左端点，左右端点之间的值就是能拿到的蛋糕值 前缀和维护区间和，复杂度O(n) 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 fn solve() { let (n, m, v) = cin!(usize, usize, usize); let qwq = cin!([usize; n]); let mut qaq = vec![0; n + 1]; for i in 0..n { qaq[i + 1] = qaq[i] + qwq[i]; } let query = |l: usize, r: usize| qaq[r] - qaq[l]; // 从前往后切，第m的右端点（开 let mut f = vec![0; m + 1]; let mut tmp = 0; for i in 1..=m { while tmp as usize \u0026lt;= n \u0026amp;\u0026amp; query(f[i - 1] as usize, tmp as usize) \u0026lt; v { tmp += 1; } f[i] = tmp; } // 从后往前切，第m的左端点（闭 let mut g = vec![n as i32; m + 1]; tmp = n as i32; for i in 1..=m { while tmp \u0026gt;= 0 \u0026amp;\u0026amp; query(tmp as usize, g[i - 1] as usize) \u0026lt; v { tmp -= 1; } g[i] = tmp; } let mut ans = -1; for i in 0..=m { // 符合条件的区间计算能获得的蛋糕 if f[i] \u0026lt;= n as i32 \u0026amp;\u0026amp; g[m - i] \u0026gt;= 0 \u0026amp;\u0026amp; f[i] \u0026lt;= g[m - i] { ans = ans.max(query(f[i] as usize, g[m - i] as usize) as i32) } } println!(\u0026#34;{ans}\u0026#34;); } ","date":"2024-11-11T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_986_div2/","title":"CodeForces_986_div2"},{"content":"CodeForces Round 985 Div1+Div2 A-E 题解 比赛链接：https://codeforces.com/contest/2029\n题目类型 A：签到-二分 B：博弈论 C：动态规划 D：构造 E：构造\n说明 写给自己看的，全文Rust代码，善用GPT翻译 发挥不够好，还是昏昏沉沉的，会的太少了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题-二分/数学\n做法:\n二分查找/数学 找第一个满足k倍\u0026gt;r的数是什么数即可，向下取整 超出的部分肯定是不能删的 二分容错率高，数学想到就好写 二分\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fn solve() { let (l, r, k) = cin!(i64, i64, i64); if k == 1 { println!(\u0026#34;{}\u0026#34;, r - l + 1); return; } let mut a = l; let mut b = r; while a \u0026lt; b { let mid = (a + b) / 2; if mid * k \u0026gt; r { b = mid; } else { a = mid + 1; } } println!(\u0026#34;{}\u0026#34;, a - l); } 数学\r1 2 3 4 fn solve() { let (l, r, k) = cin!(i64, i64, i64); println!(\u0026#34;{}\u0026#34;, ((r / k) - l + 1).max(0)) } B 博弈论\n反思:\n赛时代码太丑陋了 而且基本逻辑也没理清 浪费了好多时间 做法:\n注意到，0/1合并后为1/0，而只要还有另一种数字就可以合并 预处理出个数，跑一遍操作字符串，如果0/1不够说明跑不了 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn solve() { let n = cin!(usize); let a = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let b = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let mut cot = [0, 0]; for i in a { cot[(i as u8 - b\u0026#39;0\u0026#39;) as usize] += 1; } for i in b { let tmp = (i as u8 - b\u0026#39;0\u0026#39;) as usize; if cot[tmp] \u0026gt; 0 \u0026amp;\u0026amp; cot[tmp ^ 1] \u0026gt; 0 { cot[tmp ^ 1] -= 1; } else { println!(\u0026#34;NO\u0026#34;); return; } } println!(\u0026#34;YES\u0026#34;); } 丑陋的赛时代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 fn solve() { let _ = cin!(i64); let a = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let b = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let mut one = 0; let mut zero = 0; for i in a { if i == \u0026#39;0\u0026#39; { one += 1; } else { zero += 1; } } if zero == 0 || one == 0 { println!(\u0026#34;NO\u0026#34;); return; } for i in b { if i == \u0026#39;1\u0026#39; { if one == 0 || zero == 0 { println!(\u0026#34;NO\u0026#34;); return; } one -= 1; } else { if one == 0 || zero == 0 { println!(\u0026#34;NO\u0026#34;); return; } zero -= 1; } } println!(\u0026#34;YES\u0026#34;); } C dp\n做法:\n有最优子结构特征(某个区间跳过与不跳过)可以dp 每次维护未跳过、正跳过、已跳过 未跳过直接转移，正跳过更新为未跳过最大值，已跳过由正跳过和已跳过最大值转移 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(i64); let qwq = cin!([i64; n]); let (mut pre, mut skip, mut aft) = (0, -n, -n); let ck = |x: i64, y: i64| x + (y \u0026gt; x) as i64 - (x \u0026gt; y) as i64; for \u0026amp;x in \u0026amp;qwq { aft = ck(skip, x).max(ck(aft, x)); skip = skip.max(pre); pre = ck(pre, x); } println!(\u0026#34;{}\u0026#34;, aft.max(skip)); } D 构造\n做法:\n有多条边的直接删,每次操作都会使入度减一，所以最多m次可分为单独的点和边 将任取的一条边作为起点，若取不出则已经cool 将剩下的点和边加入这条边，最多n次 总计 n+m 左右，一定小于2*max(n,m) 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn solve() { let (n, m) = cin!(usize, usize); let mut qwq = vec![std::collections::HashSet::new(); n + 1]; for _ in 0..m { let (u, v) = cin!(usize, usize); qwq[u].insert(v); qwq[v].insert(u); } //记录操作 let mut ans = Vec::new(); for i in 1..=n { while qwq[i].len() \u0026gt;= 2 { let u = *qwq[i].iter().next().unwrap(); qwq[i].remove(\u0026amp;u); let v = *qwq[i].iter().next().unwrap(); qwq[i].remove(\u0026amp;v); qwq[u].remove(\u0026amp;i); qwq[v].remove(\u0026amp;i); ans.push((i, u, v)); if qwq[u].contains(\u0026amp;v) { qwq[u].remove(\u0026amp;v); qwq[v].remove(\u0026amp;u); } else { qwq[u].insert(v); qwq[v].insert(u); } } } //空组件 let mut zro = Vec::new(); //一条边组件 let mut one = Vec::new(); for (i, elem) in qwq.iter().enumerate().skip(1) { if elem.is_empty() { zro.push(i); } else if *elem.iter().next().unwrap() \u0026gt; i { one.push((i, *elem.iter().next().unwrap())); } } if !one.is_empty() { // println!(\u0026#34;{:?}\u0026#34;, one); let (u, mut v) = one.pop().unwrap(); for x in zro { ans.push((u, x, v)); v = x; } for (a, b) in one { ans.push((v, a, b)); } } println!(\u0026#34;{}\u0026#34;, ans.len()); ans.iter().for_each(|(a, b, c)| println!(\u0026#34;{} {} {}\u0026#34;, a, b, c)); } E 构造\n反思:\n没能注意到多个素数时一定没有答案\n做法:\n多个素数输出-1 有2用2 没2用其他的素数 说明：在主函数中预处理素数，减少不必要开销 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 fn main() { // let t = 1; let t = cin!(i64); const MAX_N: usize = 500_027; let mut pr = vec![0; MAX_N + 1]; let mut primes = Vec::new(); pr[1] = 1; for i in 2..=MAX_N { if pr[i] == 0 { primes.push(i); } for p in \u0026amp;primes { if p * i \u0026gt; MAX_N { break; } //维护最小公因子 pr[i * p] = *p; if i % p == 0 { break; } } } (0..t).for_each(|_| solve(\u0026amp;pr)); } fn solve(pr: \u0026amp;[usize]) { let n = cin!(usize); let qwq = cin!([usize; n]); let mut pf = 0; for i in \u0026amp;qwq { if pr[*i] == 0 { pf = *i; } } if pf == 0 { println!(\u0026#34;2\u0026#34;); } else { for i in qwq { if i == pf { continue; } if pr[i] == 0 { println!(\u0026#34;-1\u0026#34;); return; } else if (i \u0026amp; 1) == 1 { if i - pr[i] \u0026lt; 2 * pf { println!(\u0026#34;-1\u0026#34;); return; } } else if i \u0026lt; 2 * pf { println!(\u0026#34;-1\u0026#34;); return; } } println!(\u0026#34;{}\u0026#34;, pf) } } ","date":"2024-11-10T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_985_glb/","title":"CodeForces_985_refact.ai_match"},{"content":"CodeForces Round 984 Div3 A-F 题解 比赛链接：https://codeforces.com/contest/2036\n题目类型 A：签到-字符串 B：签到-哈希表 C：签到—字符串 D：签到-字符串 E: 二分练习题 F: 数学-XOR\n说明 写给自己看的，全文Rust代码，善用GPT翻译 vp于 2024/11/05 最后排位大概300左右，这把大概1500水平 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题\n做法:\n遍历途中看差是不是5或7即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize); let arr = cin!([i64; n]); for i in 1..n { let diff = arr[i].abs_diff(arr[i - 1]); if diff != 5 \u0026amp;\u0026amp; diff != 7 { println!(\u0026#34;NO\u0026#34;); return; } } println!(\u0026#34;YES\u0026#34;) } B 签到题\n做法:\n哈希表存每个品牌的总和，排序||存最大堆后取出前n大的和即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn solve() { let mut st = std::collections::HashMap::new(); let (n, m) = cin!(usize, usize); for _ in 0..m { let (x, y) = cin!(u64, u64); if st.contains_key(\u0026amp;x) { st.insert(x, st.get(\u0026amp;x).unwrap() + y); } else { st.insert(x, y); } } let mut qwq = std::collections::BinaryHeap::from_iter(st.values().cloned()); let mut ans = 0; let mut cot = 0; while let Some(x) = qwq.pop() { if cot == n { break; } ans += x; cot += 1; } println!(\u0026#34;{}\u0026#34;, ans) } C 预处理后即可O(1)处理查询\n做法:\n预处理一遍一开始有多少1100 看每次更改是否减少1100的个数 个数等于零说明不存在了 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn solve() { let mut s = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let mut i = 3; let n = s.len(); let mut cot = 0; let check = |s: \u0026amp;Vec\u0026lt;char\u0026gt;, i: usize| -\u0026gt; bool { i - 3 \u0026gt; 0 \u0026amp;\u0026amp; i \u0026lt; n \u0026amp;\u0026amp; s[i - 3..=i] == [\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;] }; while i \u0026lt; n { if check(\u0026amp;s, i - 3) { cot += 1; } i += 1; } let m = cin!(usize); for _ in 0..m { let (a, b) = cin!(usize, char); let i = a - 1; let checkf = |s: \u0026amp;Vec\u0026lt;char\u0026gt;| (i - 3..i + 1).fold(true, |ans, i| ans \u0026amp; check(s, i)); if checkf(\u0026amp;s) { cot -= 1; } s[i] = b; if checkf(\u0026amp;s) { cot += 1; } println!(\u0026#34;{}\u0026#34;, if cot \u0026gt; 0 { \u0026#34;YES\u0026#34; } else { \u0026#34;NO\u0026#34; }); } } D 输入练习\n做法:\n对循环读入数据的练习 每个环顺时针接在一起 循环判断是否出现1543即可 写起来还挺麻烦的，题意倒是清晰 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 fn solve() { let (n, m) = cin!(usize, usize); let mut qwq = Vec::with_capacity(n); for _ in 0..n { qwq.push(cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;()) } let mut res = Vec::new(); let round = n.min(m) / 2; for rd in 0..round { let mut tmp = Vec::new(); // 上边界 for j in rd..m - rd { tmp.push(qwq[rd][j]); } // 右边界 for row in qwq.iter().skip(rd + 1).take(n - 2 * rd - 1) { tmp.push(row[m - rd - 1]); } // 下边界 if n - rd - 1 \u0026gt; rd { for j in (rd..m - rd - 1).rev() { tmp.push(qwq[n - rd - 1][j]); } } // 左边界 if m - rd - 1 \u0026gt; rd { for i in (rd + 1..n - rd - 1).rev() { tmp.push(qwq[i][rd]); } } res.push(tmp); } let mut ans = 0; for tmp in res { let ln = tmp.len(); for i in 0..ln { if tmp[i] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; tmp[(i + 1) % ln] == \u0026#39;5\u0026#39; \u0026amp;\u0026amp; tmp[(i + 2) % ln] == \u0026#39;4\u0026#39; \u0026amp;\u0026amp; tmp[(i + 3) % ln] == \u0026#39;3\u0026#39; { ans += 1; } } } println!(\u0026#34;{}\u0026#34;, ans); } E 二分练习题\n反思:\n题目条件没注意到，每个地区是不递减的，一开始没看到也就没做出来\n做法:\n先遍历求连通水渠之后的数组 再二分查找一下即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn solve() { let (n, m, q) = cin!(usize, usize, i64); let mut qwq = Vec::with_capacity(n); for _ in 0..n { qwq.push(cin!([i64; m])); } for i in 1..n { for j in 0..m { qwq[i][j] |= qwq[i - 1][j] } } for _ in 0..q { let p = cin!(i64); let (mut l, mut r) = (0, n as i64); for _ in 0..p { let (t, o, c) = cin!(usize, char, i64); if o == \u0026#39;\u0026gt;\u0026#39; { l = l.max(qwq.partition_point(|x| x[t - 1] \u0026lt;= c) as i64); } else { r = r.min(qwq.partition_point(|x| x[t - 1] \u0026lt; c) as i64) } } if l \u0026gt;= r { println!(\u0026#34;-1\u0026#34;); } else { println!(\u0026#34;{}\u0026#34;, l + 1); } } } F 数学\n做法:\n异或和有结论 首先每4个数一轮循环，即： x%4==0 -\u0026gt; x x%4==1 -\u0026gt; 1 x%4==2 -\u0026gt; x+1 x%4==3 -\u0026gt; 0 接着是求出任意区间异或和： 只需xor(r)^xor(l-1)即可 这里的xor()指的是上述操作 接着我们需要取模$2^i$后余数为 $k$ 的数的异或和 显然，这些数低i位就是k 而高位只需将[l,r]右移后计算区间和即可 计算完左移回去，根据奇偶判断是否加k即或上k 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn solve() { let xor = |x: i64| match x % 4 { 0 =\u0026gt; x, 1 =\u0026gt; 1, 2 =\u0026gt; x + 1, 3 =\u0026gt; 0, _ =\u0026gt; unreachable!(), }; let find = |l: i64, r: i64| xor(r) ^ xor(if l \u0026gt; 0 { l - 1 } else { 0 }); let (l, r, i, k) = cin!(i64, i64, i64, i64); let qwq = find(l, r); let stt = (l - k + ((1 \u0026lt;\u0026lt; i) - 1)) \u0026gt;\u0026gt; i; let end = (r - k) \u0026gt;\u0026gt; i; if stt \u0026gt; end { println!(\u0026#34;{}\u0026#34;, qwq); return; } let n = end - stt + 1; let res = (find(stt, end) \u0026lt;\u0026lt; i) | if n % 2 == 1 { k } else { 0 }; println!(\u0026#34;{}\u0026#34;, qwq ^ res); } ","date":"2024-11-05T00:00:00Z","permalink":"https://allergy27.github.io/p/vp_cf_984_div3/","title":"CodeForces_984_div3"},{"content":"CodeForces Round 983 Div2 A-D 题解 比赛链接：https://codeforces.com/contest/2032\n题目类型 A：签到-思维题 B：签到-思维题 C：前缀和+二分 D：模拟交互题\n说明 写给自己看的，全文Rust代码，善用GPT翻译 C题作为小测补充了C++和python代码 vp于 2024/11/04 ，做前两题忘记开歌发挥有限 最后排位大概5000左右，这把大概1300水平 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题\n做法:\n00和11对应关灯，01和10对应开灯 记录下0个数a和1个数b，a%2|b%2即为最小，a.min(b)即为最大 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 fn solve() { let n = cin!(usize); let v = cin!([i64; n * 2]); let (mut a, mut b) = (0, 0); for i in v { if i == 0 { a += 1; } else { b += 1; } } println!(\u0026#34;{} {}\u0026#34;, (a % 2) | (b % 2), a.min(b)) } B 求出前缀和数组后，数学运算即得\n反思:\n题意没理解正确多花了大量无意义的时间在上面\n做法:\n先判断是否在边界，即是否等于1或n，可以用异或逻辑处理 由于中位数左右两边区间个数一定相同，我们可以一直扩展到边界 多余的部分合并到边界区间内即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fn solve() { let (n, k) = cin!(usize, usize); if (k == 1) ^ (k == n) { println!(\u0026#34;-1\u0026#34;); } else { let rd = (n - k).min(k - 1); // 代表中位数左右区间长度 println!(\u0026#34;{}\u0026#34;, 2 * rd + 1); match (k - 1).cmp(\u0026amp;(n - k)) { std::cmp::Ordering::Equal =\u0026gt; { (1..=n).for_each(|x| print!(\u0026#34;{} \u0026#34;, x)); } std::cmp::Ordering::Greater =\u0026gt; { print!(\u0026#34;1 \u0026#34;); // 1合并到k-rd (k - rd + 1..=n).for_each(|x| print!(\u0026#34;{} \u0026#34;, x)); } std::cmp::Ordering::Less =\u0026gt; { (k - rd..=k + rd).for_each(|x| print!(\u0026#34;{} \u0026#34;, x)); } } println!() } } C 预处理出前缀和再二分判断即可\n旧教学\r做法:\n只要保证$A+B\u003eC$，就保证了可以构造出三角形 预处理出$A+B$和$C$进行比较即可 比较过程遍历C,二分查找第一个满足条件的三角形，减得区间长度就是答案所求 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn solve() { let n = cin!(usize); let mut qwq = cin!([i64; n]); qwq.sort_unstable(); let mut qaq = Vec::with_capacity(n - 1); for i in 1..n { qaq.push(qwq[i] + qwq[i - 1]); } let mut ans = i64::MAX; for i in (0..n).rev() { ans = ans.min((qaq.partition_point(|\u0026amp;x| x \u0026lt;= qwq[i]) + (n - i - 1)) as i64); } println!(\u0026#34;{}\u0026#34;, ans); } 二分做法\r我们需要让答案满足$A+B\u003eC$，所以可以预处理出$A+B$，接着枚举$C$，看$C$在$A+B$为多少时可以满足$A+B\u003eC$\n也可以枚举$A+B$，看$A+B$在$C$为多少时满足 答案即为总长-枚举出来的合理区间长\n代码部分\n二分C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void solve() {//Solution A int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; sort(qwq.begin(), qwq.end()); vector\u0026lt;int\u0026gt; qaq;//预处理A+B，枚举C for (int i = 1; i \u0026lt; n; ++i) qaq.push_back(qwq[i] + qwq[i - 1]); int ans = n - 2; for (int i = n - 1; i \u0026gt;= 0; --i) ans = min(ans, upper_bound(qaq.begin(), qaq.end(), qwq[i]) - qaq.begin() + n - 1 - i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } void solve() {//Solution B int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; sort(qwq.begin(), qwq.end()); int ans = n - 2; for (int i = 1; i \u0026lt; n; ++i) ans = min(ans,qwq.begin()- lower_bound(qwq.begin(), qwq.end(), qwq[i]+qwq[i-1]) + n - 1 + i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } 二分py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solve():#Solution A n = int(input()) qwq = list(map(int, input().split())) qwq.sort() qaq = [qwq[i] + qwq[i - 1] for i in range(1, n)] ans = n - 2 for i in range(n - 1, -1, -1): ans = min(ans, len([x for x in qaq if x \u0026lt;= qwq[i]]) + n - 1 - i) print(ans) def solve():#Solution B n = int(input()) qwq = list(map(int, input().split())) qwq.sort() ans = n - 2 for i in range(1, n): ans = min(ans, len([x for x in qwq if x \u0026gt;= qwq[i] + qwq[i - 1]]) + n - 1 + i) print(ans) 双指针做法\r我们设置两个变量模拟两个指针，一个指向0位置，一个指向2位置\n如果我们移动右指针，则越来越不满足条件\n如果移动左指针，则越来越满足条件\n我们一边移动一边更新区间最长的值MAX\n答案即为总长-MAX\n代码部分\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 void solve() int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; sort(qwq.begin(), qwq.end()); int l = 0; int ans = n - 2; for (int r = 2; r \u0026lt; n; ++r) { while (r - l \u0026gt;= 2 \u0026amp;\u0026amp; qwq[r] \u0026gt;= qwq[l] + qwq[l + 1]) ++l; ans = min(ans, n - r + l - 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; Py代码\r1 2 3 4 5 6 7 8 9 10 11 def solve(): n = int(input()) qwq = list(map(int, input().split())) qwq.sort() l = 0 ans = n - 2 for r in range(2, n): while r - l \u0026gt;= 2 and qwq[r] \u0026gt;= qwq[l] + qwq[l + 1]: l += 1 ans = min(ans, n - r + l - 1) print(ans) D 交互思维题\n做法:\n理解完题意我们知道只有根节点有多个孩子，其他节点只有一个孩子 又题目已知1节点一定与两个点相连 我们从1开始向n遍历判断谁是1的孩子 判断完孩子后我们接着判断每个点都接在哪个孩子下面 依次遍历叶子，如果叶子和当前节点查询得0，则说明当前节点的直接父亲为该叶子 题目保证了可以找到，所以直接找就可以 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 fn solve() { let n = cin!(usize); let mut fa = vec![0; n]; let mut qwq = std::collections::BTreeSet::new(); let ask = |l: usize, r: usize| -\u0026gt; bool { println!(\u0026#34;? {} {}\u0026#34;, l, r); stdout().flush().unwrap(); cin!(i32) == 0 }; let mut f = true; for (i, elem) in fa.iter_mut().enumerate().skip(2) { if f { if ask(1, i) { *elem = 1; f = false; } } else { while let Some(x) = qwq.pop_first() { if ask(x, i) { *elem = x; break; } } } qwq.insert(i); } print!(\u0026#34;! \u0026#34;); for i in fa.into_iter().skip(1) { print!(\u0026#34;{} \u0026#34;, i); } println!(); } ","date":"2024-11-04T00:00:00Z","permalink":"https://allergy27.github.io/p/vp_cf_983_div2/","title":"CodeForces_983_div2"},{"content":"2024级新生前缀和考核题解 考核链接：https://vjudge.net/contest/668380\n题目类型 A：前缀和+二分 B：前缀和+数学 C：前缀和+字符串 D：前缀和+思维 E：前缀和嵌套\n说明 Python代码全是由C++版本用GPT转译而来，逻辑上没有问题但不保证是在python下的最优实现 未提供C代码，请善用GPT等工具或尽快掌握C++的基础语法 C++模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln \u0026#39;\\n\u0026#39; #define int int64_t using namespace std; // NOLINT using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; void solve() { } signed main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); cin \u0026gt;\u0026gt; t; return 0; } Py模板\r1 2 3 4 5 6 def solve(): if __name__ == \u0026#34;__main__\u0026#34;: n = int(input()) for i in range(n): solve() A 只需要排序后预处理出前缀和数组并二分查找即可\n做法:\n最小的两个货物数之和肯定是最小的，我们每次取最小的肯定是最理想的情况，而题目中顺序不影响答案，先排序方便之后二分查找。 预处理出前缀和数组，此时数组的值代表需要多少头鹿，索引加一代表能拉的货物数量，只需判断给定的鹿的数量在数组中的哪个位置即可，所以我们利用二分查找得到答案。 C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;i : qwq) cin \u0026gt;\u0026gt; i; sort(qwq.begin(), qwq.end()); // 排序O(nlogn) for (int i = 1; i \u0026lt; n; i++) qwq[i] += qwq[i - 1]; // 预处理出前缀和 for (int i = 0; i \u0026lt; m; i++) { int x; cin \u0026gt;\u0026gt; x; // 二分查询O(logn) 共m次 O(mlogn) cout \u0026lt;\u0026lt; upper_bound(qwq.begin(), qwq.end(), x) - qwq.begin() \u0026lt;\u0026lt; ln; } } Py代码\r1 2 3 4 5 6 7 8 9 10 11 import bisect def solve(): n, m = map(int, input().split()) qwq = list(map(int, input().split())) qwq.sort() # 排序O(nlogn) for i in range(1, n): qwq[i] += qwq[i - 1] # 预处理出前缀和 for _ in range(m): x = int(input()) # 二分查询O(logn) 共m次 O(mlogn) print(bisect.bisect_right(qwq, x)) B 求出前缀和数组后，数学运算即得\n做法:\n预处理出前缀和数组，此时数组的值代表0到索引位置的和为多少，而每隔数组长度个数的和都是不变的，和为qaq[n]，所以计算出有几段并顺序查找到哪位时和超过x即可 记得开long long (我的模板是直接将int定义成long long，所以不用再手动开long long) C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void solve() { int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; qaq(n + 1); for (int i = 0; i \u0026lt; n; ++i) qaq[i + 1] = qaq[i] + qwq[i]; cin \u0026gt;\u0026gt; m; int ans = m / qaq[n] * n; // 计算有几段，直接添加到答案中 m %= qaq[n]; // 剩下的部分的大小 // 这里我用的二分去找，实际O(n)的查询也能过 ans += upper_bound(qaq.begin(), qaq.end(), m) - qaq.begin(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 import bisect def solve(): n = int(input()) qwq = list(map(int, input().split())) qaq = [0] * (n + 1) for i in range(n): qaq[i + 1] = qaq[i] + qwq[i] m = int(input()) ans = m // qaq[n] * n # 计算有几段，直接添加到答案中 m %= qaq[n] # 剩下的部分的大小 # 这里我用的二分去找，实际O(n)的查询也能过 ans += bisect.bisect_right(qaq, m) print(ans) C 前缀和+字符串计数\n做法:\n记录到每个索引前有多少个\u0026quot;AC\u0026quot;，即前缀和预处理即可 预处理时注意先检查\u0026quot;C\u0026quot;会比较方便 C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; qaq(n); // 前缀和数组 int idx = 1; while (idx \u0026lt; n) { qaq[idx] = qaq[idx - 1]; // 遇到AC就往后跳两步 if (s[idx - 1] == \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s[idx] == \u0026#39;C\u0026#39;) ++qaq[idx]; idx++; } // 前缀和处理查询 while (m--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; qaq[r - 1] - qaq[l - 1] \u0026lt;\u0026lt; ln; } } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solve(): n, m = map(int, input().split()) s = input() qaq = [0] * n # 前缀和数组 idx = 1 while idx \u0026lt; n: qaq[idx] = qaq[idx - 1] # 遇到AC就往后跳两步 if s[idx - 1] == \u0026#39;A\u0026#39; and s[idx] == \u0026#39;C\u0026#39;: qaq[idx] += 1 idx += 1 # 前缀和处理查询 for _ in range(m): l, r = map(int, input().split()) print(qaq[r - 1] - qaq[l - 1]) D 前缀和+思维\n做法:\n题目不是简单的前缀和，需要动脑子转换一下 我们拿m = 2举例子，如下图： 1 2 3 4 4 3 4 2 3 4 1 2 3 4 一开始是1和22，接着我们要求2和33，那怎么求呢？ 我们如果在转移的时候，加上333，再减去1到3的和，是否就是2+33？ 所以我们只要做前缀和得到任意区间和，再在转移的时候减去该部分前缀和即可 C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; qaq(n + 1); // 前缀和 for (int i = 1; i \u0026lt;= n; ++i) qaq[i] = qaq[i - 1] + qwq[i - 1]; int tmp = 0; // 记录每一段长度 for (int i = 0; i \u0026lt; m; ++i) tmp += qwq[i] * (i + 1); int ans = tmp; for (int i = m; i \u0026lt; n; ++i) { tmp -= qaq[i + 1] - qaq[i - m] - qwq[i] * (m + 1); ans = max(ans, tmp); // 更新最大值 } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solve(): n, m = map(int, input().split()) qwq = list(map(int, input().split())) qaq = [0] * (n + 1) # 前缀和 for i in range(1, n + 1): qaq[i] = qaq[i - 1] + qwq[i - 1] tmp = 0 # 记录每一段长度 for i in range(m): tmp += qwq[i] * (i + 1) ans = tmp for i in range(m, n): tmp -= qaq[i + 1] - qaq[i - m] - qwq[i] * (m + 1) ans = max(ans, tmp) # 更新最大值 print(ans) E 前缀和的嵌套\n做法:\n和上题有些类似，但由于实在太不直观，这边需要拿一张图说明一下： 首先我们要计算绿色的部分（和橙色重叠的地方变成了黄色），也就是 a1-a1a2a3 这个三角形 这段长度为 B 中第一段的 1 到 3 的和，我们不妨记作t(1,3)，很显然，我们要计算B中任意区间和，必须求出t(l,r) 我们思考如何计算例如t(3,3)： 首先，每个独立的列s(l,r)可以通过对A做前缀和由 qaq 数组求出 其次，t(1,r)是可以预处理得到的，记为 h 数组 而橙色部分也可以预处理得到，记为 w 数组 我们计算t(l,r)无非是将绿色部分减去黄色部分 所以绿色部分（不算重叠）的和就是绿色部分（算上重叠）减橙色部分（算上重叠）加上橙色部分（不算重叠） 而单独计算橙色部分（不算重叠）即s(1,l-1)*(n-r) 那么得到t(l,r) = h[r] - w[l-1] + (n-r) * qaq[l - 1] 现在我们得到如何计算t(l,r)，还得处理查询 查询需要确定给定区间包括了多少段和，我们提前预处理出来tsum数组，代表从l段右端点到r段左端点和 如果l和r在同一段，可以直接计算 如果不在同一段，则需计算l到l右端点，tsum和，r到r左端点，接着加在一起 查询也可以用数学公式确定到底在哪段，做到$O(1)$查询，不过$O(\\log{n})$显然够用了 C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void solve() { int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; // Step 1. O(n)预处理 vector\u0026lt;int\u0026gt; qaq(n + 1); // 前缀和 vector\u0026lt;int\u0026gt; h(n + 1); // 纵向前缀和 vector\u0026lt;int\u0026gt; w(n + 1); // 横向前缀和 vector\u0026lt;int\u0026gt; tsum(n + 1); // 前缀和总和的前缀和 for (int i = 1; i \u0026lt;= n; ++i) qaq[i] = qaq[i - 1] + qwq[i - 1]; for (int i = 1; i \u0026lt;= n; ++i) h[i] = h[i - 1] + qaq[i]; for (int i = 1; i \u0026lt;= n; ++i) w[i] = w[i - 1] + qwq[i - 1] * (n - i + 1); auto t = [\u0026amp;](int l, int r) -\u0026gt; int { // lambda表达式，等效一个函数 return h[r] - w[l - 1] + (n - r) * qaq[l - 1]; }; for (int i = 1; i \u0026lt;= n; ++i) tsum[i] = tsum[i - 1] + t(i, n); // Step 2. O(log n)查询 cin \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; nums(n + 1); for (int i = 1; i \u0026lt;= n; ++i) nums[i] = nums[i - 1] + n - i + 1; while (m--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; int lf = lower_bound(nums.begin(), nums.end(), l) - nums.begin(); int rf = lower_bound(nums.begin(), nums.end(), r) - nums.begin(); int nl = l - nums[lf - 1] - 1; int nr = r - nums[rf - 1] - 1; if (lf == rf) { // 在同一段直接求和 cout \u0026lt;\u0026lt; t(lf, lf + nr) - t(lf, lf + nl - 1) \u0026lt;\u0026lt; ln; } else { int ans = 0; ans += t(lf, n) - t(lf, lf + nl - 1); // l到l右端点和 ans += tsum[rf - 1] - tsum[lf]; // 中间段和 ans += t(rf, rf + nr); // r到r左端点和 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } } } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import bisect def solve(): n = int(input()) qwq = list(map(int, input().split())) # Step 1. O(n)预处理 qaq = [0] * (n + 1) # 前缀和 h = [0] * (n + 1) # 纵向前缀和 w = [0] * (n + 1) # 横向前缀和 tsum = [0] * (n + 1) # 前缀和总和的前缀和 for i in range(1, n + 1): qaq[i] = qaq[i - 1] + qwq[i - 1] for i in range(1, n + 1): h[i] = h[i - 1] + qaq[i] for i in range(1, n + 1): w[i] = w[i - 1] + qwq[i - 1] * (n - i + 1) def t(l, r): return h[r] - w[l - 1] + (n - r) * qaq[l - 1] for i in range(1, n + 1): tsum[i] = tsum[i - 1] + t(i, n) # Step 2. O(log n)查询 m = int(input()) nums = [0] * (n + 1) for i in range(1, n + 1): nums[i] = nums[i - 1] + n - i + 1 for _ in range(m): l, r = map(int, input().split()) lf = bisect.bisect_left(nums, l) rf = bisect.bisect_left(nums, r) nl = l - nums[lf - 1] - 1 nr = r - nums[rf - 1] - 1 if lf == rf: # 在同一段直接求和 print(t(lf, lf + nr) - t(lf, lf + nl - 1)) else: ans = 0 ans += t(lf, n) - t(lf, lf + nl - 1) # l到l右端点和 ans += tsum[rf - 1] - tsum[lf] # 中间段和 ans += t(rf, rf + nr) # r到r左端点和 print(ans) ","date":"2024-11-02T00:00:00Z","permalink":"https://allergy27.github.io/p/flashmen_solve_3/","title":"2024级新生前缀和测试"},{"content":"背包问题 写于2023年，码风较为丑陋，建议优先查看官方推荐题解\n背包问题一共分为三种,01背包，完全背包，多重背包。 其中多重背包要了解二进制优化。\n零一背包 问题介绍： 有一个有限容量的背包，要装n种n个物品，物品占不同容量、有不同价值，求出最大能装下的价值\n算法分析：\n首先我们知道01背包问题最核心的就是取还是不取，这个问题可以联系到最经典的捡芝麻丢西瓜小故事。而与之不同的是我们要做出正确的决策 我们来想想看，什么样的决策是正确的？ 在背包里没有东西的时候，我们见到一个东西就拿一个东西是对的 在背包里装不下新的东西的时候，我们就需要做一些取舍，丢掉一部分的物品，转而装下新东西（当然，新东西需要更有价值 于是我们就可以先遍历东西，再从背包是空的情况向满的情况开始遍历，如果这个东西放进来更有价值我们就让它放进来 那么我们理解了这个决策的方法后，就可以用更学术的语言来描述这个过程了 我们设出一个dp表记作背包对应容量下能获得的最大价值 接着我们开始遍历 外层遍历物品，内层遍历背包的容量，而遍历过程中的状态转移方程则为：$dp[j]=max(dp[j],dp[j-w[i]]+v[i])$ 写出这个状态转移方程之后其实就可以直接写代码了，但是初次接触这个概念可能显得比较抽象，我们用一些图片来辅助理解: 我自拟了一个简单的01背包问题，那么我们直接模拟一下上面那个策略的执行过程： 首先我们遇到了重量为2，价值为3的西瓜，没什么好说的这遍循环直接将其加入:图2 接着我们遇到了3 4的西瓜，我们开始判断了：图3 因为容量是7，所以7-3 （这个西瓜）=4是4的位置，我们判断容量为4的最大值也就是3加上这个新东西4是否比原先容量为7时的值大。而7很显然大于3，我们替换：图4 接着依次类推直到下面这种情况:图5 其实没必要单领出来，但是这时是有一点点不一样的，我们能发现这时左边的不是3而是0了，所以我们比较的是0+4和3的大小关系，显然4更大些，接着类推直到包已经满了:图6 这时我们就接着判断下一个物品了，那么中间过程交给大火自己写了，我这里贴出最终的状态以供验证:图7 代码部分：\n老规矩昂，只有主体部分\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void solve() { int n, v, i, j; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt;qwq(v + 1, 0); vector\u0026lt;int\u0026gt;qwqV(n + 1, 0); vector\u0026lt;int\u0026gt;qwqW(n + 1, 0); //输入物品及价值 for(i = 1;i \u0026lt;= n;++i)cin \u0026gt;\u0026gt; qwqW[i] \u0026gt;\u0026gt; qwqV[i]; //动态规划 for(i = 1;i \u0026lt;= n;++i) for(j = v;j \u0026gt;=qwqW[i];--j) qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]); cout \u0026lt;\u0026lt; qwq[v] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 理解完这个西瓜的题目之后，我们去洛谷做一下也是相当经典的采药问题 完全背包 问题介绍： 从n种n个物品改成了n种无限个物品。\n算法分析：\n那么相信大火已经把01背包搞懂了，我们来搞懂完全背包问题 其实这个问题就是01背包反过来做，我们原先是从后往前遍历的，现在我们从前往后遍历 就是指每当遇到一个东西，我们都用它塞满背包，最后塞满时的状态就是最后我们要的答案 理解起来应该不难，代码上也只需要改一点， 所以我们直接给出题目并且附赠一个题解： 疯狂的采药 题解：\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void solve() { ll n, v, i, j; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt;qwq(v + 1, 0); vector\u0026lt;ll\u0026gt;qwqV(n + 1, 0); vector\u0026lt;ll\u0026gt;qwqW(n + 1, 0); //输入物品及价值 for(i = 1;i \u0026lt;= n;++i)cin \u0026gt;\u0026gt; qwqW[i] \u0026gt;\u0026gt; qwqV[i]; //动态规划 for(i = 1;i \u0026lt;= n;++i) for(j = qwqW[i];j\u0026lt;=v;++j) //保证了一定不越界 qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]); //要么取，要么不取，不考虑空间用完 cout \u0026lt;\u0026lt; qwq[v] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 多重背包 问题介绍： 从n种n个变成了n种m个，也就是每种可能有多个\n算法分析：\n其实就是一个01背包问题，试想一下，我们将每种的多个都拆出来，是不是直接转换成了01背包问题 但是我们还需要优化（试想一下，我有两个物品，其中一个是1 1 1000000，那我如果转化的话，是不是不止2个物品的讨论情况了 但是也许你也注意到了，1000000个的话，我的背包可能根本装不完 是的，这样我们就转换成了完全背包+01背包问题 不过我们采取别的方法优化（主要是为了有东西可以写……） 我们来考虑一下将一个物品的数量分解： 如果是1 1 20，那我们可以拆成$(1+2+4+8)+5$ 为什么不是$4+16$呢？ 这是因为，前面括号括起来的数全是2的n次幂，我们可以用\u0026lt;\u0026lt;来实现轻松枚举，而4 16则没有明显的枚举关系（你可能会说4^1 4^2,总之因为位运算是二进制，符合2的n次都是可以的(不过取这些也许会得到错误的答案，不妨尝试一下)） 那么我们直接用一道宝物筛选来巩固一下吧\n题解：\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void solve() { int n, v, i, j, num, cnt = 0, a, b; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v; vector\u0026lt;int\u0026gt;qwq(1000005, 0); vector\u0026lt;int\u0026gt;qwqV(1000005, 0); vector\u0026lt;int\u0026gt;qwqW(1000005, 0); //输入物品及价值(二进制优化) for(i = 1;i \u0026lt;= n;++i) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; num; for(j = 1;j \u0026lt;= num;j \u0026lt;\u0026lt;= 1) { qwqV[++cnt] = j * a; qwqW[cnt] = j * b; num -= j; } if(num)qwqV[++cnt] = a * num, qwqW[cnt] = b * num; } //动态规划 for(i = 1;i \u0026lt;= cnt;++i) for(j = v;j \u0026gt;= qwqW[i];--j) //保证了一定不越界 qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]); //要么取，要么不取，不考虑空间用完 cout \u0026lt;\u0026lt; qwq[v] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":"2024-10-30T00:00:00Z","permalink":"https://allergy27.github.io/p/easy-dp-bag/","title":"简单线性dp-背包问题"},{"content":"2024级新生语言基础考核题解 考核链接：https://vjudge.net/contest/666653\n题目类型 A：签到题 B：思维 C：思维 D：思维 E：数学 F：滑动窗口 G：思维\n说明 Python代码全是由C++版本用GPT转译而来，逻辑上没有问题但不保证是在python下的最优实现 未提供C代码，请善用GPT等工具或尽快掌握C++的基础语法 C++模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln \u0026#39;\\n\u0026#39; #define int int64_t using namespace std; // NOLINT using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; void solve() { } signed main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); cin \u0026gt;\u0026gt; t; return 0; } Py模板\r1 2 3 4 5 6 def solve(): if __name__ == \u0026#34;__main__\u0026#34;: n = int(input()) for i in range(n): solve() A 签到题\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 void solve() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; if (a \u0026lt; b \u0026amp;\u0026amp; b \u0026lt; c) { cout \u0026lt;\u0026lt; \u0026#34;STAIR\\n\u0026#34;; } else if (a \u0026lt; b \u0026amp;\u0026amp; b \u0026gt; c) { cout \u0026lt;\u0026lt; \u0026#34;PEAK\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;NONE\\n\u0026#34;; } } Py代码\r1 2 3 4 5 6 7 8 def solve(): a, b, c = map(int, input().split()) if a \u0026lt; b \u0026lt; c: print(\u0026#34;STAIR\u0026#34;) elif a \u0026lt; b \u0026gt; c: print(\u0026#34;PEAK\u0026#34;) else: print(\u0026#34;NONE\u0026#34;) B 思维题\n想明白Kosuke获胜n一定是奇数，就好做了\nC++代码\r1 2 3 4 5 6 7 8 9 void solve() { int n, m; cin \u0026gt;\u0026gt; n; if (n \u0026amp; 1) { cout \u0026lt;\u0026lt; \u0026#34;Kosuke\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;Sakurako\\n\u0026#34;; } } Py代码\r1 2 3 4 5 6 def solve(): n = int(input()) if n % 2 == 1: print(\u0026#34;Kosuke\u0026#34;) else: print(\u0026#34;Sakurako\u0026#34;) C 思维题\n想清楚最多只要一次就行，假如B个数已经为k则为0次，否则B多了就0到i变A,B少了0到i变B。\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void solve() { // 解题部分 int n, m, i, f = 0, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;char\u0026gt; s(n); for (auto \u0026amp;x : s) { cin \u0026gt;\u0026gt; x; if (x == \u0026#39;B\u0026#39;) ++ans; } if (ans \u0026lt; m) { f += 2; for (i = 0; i \u0026lt; n \u0026amp;\u0026amp; ans != m; ++i) if (s[i] == \u0026#39;A\u0026#39;) ++ans; } else if (ans \u0026gt; m) { f += 1; for (i = 0; i \u0026lt; n \u0026amp;\u0026amp; ans != m; ++i) if (s[i] == \u0026#39;B\u0026#39;) --ans; } cout \u0026lt;\u0026lt; (f ? \u0026#34;1\\n\u0026#34; : \u0026#34;0\\n\u0026#34;); if (f != 0) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; \u0026#34;AB\u0026#34;[f - 1] \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def solve(): n, m = map(int, input().split()) s = list(input().strip()) ans = sum(1 for x in s if x == \u0026#34;B\u0026#34;) f = 0 i = 0 if ans \u0026lt; m: f += 2 while i \u0026lt; n: if ans == m: break if s[i] == \u0026#34;A\u0026#34;: ans += 1 i += 1 elif ans \u0026gt; m: f += 1 while i \u0026lt; n: if ans == m: break if s[i] == \u0026#34;B\u0026#34;: ans -= 1 i += 1 print(\u0026#34;1\u0026#34; if f else \u0026#34;0\u0026#34;) if f != 0: print(i, \u0026#34;AB\u0026#34;[f - 1]) D 思维题\n题目翻译有点问题，但是能看出来比赛想要结束一定是由某个人赢了来结束，也就是输出最后一个\nC++代码\r1 2 3 4 5 6 void solve() { string s; cin \u0026gt;\u0026gt; s; cin \u0026gt;\u0026gt; s; cout \u0026lt;\u0026lt; s.back() \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 def solve(): input() s = input().strip() print(s[-1]) E 数学\n先计算2*2的方块，每有两个都会产生7个空位，有剩余就多4个 再看空位够不够，把1*1个数减去空位再/15即可，不要忘记向上取整\nC++代码\r1 2 3 4 5 6 7 8 9 void solve() { int n, m, res = 0; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; res += (n % 2) * 4 + ((n + 1) / 2) * 7; if (res \u0026gt; m) cout \u0026lt;\u0026lt; (n + 1) / 2 \u0026lt;\u0026lt; ln; else cout \u0026lt;\u0026lt; (n + 1) / 2 + (m - res + 14) / 15 \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 def solve(): m, n = map(int, input().split()) res = (n % 2) * 4 + ((n + 1) // 2) * 7 if res \u0026gt; m: print((n + 1) // 2) else: print((n + 1) // 2 + (m - res + 14) // 15) F 滑动窗口\n不定长的滑动窗口，每次扩展右端点，扩展到:\n右端点不等于上一个数+1 右端点减左端点大于k 则移动左端点\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; sort(qwq.begin(), qwq.end()); int l = 0, r = 0; int l_ans = qwq[0], r_ans = qwq[0]; int ans = 1; while (r \u0026lt; n) { if (++r == n) break; if (qwq[r] \u0026gt; r_ans + 1) { ans = max(ans, r - l); l = r; l_ans = qwq[r]; } r_ans = qwq[r]; while (r_ans - l_ans + 1 \u0026gt; m) { l_ans = qwq[++l]; } ans = max(ans, r - l + 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def solve(): n, m = map(int, input().split()) qwq = list(map(int, input().split())) qwq.sort() l, r = 0, 0 l_ans = r_ans = qwq[0] ans = 1 while r \u0026lt; n: r += 1 if r == n: break if qwq[r] \u0026gt; r_ans + 1: ans = max(ans, r - l) l = r l_ans = qwq[r] r_ans = qwq[r] while r_ans - l_ans + 1 \u0026gt; m: l += 1 l_ans = qwq[l] ans = max(ans, r - l + 1) print(ans) G 思维题\n每一位的计算是独立的，而由于是减法运算，也不会出现进位,又$a|b \\geq a\\\u0026c$,不会出现借位，所以对每一位单独考虑就行，我们列出真值表:\nb c d a 0 0 0 0 0 0 1 1 0 1 0 1\\0 1 0 1 1\\0 1 1 0 1 1 1 1 0 需要注意，不会有(b,c,d) = (1,0,0) or (b,c,d) = (0,1,1)的情况，所以一旦出现就证明构造不出\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void solve() { int a = 0, b, c, d, bit = 1, f = 1; cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; for (int i = 0; i \u0026lt; 62; ++i) { int bit_b = (b \u0026amp; bit) ? 1 : 0; int bit_c = (c \u0026amp; bit) ? 1 : 0; int bit_d = (d \u0026amp; bit) ? 1 : 0; if (bit_b \u0026amp;\u0026amp; (!bit_c) \u0026amp;\u0026amp; (!bit_d) || (!bit_b) \u0026amp;\u0026amp; bit_c \u0026amp;\u0026amp; bit_d) { f = 0; break; } a |= (bit_b \u0026amp;\u0026amp; bit_c) ? bit * (1ll - bit_d) : bit * bit_d; bit \u0026lt;\u0026lt;= 1; } cout \u0026lt;\u0026lt; (f ? a : -1) \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def solve(): a, b, c, d = 0, *map(int, input().split()) bit, f = 1, 1 for i in range(62): bit_b = 1 if (b \u0026amp; bit) else 0 bit_c = 1 if (c \u0026amp; bit) else 0 bit_d = 1 if (d \u0026amp; bit) else 0 if (bit_b and not bit_c and not bit_d) or (not bit_b and bit_c and bit_d): f = 0 break a |= (bit * (1 - bit_d)) if (bit_b and bit_c) else bit * bit_d bit \u0026lt;\u0026lt;= 1 print(a if f else -1) ","date":"2024-10-26T00:00:00Z","permalink":"https://allergy27.github.io/p/flashmen_solve_2/","title":"2024级新生语言基础测试"},{"content":"转自 源地址：https://studyingfather.com/archives/841 源仓库地址：https://github.com/SFOI-Team/luogu-problem-list star截图： 转载前言 从luogu上copy来的，因为用luogu的那个找题有些不方便干脆转过来了。 仅供本人自己练习使用，原作者源码都在上方，如转载请勿转载我的版本，转载原作者的。\n新版本食用指南 本次版本更新变更较大，建议您仔细阅读下面的内容！\n在刚刚更新的 2.0 版本中，我们改变了原来按知识难度排列知识点的目录结构，改为按照专题大类组织目录结构。\n为了方便按知识难度刷题的用户，这里给出一些建议：\n对于初学者，建议先完成 Part 1,2 两部分内容，为接下来的学习打好基础。 对于要参加 CSP-S 的选手，建议在前面的基础上优先完成 Part 3.1-3.4, 4.1-4.4, 6.1-6.5, 7.1-7.8, 8.1-8.7 的内容（具体内容见下），在此基础上继续完成其他内容。 每个专题下的题目先给出模板，剩下的题目均按照难度递增顺序排序，部分难度较高的综合性题目建议达到一定能力后再尝试解决。 Part 0 试机题 三道试机题目。\nP1000 超级玛丽游戏 - Accept P1001 A+B Problem - Accept P1008 三连击 - Accept Part 1 入门阶段 本部分内容针对入门 OIer ，主要是语言基础内容。\nPart 1.1 从零开始 语言基础题。\nP1421 小玉买文具 - Accept P1909 买铅笔 - Accept P1089 津津的储蓄计划 - Accept P1085 不高兴的津津 - Accept P1035 级数求和 - Accept P1980 计数问题 - Accept P1014 Cantor表 - Accept P1307 数字反转 - Accept Part 1.2 数组基础 数组可以用于存储大量的信息。\nP1046 陶陶摘苹果 - Accept P1047 校门外的树 - Accept P1427 小鱼的数字游戏 - Accept P2141 珠心算测验 - Accept P5594 【XR-4】模拟赛 - Accept Part 1.3 字符串基础 字符串是特殊的数组，但它也有很多自身的特点。\nP5015 标题统计 - Accept P1055 ISBN号码 - Accept P1308 统计单词数 - Accept P2010 回文日期 - Accept P1012 拼数 - Accept P5587 打字练习 - Accept Part 1.4 函数，递归及递推 这是初学者最难理解的部分，建议画出递归图来理解递归的过程。\nP1028 数的计算 - Accept P1036 选数 - Accept P1464 Function - Accept P5534 【XR-3】等差数列 - Accept P1192 台阶问题 - Accept P1025 数的划分 - Accept P4994 终于结束的起点 - Accept Part 2 基础算法 这一部分的内容包含了 OI 中的基础算法，供各位巩固基础。\n当然，这里面也有一些难度比较高的题目。\nPart 2.1 模拟 模拟，顾名思义就是题目要求你做什么你就做什么，这样的题目很考验选手的代码组织能力。\n这里不仅仅有非常基础的模拟，也有一些非常复杂的题目。\nP1003 铺地毯 - Accept P1067 多项式输出 - Accept P1328 生活大爆炸版石头剪刀布 - Accept P1563 玩具谜题 - Accept P1042 乒乓球 - Accept P1179 数字统计 - Accept P2615 神奇的幻方 - Accept P3952 时间复杂度 P2482 [SDOI2010]猪国杀 P5380 [THUPC2019]鸭棋 Part 2.2 排序算法 通过排序，我们可以将数据有序化，这让我们对数据的处理方便了很多。\nP1177 【模板】快速排序 - Accept P1059 明明的随机数 - Accept P1068 分数线划定 - Accept P1051 谁拿了最多奖学金 P1309 瑞士轮 - Accept P1908 逆序对 - Accept Part 2.3 二分答案 对一个满足单调性质的问题，我们可以采用二分答案的方法来解决。\nP1024 一元三次方程求解 - Accept P2678 跳石头 - Accept P1824 进击的奶牛 P1902 刺杀大使 P1314 聪明的质监员 P1083 借教室 P4343 [SHOI2015]自动刷题机 Part 2.4 分治 分治，即分而治之，将大问题分解为小问题，分别求解，最后合并结果。\nP1226 【模板】快速幂||取余运算 - Accept P1010 幂次方 - Accept P1429 平面最近点对（加强版） P3612 [USACO17JAN]Secret Cow Code Part 2.5 贪心 贪心，指的是决策时都采取当前最优解的算法。有的时候，这样做确实可以获得最优解。\nP1208 [USACO1.3]Mixing Milk P4995 跳跳！ - Accept P1094 纪念品分组 - Accept P1199 三国游戏 P2672 推销员 - Accept P1080 国王游戏 - Accept P2123 皇后游戏 P5521 [yLOI2019]梅深不见冬 Part 2.6 构造 构造题是一种形式灵活多样的题型。正是因为这个特点，使得构造题没有一种通用的方法。\nP3599 Koishi Loves Construction P5441 【XR-2】伤痕 P5595 【XR-4】歌唱比赛 Part 2.7 高精度 在 C++ 中，long long 都无法表示我们需要的整数时怎么办？那就用高精度吧！\nP1601 A+B Problem（高精） - Accept P2142 高精度减法 P1303 A*B Problem - Accept P1480 A/B Problem P1009 阶乘之和 - Accept Part 2.8 前缀和 \u0026amp; 差分 前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。\nP3131 [USACO16JAN]Subsequences Summing to Sevens P1387 最大正方形 P3397 地毯 - Accept P2280 [HNOI2003]激光炸弹 P4552 [Poetize6] IncDec Sequence Part 3 搜索 搜索其实就是高级的枚举，很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。\nPart 3.1 深度优先搜索 深度优先搜索（DFS），即按照深度优先的顺序搜索的算法。\n深度优先搜索一般使用栈来实现。\nP1219 八皇后 - Accept P1019 单词接龙 - Accept P5194 [USACO05DEC]Scales P5440 【XR-2】奇迹 P1378 油滴扩展 Part 3.2 广度优先搜索 广度优先搜索（BFS），即优先扩展浅层节点，逐渐深入的搜索算法。\n广度优先搜索一般使用队列来实现。\nP1162 填涂颜色 P1443 马的遍历 - Accept P3956 棋盘 P1032 字串变换 P1126 机器人搬重物 Part 3.3 记忆化搜索 通过将已经遍历的状态记录下来，从而减少重复的搜索量，这就是记忆化搜索。\n动态规划的时候，记忆化搜索也是一种高效简洁的实现方式。\nP1514 引水入城 P1535 游荡的奶牛 P1434 [SHOI2002]滑雪 P3953 逛公园 Part 3.4 搜索的剪枝 对于一些不必要搜索的部分，我们可以避免访问这些状态，从而提高搜索效率。\nP1120 小木棍 ［数据加强版］ P1312 Mayan游戏 P1074 靶形数独 Part 3.5 双向搜索 在搜索时，如果能从初态和终态出发，同时进行搜索，就可以减小搜索树的规模，提高时间效率。\nP3067 [USACO12OPEN]Balanced Cow Subsets P4799 [CEOI2015 Day2]世界冰球锦标赛 P5195 [USACO05DEC]Knights of Ni Part 3.6 A* 在 BFS 中，如果能设计一个合理的估价函数，就可以更快扩展到最优解。这就是 A*算法。\nP1379 八数码难题 Part 3.7 IDA* 像 BFS 那样，每次只扩展一层节点，却采用 DFS 方式来遍历搜索树，这就是迭代加深搜索。\n再加上一个估价函数来减小搜索量，就是 IDA*了。\nP2324 [SCOI2005]骑士精神 P2534 [AHOI2012]铁盘整理 Part 3.8 DLX 算法 X 是通过回溯法求解精确覆盖问题的算法，而删除列这一操作可以使用舞蹈链加速。\nP4929 【模板】舞蹈链（DLX） P4205 [NOI2005]智慧珠游戏 Part 4 动态规划 动态规划是一种重要的思维方法，通过利用已有的子问题信息高效求出当前问题的最优解。\nPart 4.1 线性动态规划 线性动态规划，即具有线性阶段划分的动态规划。\nP1216 数字三角形 - Accept P1020 导弹拦截 - Accept P1091 合唱队形 - Accept P1095 守望者的逃离 - Accept P1541 乌龟棋 - Accept P1868 饥饿的奶牛 - Accept P2679 子串 - Accept P2501 [HAOI2006]数字序列 P3336 [ZJOI2013]话旧 P3558 [POI2013]BAJ-Bytecomputer P4158 [SCOI2009]粉刷匠 P5301 [GXOI/GZOI2019]宝牌一大堆 Part 4.2 背包动态规划 背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。\nP1048 采药 - Accept P1060 开心的金明 - Accept P1855 榨取kkksc03 - Accept P5020 货币系统 P1757 通天之分组背包 P1064 金明的预算方案 P2946 [USACO09MAR]Cow Frisbee Team P1156 垃圾陷阱 P5322 [BJOI2019]排兵布阵 P5289 [十二省联考2019]皮配 Part 4.3 区间动态规划 区间动态规划一般以区间作为动态规划的阶段。\nP1880 [NOI1995]石子合并 P3146 [USACO16OPEN]248 P1063 能量项链 P1005 矩阵取数游戏 - Accept P4170 [CQOI2007]涂色 P4302 [SCOI2003]字符串折叠 P2466 [SDOI2008]Sue的小球 Part 4.4 树形动态规划 树形动态规划，即在树上进行的动态规划。\n因为树的递归性质，树形动态规划一般都是递归求解的。\nP1352 没有上司的舞会 P1040 加分二叉树 P1122 最大子树和 P1273 有线电视网 P2014 选课 P2585 [ZJOI2006]三色二叉树 P3047 [USACO12FEB]Nearby Cows P3698 [CQOI2017]小Q的棋盘 P5658 括号树 P2607 [ZJOI2008]骑士 P3177 [HAOI2015]树上染色 P4395 [BOI2003]Gem P4516 [JSOI2018]潜入行动 Part 4.5 状态压缩动态规划 将一个状态压缩为一个整数（通常为二进制数），就可以在更为方便地进行状态转移的同时，达到节约空间的目的。\nP2704 [NOI2001]炮兵阵地 P1879 [USACO06NOV]Corn Fields P1896 [SCOI2005]互不侵犯 P3092 [USACO13NOV]No Change P3694 邦邦的大合唱站队 P4925 [1007]Scarlet的字符串不可能这么可爱 P2157 [SDOI2009]学校食堂 P2167 [SDOI2009]Bill的挑战 P2396 yyy loves Maths VII P4363 [九省联考2018]一双木棋 P5005 中国象棋 - 摆上马 P2150 [NOI2015]寿司晚宴 Part 4.6 倍增优化动态规划 利用倍增的方式，我们可以将状态转移的效率大大提高。\nP1613 跑路 P1081 开车旅行 P5024 保卫王国 Part 4.7 数据结构优化动态规划 利用数据结构来维护已有信息，也可以达到优化状态转移的目的。\nP4719 【模板】动态dp P4751 动态dp【加强版】 P3287 [SCOI2014]方伯伯的玉米田 P2605 [ZJOI2010]基站选址 Part 4.8 单调队列优化动态规划 借助单调队列，排除不可能的决策，可以起到优化状态转移的效果。\nP1776 宝物筛选 - Accept P3089 [USACO13NOV]Pogo-Cow P3572 [POI2014]PTA-Little Bird P3522 [POI2011]TEM-Temperature P4544 [USACO10NOV]Buying Feed P5665 划分 P1973 [NOI2011]Noi嘉年华 P2569 [SCOI2010]股票交易 P4852 yyf hates choukapai Part 4.9 斜率优化动态规划 通过用单调队列维护一个凸壳，来达到优化转移的目的。\nP2900 [USACO08MAR]Land Acquisition P3195 [HNOI2008]玩具装箱 P3628 [APIO2010]特别行动队 P3648 [APIO2014]序列分割 P4027 [NOI2007]货币兑换 P4360 [CEOI2004]锯木厂选址 P5468 [NOI2019]回家路线 P2305 [NOI2014]购票 Part 4.10 决策单调性优化动态规划 利用决策间的递变规律，也能实现优化状态转移的目的。\nP3515 [POI2011]Lightning Conductor P4767 [IOI2000]邮局 P1912 [NOI2009]诗人小G P1973 [NOI2011]Noi嘉年华 P3724 [AH2017/HNOI2017]大佬 P5574 [CmdOI2019]任务分配问题 Part 4.11 数位统计类动态规划 统计一个区间中满足条件的数有多少，就是数位统计类动态规划。\nP2602 [ZJOI2010]数字计数 P3281 [SCOI2013]数数 P2518 [HAOI2010]计数 P2657 [SCOI2009]windy数 P3286 [SCOI2014]方伯伯的商场之旅 P4124 [CQOI2016]手机号码 P4999 烦人的数学作业 P2606 [ZJOI2010]排列计数 P4798 [CEOI2015 Day1]卡尔文球锦标赛 Part 4.12 轮廓线动态规划 轮廓线动态规划（即常说的插头 DP）是一种特殊的状压动态规划，通过以轮廓线为状态来实现状态转移。\nP5056 【模板】插头dp P2289 [HNOI2004]邮递员 P2337 [SCOI2012]喵星人的入侵 P5347 【XR-1】俄罗斯方块 Part 5 字符串 字符串问题有很多自己的特点。\nPart 5.1 字符串哈希 字符串哈希通过牺牲很小的准确率，达到快速进行字符串匹配的效果。\nP3370 【模板】字符串哈希 P5270 无论怎样神树大人都会删库跑路 P5537 【XR-3】系统设计 Part 5.2 KMP KMP 算法可以用来解决模式串匹配问题。\nP3375 【模板】KMP字符串匹配 - Accept P4391 [BOI2009]Radio Transmission P3435 [POI2006]OKR-Periods of Words P4824 [USACO15FEB]Censoring (Silver) P2375 [NOI2014]动物园 P3426 [POI2005]SZA-Template P3193 [HNOI2008]GT考试 Part 5.3 Manacher Manacher 可以在线性时间内求出一个字符串的最长回文子串。\nP3805 【模板】manacher算法 P4555 [国家集训队]最长双回文串 P1659 [国家集训队]拉拉队排练 Part 5.4 Trie树 Trie树可以像查字典一样把多个字符串组织到一棵树上。\nP3879 [TJOI2010]阅读理解 P2292 [HNOI2004]L语言 P2922 [USACO08DEC]Secret Message P3065 [USACO12DEC]First! P3294 [SCOI2016]背单词 P4407 [JSOI2009]电子字典 P4551 最长异或路径 P4683 [IOI2008]Type Printer P3783 [SDOI2017]天才黑客 Part 5.5 AC自动机 AC自动机可以看成是 KMP 和 Trie 的结合体，用于解决多字符串匹配问题。\nP3808 【模板】AC自动机（简单版） P3796 【模板】AC自动机（加强版） P5357 【模板】AC自动机（二次加强版） P3121 [USACO15FEB]Censoring (Gold) P2414 [NOI2011]阿狸的打字机 P3966 [TJOI2013]单词 P2444 [POI2000]病毒 P3311 [SDOI2014]数数 P4052 [JSOI2007]文本生成器 P5599 【XR-4】文本编辑器 Part 5.6 回文自动机 回文自动机是解决回文串问题的有力工具。\nP5496 【模板】回文自动机（PAM） P3649 [APIO2014]回文串 P4287 [SHOI2011]双倍回文 P4762 [CERC2014]Virus synthesis Part 5.7 后缀数组 后缀数组可以解决很多字符串匹配的问题。\nP3809 【模板】后缀排序 P5353 【模板】树上后缀排序 P2336 [SCOI2012]喵星球上的点名 P2463 [SDOI2008]Sandy的卡片 P2852 [USACO06DEC]Milk Patterns P4051 [JSOI2007]字符加密 P1117 [NOI2016]优秀的拆分 P2178 [NOI2015]品酒大会 P5346 【XR-1】柯南家族 P5576 [CmdOI2019]口头禅 Part 5.8 后缀自动机 后缀自动机是一种处理字符串问题的强大工具。\nP3804 【模板】后缀自动机 P3649 [APIO2014]回文串 P3975 [TJOI2015]弦论 P4248 [AHOI2013]差异 P5341 [TJOI2019]甲苯先生和大中锋的字符串 P4770 [NOI2018]你的名字 P5284 [十二省联考2019]字符串问题 P5319 [BJOI2019]奥术神杖 Part 6 数学 OI 中的数学知识很多，也有些杂乱。\nPart 6.1 位运算 将十进制整数转换为二进制后，有很多按位运算的运算符。\n如果能善于利用位运算的一些性质，往往能达到事半功倍的效果。\nP5657 格雷码 P5514 [MtOI2019]永夜的报应 P5538 【XR-3】Namid[A]me P5539 【XR-3】Unknown Mother-Goose P5523 [yLOI2019]珍珠 Part 6.2 整除相关 与整除相关的概念有很多，比较常用的有素数，最大公约数和欧拉函数。\nPart 6.2.1 素数 素数，指的是除 1 和它本身之外没有其他约数的数。\nP4718 【模板】Pollard-Rho算法 P1075 质因数分解 - Accept P2441 角色属性树 P5535 【XR-3】小道消息 Part 6.2.2 最大公约数 如果两个数有一个共同的约数，那么这个约数就被称为公约数。最大公约数就是指这两个数的所有公约数中，最大的一个。\n求解两个数的最大公约数，可以采用欧几里得算法解决。\nP5435 【模板】快速 GCD P5436 【XR-2】缘分 P1029 最大公约数和最小公倍数问题 - Accept P1414 又是毕业季II P2152 [SDOI2009]SuperGCD P1072 Hankson 的趣味题 Part 6.2.3 欧拉函数 欧拉函数 $ \\varphi (x) $ 表示了小于 $ x $ 的数字中，与 $ x $ 互质的数字个数。\nP2158 [SDOI2008]仪仗队 P2568 GCD P2398 GCD SUM P4139 上帝与集合的正确用法 Part 6.3 同余方程 求解同余方程往往可以引出不少话题。\nPart 6.3.1 线性同余方程\u0026amp;乘法逆元 线性同余方程是同余方程中最基础的内容。\nP4549 【模板】裴蜀定理 P2613 【模板】有理数取余 P3811 【模板】乘法逆元 P5431 【模板】乘法逆元2 P1082 同余方程 P3951 小凯的疑惑 P1516 青蛙的约会 Part 6.3.2 中国剩余定理 中国剩余定理可以快速解一元线性同余方程组。\nP4777 【模板】扩展中国剩余定理（EXCRT） P3868 [TJOI2009]猜数字 P2480 [SDOI2010]古代猪文 P4774 [NOI2018]屠龙勇士 P5345 【XR-1】快乐肥宅 Part 6.3.3 高次同余方程 BSGS 算法可以高效计算离散对数。\n而高次剩余的求解更加复杂，其中二次剩余作为高次剩余中比较特殊的情况，可以使用 Cipolla 法求解。\nP4195 【模板】exBSGS P5491 【模板】二次剩余 P3306 [SDOI2013]随机数生成器 P2485 [SDOI2011]计算器 Part 6.4 博弈论 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。\nP2197 【模板】nim游戏 P1288 取数游戏II P1290 欧几里德的游戏 P1247 取火柴游戏 P2252 取石子游戏 Part 6.5 概率与期望 概率和期望是紧密相连的，OI 中往往会出现和概率期望相关的动态规划问题。\nP5104 红包发红包 P1850 换教室 P3830 [SHOI2012]随机树 P4564 [CTSC2018]假面 P2473 [SCOI2008]奖励关 P2221 [HAOI2012]高速公路 P3239 [HNOI2015]亚瑟王 P3750 [六省联考2017]分手是祝愿 P4284 [SHOI2014]概率充电器 P5249 [LnOI2019]加特林轮盘赌 P2081 [NOI2012]迷失游乐园 P3343 [ZJOI2015]地震后的幻想乡 P3600 随机数生成器 P5326 [ZJOI2019]开关 Part 6.6 组合数学 组合数学常常与计数问题，概率期望紧密相连。\nPart 6.6.1 排列组合 排列组合是组合数学的基础。\nP3807 【模板】卢卡斯定理 P2822 组合数问题 P5520 [yLOI2019]青原樱 P3197 [HNOI2008]越狱 P2290 [HNOI2004]树的计数 P4981 父子 P4769 [NOI2018]冒泡排序 P4931 情侣？给我烧了！（加强版） P5596 【XR-4】题 P5598 【XR-4】混乱度 Part 6.6.2 卡特兰数\u0026amp;斯特林数 卡特兰数和斯特林数是两类常见的组合递推数列。\nP5395 第二类斯特林数·行 P5396 第二类斯特林数·列 P5408 第一类斯特林数·行 P5409 第一类斯特林数·列 P1655 小朋友的球 P2532 [AHOI2012]树屋阶梯 P3200 [HNOI2009]有趣的数列 P3978 [TJOI2015]概率论 P4091 [HEOI2016/TJOI2016]求和 P4827 [国家集训队]Crash 的文明世界 Part 6.6.3 容斥原理 容斥原理常常用于解决集合的计数问题。\nP5664 Emiya 家今天的饭 P1450 [HAOI2008]硬币购物 P3214 [HNOI2011]卡农 P3270 [JLOI2016]成绩比较 P4336 [SHOI2016]黑暗前的幻想乡 P4448 [AHOI2018初中组]球球的排列 P4491 [HAOI2018]染色 P5339 [TJOI2019]唱、跳、rap和篮球 P5400 [CTS2019]随机立方体 Part 6.7 线性代数 线性代数主要用于解决线性关系问题。\nPart 6.7.1 矩阵 利用矩阵优化数列递推，可以实现复杂度从线性到对数级的转变。\nP3390 【模板】矩阵快速幂 P1939 【模板】矩阵加速（数列） P4783 【模板】矩阵求逆 P1962 斐波那契数列 P1349 广义斐波那契数列 P4000 斐波那契数列 P3758 [TJOI2017]可乐 P4967 黑暗打击 P5343 【XR-1】分块 P5337 [TJOI2019]甲苯先生的字符串 P5303 [GXOI/GZOI2019]逼死强迫症 Part 6.7.2 高斯消元 高斯消元可以用来求解方程组。\nP3389 【模板】高斯消元法 P2447 [SDOI2010]外星千足虫 P4035 [JSOI2008]球形空间产生器 P5516 [MtOI2019]小铃的烦恼 P4111 [HEOI2015]小Z的房间 P4457 [BJOI2018]治疗之雨 Part 6.7.3 线性基 线性基可以求解最大异或和的一类问题。\nP3812 【模板】线性基 P3857 [TJOI2008]彩灯 P4570 [BJWC2011]元素 P4301 [CQOI2013]新Nim游戏 P3292 [SCOI2016]幸运数字 P4151 [WC2011]最大XOR和路径 Part 6.8 多项式 对多项式的运算进行优化，从而能够解决规模更大的问题。\nP3803 【模板】多项式乘法（FFT） P4238 【模板】多项式求逆 P4245 【模板】任意模数NTT P4512 【模板】多项式除法 P4717 【模板】快速沃尔什变换 P4721 【模板】分治 FFT P4725 【模板】多项式对数函数 P4726 【模板】多项式指数函数 P4781 【模板】拉格朗日插值 P5050 【模板】多项式多点求值 P5158 【模板】多项式快速插值 P5205 【模板】多项式开根 P5245 【模板】多项式快速幂 P5273 【模板】多项式幂函数 (加强版) P5282 【模板】快速阶乘算法 P5373 【模板】多项式复合函数 P5394 【模板】下降幂多项式乘法 P3338 [ZJOI2014]力 P3723 [AH2017/HNOI2017]礼物 P5437 【XR-2】约定 P5293 [HNOI2019]白兔之舞 P5432 A/B Problem (加强版) P5472 [NOI2019]斗主地 P5577 [CmdOI2019]算力训练 Part 6.9 莫比乌斯反演 运用莫比乌斯反演，我们可以将一些函数转化，从而降低计算难度。\nP3172 [CQOI2015]选数 P2522 [HAOI2011]Problem b P3455 [POI2007]ZAP-Queries P3327 [SDOI2015]约数个数和 P1829 [国家集训队]Crash的数字表格 / JZPTAB P4619 [SDOI2018]旧试题 P3704 [SDOI2017]数字表格 P5518 [MtOI2019]幽灵乐团 Part 6.10 筛法 利用数列的性质，有多种筛法可以求出我们想要的信息。\nP3383 【模板】线性筛素数 P4213 【模板】杜教筛（Sum） P5325 【模板】Min_25筛 P1865 A % B Problem P1621 集合 P3768 简单的数学题 P5438 【XR-2】记忆 Part 6.11 线性规划 线性规划是研究线性约束条件下线性目标函数极值问题的方法。\nP3980 [NOI2008]志愿者招募 P4232 无意识之外的捉迷藏 Part 6.12 数值方法 在算法领域，有很多求近似值的数值方法。\nPart 6.12.1 三分法 三分法可以求出一个单峰 / 单谷函数的极值。\nP3382 【模板】三分法 P1883 函数 Part 6.12.2 自适应辛普森法 自适应辛普森法可以高效求出给定函数的数值积分。\nP4525 【模板】自适应辛普森法1 P4526 【模板】自适应辛普森法2 P3779 [SDOI2017]龙与地下城 Part 6.13 置换群 置换群通常用来解决一些涉及“本质不同”的计数问题。\nP4980 【模板】Polya定理 P1446 [HNOI2008]Cards P2561 [AHOI2002]黑白瓷砖 P4128 [SHOI2006]有色图 P4727 [HNOI2009]图的同构记数 Part 7 数据结构 灵活地运用数据结构可以高效地查询并处理需要的信息。\nPart 7.1 链表 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。\nP1996 约瑟夫问题 P1160 队列安排 Part 7.2 栈 栈，是一种后进先出（FILO）的数据结构。\nP1449 后缀表达式 P1739 表达式括号匹配 P1981 表达式求值 P1175 表达式的转换 Part 7.3 队列 队列，是一种先进先出（FIFO）的数据结构。\nP1540 机器翻译 Part 7.4 并查集 并查集常用于处理一些不相交集合的合并和查询问题。\nP1111 修复公路 - Accept P3958 奶酪 - Accept P1525 关押罪犯 - Accept P4185 [USACO18JAN]MooTube G P2024 [NOI2001]食物链 P1197 [JSOI2008]星球大战 P1196 [NOI2002]银河英雄传说 P1955 [NOI2015]程序自动分析 Part 7.5 二叉堆 二叉堆是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。\nP3378 【模板】堆 P1090 合并果子 - Accept P1168 中位数 - Accept P2085 最小函数值 P2827 蚯蚓 P3045 [USACO12FEB]Cow Coupons Part 7.6 ST表 ST表可以离线查询区间最值。\nP3865 【模板】ST表 - Accept P2251 质量检测 P1816 忠诚 P1198 [JSOI2008]最大数 P2880 [USACO07JAN]Balanced Lineup P5012 水の数列 P5344 【XR-1】逛森林 P2048 [NOI2010]超级钢琴 Part 7.7 树状数组 树状数组是一种简洁高效的树形数据结构。\nP3374 【模板】树状数组 1 P3368 【模板】树状数组 2 P1908 逆序对 - Accept P1966 火柴排队 P3605 [USACO17JAN]Promotion Counting P1972 [SDOI2009]HH的项链 P3586 [POI2015]LOG P4054 [JSOI2009]计数问题 P4113 [HEOI2012]采花 P3960 列队 Part 7.8 线段树 线段树的通用性比树状数组更强，可以处理更多涉及区间操作的题目。\nP3372 【模板】线段树 1 - Accept P3373 【模板】线段树 2 P5490 【模板】扫描线 P4588 [TJOI2018]数学计算 P1502 窗口的星星 P2471 [SCOI2007]降雨量 P2824 [HEOI2016/TJOI2016]排序 P3722 [AH2017/HNOI2017]影魔 P4097 [HEOI2013]Segment P4198 楼房重建 P4513 小白逛公园 P4556 [Vani有约会]雨天的尾巴 P5324 [BJOI2019]删数 P5327 [ZJOI2019]语言 Part 7.9 分块 分块是一种非常通用的暴力方法，虽然效率不如线段树和树状数组，但可以解决很多线段树和树状数组处理不了的问题。\nP3870 [TJOI2009]开关 P3396 哈希冲突 P3863 序列 P1975 [国家集训队]排队 P3710 方方方的数据结构 P3992 [BJOI2017]开车 P4168 [Violet]蒲公英 P4119 [Ynoi2018]未来日记 Part 7.10 可并堆 可并堆分为左偏树和配对堆两种，它们都具有堆的性质，且可以高效合并。\nP3377 【模板】左偏树（可并堆） P2713 罗马游戏 P1456 Monkey King P1552 [APIO2012]派遣 P3261 [JLOI2015]城池攻占 P3273 [SCOI2011]棘手的操作 P4331 [BOI2004]Sequence Part 7.11 主席树 主席树，即可持久化权值线段树。\nP2468 [SDOI2010]粟粟的书架 P3302 [SDOI2013]森林 P3168 [CQOI2015]任务查询系统 P4559 [JSOI2018]列队 P2633 Count on a tree P3293 [SCOI2016]美味 P4618 [SDOI2018]原题识别 Part 7.12 平衡树 二叉搜索树可以用来维护有序序列。\n为了保证查询效率，有多种使二叉搜索树保持平衡的实现方法。\nP3369 【模板】普通平衡树 P3391 【模板】文艺平衡树（Splay） P3850 [TJOI2007]书架 P4008 [NOI2003]文本编辑器 P5338 [TJOI2019]甲苯先生的滚榜 P2042 [NOI2005]维护数列 P1110 [ZJOI2007]报表统计 P3644 [APIO2015]八邻旁之桥 P1486 [NOI2004]郁闷的出纳员 P2710 数列 P3224 [HNOI2012]永无乡 P3285 [SCOI2014]方伯伯的OJ P5321 [BJOI2019]送别 Part 7.13 树链剖分 树链剖分可以将任意一条树上路径划分成若干条连续的链，并用线段树等数据结构高效维护链上信息。\nP3384 【模板】树链剖分 P3313 [SDOI2014]旅行 P2590 [ZJOI2008]树的统计 P1505 [国家集训队]旅游 P2486 [SDOI2011]染色 P3258 [JLOI2014]松鼠的新家 P4069 [SDOI2016]游戏 P4211 [LNOI2014]LCA P4592 [TJOI2018]异或 P5305 [GXOI/GZOI2019]旧词 P5354 [Ynoi2017]由乃的OJ P5499 [LnOI2019]Abbi并不想研学 Part 7.14 树套树 树套树可以用来维护多维度信息。\nP3380 【模板】二逼平衡树（树套树） P1975 [国家集训队]排队 P3332 [ZJOI2013]K大数查询 P4278 带插入区间K小值 P1903 [国家集训队]数颜色 / 维护队列 P3759 [TJOI2017]不勤劳的图书管理员 P3242 [HNOI2015]接水果 P3248 [HNOI2016]树 P5445 [APIO2019]路灯 Part 7.15 动态树 Link-Cut Tree 可以用来解决动态树一类问题。\nP3690 【模板】Link Cut Tree （动态树） P3203 [HNOI2010]弹飞绵羊 P4338 [ZJOI2018]历史 P4312 [COCI2009]OTOCI P1501 [国家集训队]Tree II P2387 [NOI2014]魔法森林 P3348 [ZJOI2016]大森林 P3703 [SDOI2017]树点涂色 P4172 [WC2006]水管局长 P4219 [BJOI2014]大融合 P5489 EntropyIncreaser 与 动态图 Part 7.16 可持久化数据结构 可持久化数据结构实现了在更新信息的时候保留历史版本。\nP3919 【模板】可持久化数组（可持久化线段树/平衡树） P3834 【模板】可持久化线段树 1（主席树） P3402 【模板】可持久化并查集 P3835 【模板】可持久化平衡树 P5055 【模板】可持久化文艺平衡树 P5283 [十二省联考2019]异或粽子 Part 7.17 K-D Tree K-D Tree 是一种高效处理 $ k $ 维信息的数据结构。\nP4357 [CQOI2016]K远点对 P4148 简单题 P2479 [SDOI2010]捉迷藏 P3769 [CH弱省胡策R2]TATT P4169 [Violet]天使玩偶/SJY摆棋子 P4390 [BOI2007]Mokia P4475 巧克力王国 P2093 [国家集训队]JZPFAR P5471 [NOI2019]弹跳 Part 7.18 珂朵莉树 珂朵莉树，是一种基于 std::set 的暴力数据结构，在数据随机的情况下表现优秀。\nP5251 [LnOI2019]第二代图灵机 P5350 序列 Part 8 图论 图论是数学的一个分支，它以图为研究的对象。\nPart 8.1 图的存储与遍历 这里的图论内容都比较简单，涉及图的存储以及遍历图的方式。\nP2661 信息传递 P2921 [USACO08DEC]Trick or Treat on the Farm Part 8.2 最短路问题 很多题目都可以转化为最短路的模型。因此，掌握最短路算法非常重要。\nP3371 【模板】单源最短路径（弱化版） - Accept P4779 【模板】单源最短路径（标准版） - Accept P5905 【模板】Johnson 全源最短路 P1144 最短路计数 - Accept P1462 通往奥格瑞玛的道路 P1522 Cow Tours P1266 速度限制 P4001 [ICPC-Beijing 2006]狼抓兔子 P4568 [JLOI2011]飞行路线 P3238 [HNOI2014]道路堵塞 P5304 [GXOI/GZOI2019]旅行者 Part 8.3 树上问题 作为一种特殊的图，树上的问题具有很多鲜明的特点。\nPart 8.3.1 二叉树 二叉树是一种特殊的树，它有很多特殊的性质。\nP1087 FBI树 P1030 求先序排列 P1305 新二叉树 P1229 遍历问题 P5018 对称二叉树 P5597 【XR-4】复读 Part 8.3.2 树的直径 树的直径被定义为树上最远的两点间的距离。\n计算树的直径，可以通过两遍 DFS 解决。\nP2195 HXY造公园 P3629 [APIO2010]巡逻 P5536 【XR-3】核心城市 P1099 树网的核 P4408 [NOI2003]逃学的小孩 Part 8.3.3 最近公共祖先 两个点的最近公共祖先，即两个点的所有公共祖先中，离根节点最远的一个节点。\n求解最近公共祖先，常用的方法是树上倍增或者树链剖分。\nP3379 【模板】最近公共祖先（LCA） P3938 斐波那契 P4281 [AHOI2008]紧急集合 / 聚会 Part 8.4 生成树 用 $ n-1 $ 条边将图上的 $ n $ 个点连接起来，形成的树就被称为生成树。\nP3366 【模板】最小生成树 P4180 【模板】严格次小生成树[BJWC2010] P2872 [USACO07DEC]Building Roads P1991 无线通讯网 P1967 货车运输 P4047 [JSOI2010]部落划分 Part 8.5 拓扑排序 将一个有向无环图排序，使得所有排在前面的节点不能依赖于排在后面的节点，这就是拓扑排序。\nP1113 杂务 P1983 车站分级 P1038 神经网络 Part 8.6 差分约束 差分约束要解决的问题是：求出一组 $ n $ 元不等式的一组解，使得所有约束关系都能得到满足。\nP5960 【模板】差分约束算法 P3275 [SCOI2011]糖果 P2294 [HNOI2005]狡猾的商人 P4926 [1007]倍杀测量者 P5590 赛车游戏 Part 8.7 图的连通性相关 利用 Tarjan 算法，我们可以解决很多与图的连通性相关的问题。\nP3387 【模板】缩点 P3388 【模板】割点（割顶） P2341 [HAOI2006]受欢迎的牛 P2863 [USACO06JAN]The Cow Prom P2746 [USACO5.3]Network of Schools P1407 [国家集训队]稳定婚姻 P2272 [ZJOI2007]最大半连通子图 P3225 [HNOI2012]矿场搭建 P5058 [ZJOI2004]嗅探器 P2515 [HAOI2010]软件安装 Part 8.8 二分图 二分图上的不少问题都可以转化成网络流解决，当然也有独特的其他方法。\nP3386 【模板】二分图匹配 P2756 飞行员配对方案问题 P1129 [ZJOI2007]矩阵游戏 P1559 运动员最佳匹配问题 P2423 [HEOI2012]朋友圈 P2764 最小路径覆盖问题 P2825 [HEOI2016/TJOI2016]游戏 P3033 [USACO11NOV]Cow Steeplechase P3731 [HAOI2017]新型城市化 P4014 分配问题 P4617 [COCI2017-2018#5] Planinarenje Part 8.9 网络流 网络流是图论中一个重要的分支，很多题目都可以通过建立网络流的模型来解决。\nPart 8.9.1 最大流 最大流，即求网络中最大的流量。\nP3376 【模板】网络最大流 - Accept P4722 【模板】最大流 加强版 / 预流推进 P2065 [TJOI2011]卡片 P2763 试题库问题 P2472 [SCOI2007]蜥蜴 P2754 [CTSC1999]家园 P2765 魔术球问题 P2766 最长不下降子序列问题 P2805 [NOI2009]植物大战僵尸 P3749 [六省联考2017]寿司餐厅 Part 8.9.2 最小割 最小割，即求一个边权最小的边集，使得源点和汇点不再连通。\n可以证明，最大流=最小割。\nP1345 [USACO5.4]Telecowmunication P2057 [SHOI2007]善意的投票 P2598 [ZJOI2009]狼和羊的故事 P2774 方格取数问题 P4126 [AHOI2009]最小割 P5039 [SHOI2010]最小生成树 Part 8.9.3 费用流 在网络流中给边加上一个参数——费用，就出现了费用流。\nP3381 【模板】最小费用最大流 P4016 负载平衡问题 P4452 [国家集训队]航班安排 P2045 方格取数加强版 P2050 [NOI2012]美食节 P2053 [SCOI2007]修车 P2604 [ZJOI2010]网络扩容 P2770 航空路线问题 P3159 [CQOI2012]交换棋子 P3356 火星探险问题 P3358 最长k可重区间集问题 P4013 数字梯形问题 P4015 运输问题 P5331 [SNOI2019]通信 Part 8.9.4 上下界网络流 在网络流问题中给每条边的流量增加一个下界，就有了上下界网络流。\nP3980 [NOI2008]志愿者招募 P4043 [AHOI2014/JSOI2014]支线剧情 P4553 80人环游世界 P4843 清理雪道 Part 8.10 2-SAT k-SAT 问题的目标是对一些布尔变量赋值，满足限定的条件。\n在 k-SAT 问题中，2-SAT 问题属于较为容易解决的一类。\nP4782 【模板】2-SAT 问题 P4171 [JSOI2010]满汉全席 P3825 [NOI2017]游戏 P5332 [JSOI2019]精准预测 Part 8.11 点分治 点分治是一种可以高效统计树上路径信息的算法。\nP3806 【模板】点分治1 P2634 [国家集训队]聪聪可可 P2664 树上游戏 P3714 [BJOI2017]树的难题 P4149 [IOI2011]Race P3241 [HNOI2015]开店 P4075 [SDOI2016]模式字符串 P4183 [USACO18JAN]Cow at Large P P4292 [WC2010]重建计划 P5306 [COCI2019]Transport Part 8.12 虚树 将一些无用的点从树上删去，从而达到降低树的规模的效果。\nP2495 [SDOI2011]消耗战 P3233 [HNOI2014]世界树 P5360 [SDOI2019]世界地图 P5439 【XR-2】永恒 Part 8.13 矩阵树定理 矩阵树定理可以解决图的生成树计数问题。\nP4111 [HEOI2015]小Z的房间 P2144 [FJOI2007]轮状病毒 P3317 [SDOI2014]重建 P4208 [JSOI2008]最小生成树计数 Part 9 计算几何 试着用计算机来解决几何问题吧！\nPart 9.1 凸包 凸包指在平面上能包含所有给定点的最小凸多边形。\nP2742 【模板】二维凸包 P2287 [HNOI2004]最佳包裹 P3829 [SHOI2012]信用卡凸包 P4680 [Ynoi2018]末日时在做什么?有没有空?可以来拯救吗? P4557 [JSOI2018]战争 P5403 [CTS2019]田野 Part 9.2 旋转卡壳 旋转卡壳是一种求出凸包所有对踵点对的算法。\nP1452 Beauty Contest P3187 [HNOI2007]最小矩形覆盖 Part 9.3 半平面交 多个半平面的交集称之为半平面交。\nP3256 [JLOI2013]赛车 P2600 [ZJOI2008]瞭望塔 P4196 [CQOI2006]凸多边形 P3297 [SDOI2013]逃考 P4250 [SCOI2015]小凸想跑步 P5328 [ZJOI2019]浙江省选 Part 10 杂项 这里的专题，有很多都难以纳入前面的类别中，故将他们单独列入了杂项。\nPart 10.1 模拟退火 模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。\nP1337 [JSOI2004]平衡点 / 吊打XXX P2503 [HAOI2006]均分数据 P3878 [TJOI2010]分金币 Part 10.2 0/1 分数规划 0/1 分数规划用来求一个分式的极值。\nP4377 [USACO18OPEN]Talent Show P3199 [HNOI2009]最小圈 P3288 [SCOI2014]方伯伯运椰子 P3705 [SDOI2017]新生舞会 P4322 [JSOI2016]最佳团体 Part 10.3 离线算法 当题目不要求强制在线时，我们可以一次性读入所有询问来处理。\nPart 10.3.1 CDQ 分治 CDQ 分治是一个基于分治思想的离线算法。\nP3810 【模板】三维偏序（陌上花开） P3157 [CQOI2011]动态逆序对 P2487 [SDOI2011]拦截导弹 P4690 [Ynoi2016]镜中的昆虫 P3206 [HNOI2010]城市建设 Part 10.3.2 整体二分 整体二分，顾名思义就是把多个查询一起二分解决。\nP1527 [国家集训队]矩阵乘法 P2617 Dynamic Rankings P3527 [POI2011]MET-Meteors P4602 [CTSC2018]混合果汁 Part 10.3.3 莫队 莫队算法可以解决不少离线区间询问问题。\nP1494 [国家集训队]小Z的袜子 /【模板】莫队 P1903 [国家集训队]数颜色 / 维护队列 /【模板】带修莫队 P5906 【模板】回滚莫队 P4887 【模板】莫队二次离线（第十四分块(前体)） P2709 小B的询问 P3674 小清新人渣的本愿 P3709 大爷的字符串题 P4074 [WC2013]糖果公园 P5501 [LnOI2019]来者不拒，去者不追 Part 10.4 奇怪的题目 OI 界中有一些非常规套路的题目，这里放出来分享。\nP4920 [WC2015]未来程序 P5042 [国家集训队]丢失的题面（ydc的题面） P5285 [十二省联考2019]骗分过样例 P5246 [集训队互测2016]消失的源代码 Part 10.5 非传统题 在 NOI 等比赛中，非传统题正越来越频繁出现。\n非传统题主要包括以下几类：提交答案题，交互题，通信题。\nPart 10.5.1 提交答案题 给你一些输入，你只需要提交这些输入对应的答案，即为提交答案题。\nP1335 [NOI2013]小Q的修炼 P1737 [NOI2016]旷野大计算 P3614 yyy棋 II P3640 [APIO2013]出题人 P3782 [WC2017]排序 P3836 Nowruz P4920 [WC2015]未来程序 P5402 [CTS2019]无处安放 P5418 [CTSC2016]NOIP十合一 P5600 【XR-4】尺规作图 Part 10.5.2 交互题 在交互题中，选手程序需要通过与测评程序交互来完成任务。\nP1733 猜数（IO交互版） P1947 猜数 P5208 [WC2019]I 君的商店 P5473 [NOI2019]I 君的探险 P6541 [WC2018]即时战略 P6558 [APIO2017]考拉的游戏 ","date":"2024-10-24T00:00:00Z","permalink":"https://allergy27.github.io/p/problem_list/","title":"luogu题单"},{"content":"2024级新生第四次考核题解 考核链接：https://vjudge.net/contest/663008\n题目类型 A：签到题 B：暴力 C：模拟、排序 D：优先队列 E：BFS\n说明：\nPython代码全是由C++版本用GPT转译而来，逻辑上没有问题但不保证是在python下的最优实现 B题暴力并非最优解，但是可行解，且在比赛过程中能做上就是最好的 未提供C代码，请善用GPT等工具或尽快掌握C++的基础语法 C++代码统一模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Copyright 2024 Allergy /* @author Allergy * @email Allergy527@gmail.com * @workspace Atcoder\\10.13New\\a.cpp * @date 2024/10/13 17:21:44 */ #include\u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x)\u0026amp;(-(x))) // #define int int64_t using namespace std; // NOLINT using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; void solve(){ } signed main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); cin \u0026gt;\u0026gt; t; return 0; } Python代码统一模板 1 2 3 4 5 6 7 def solve(): pass if __name__ == \u0026#34;__main__\u0026#34;: t = 1 # t = int(input().strip()) for _ in range(t): solve() A 因为Taffy很 本质上是一道模拟题，按题意从高到低走一遍即可，检测到比前一位小就返回NO\nC++代码 1 2 3 4 5 6 7 8 9 10 11 void solve() { string s; cin \u0026gt;\u0026gt; s; for (int i = 1; i \u0026lt; s.size(); ++i) { if (s[i] \u0026gt;= s[i - 1]) { cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; return; } } cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; } Python代码 1 2 3 4 5 6 7 def solve(): s = input().strip() for i in range(1, len(s)): if s[i] \u0026gt;= s[i - 1]: print(\u0026#34;No\u0026#34;) return print(\u0026#34;Yes\u0026#34;) B 回合制 假设我们从小到大遍历，那么算法时间复杂度为$O(n^2)$，显然跑题目的 $10^{18}$ 会超。 不妨换个想法，我们从最大值开始跑，也就是先检查 $R-L$ 是否满足题意，接着检查 $R-L-1$ ，以此类推\n诶，有同学会问为什么这样就不会超呢？ 我们可以简单思考一下，一开始质数的间隔小，接着间隔越来越大： 2 3 5 7 11 13 17 19 23 29 31 37 41 43 49 我们可以大胆猜测每隔 $5000$ 个肯定有两个是质数，而即便是 $5000$ ，$5000*5000\\approx10^7 $ ，这个数量级肯定是不会超的。至于详细证明见维基百科： https://en.wikipedia.org/wiki/Prime_gap C++代码 1 2 3 4 5 6 7 8 9 10 11 12 void solve() { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int w = r - l; w \u0026gt; 0; w--) { //从最宽的情况遍历 for (int j = l; j \u0026lt; r - w + 1; ++j) { if (__gcd(j, j + w) == 1) { //调用库函数求最大公约数 cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } } } } Python代码 1 2 3 4 5 6 7 8 9 import math def solve(): l, r = map(int, input().split()) for w in range(r - l, 0, -1): #从最宽的情况遍历 for j in range(l, r - w + 1): if math.gcd(j, j + w) == 1: #调用库函数求最大公约数 print(w) return C 可爱狗 首先，两个颜色相同的狗不会摸头，而题目保证了给定输入是偶数，那么如果每种颜色都为偶数个，则可以两两分组而不产生摸头。 接着我们讨论有颜色不为偶数的情况，由容斥原理，只会有两种颜色为奇数。 不妨假设 R 和 G 为奇数，那么取得最小摸头速度的情况只会是取min_diff(R,G)或min_diff(R,B)+min_diff(G,B)，比较后取较小者 (这里的min_diff并非库函数，仅是举例)\n有同学可能会问，为什么 R 和 G 不会取 B 中的同一个值？ 这点也不难理解，如果最优解时R和G取同一个B值，那答案是一定取min_diff(R,G)的，证明不困难，就留给各位了 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; qwq(3); for (int i = 0; i \u0026lt; 2 * n; i++) { int x; char y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; switch (y) { case \u0026#39;R\u0026#39;: qwq[0].emplace_back(x); break; case \u0026#39;G\u0026#39;: qwq[1].emplace_back(x); break; case \u0026#39;B\u0026#39;: qwq[2].emplace_back(x); break; default: break; } } for (auto \u0026amp;x : qwq) sort(x.begin(), x.end()); int r = qwq[0].size(), g = qwq[1].size(), b = qwq[2].size(); if (r % 2 == 0 \u0026amp;\u0026amp; g % 2 == 0 \u0026amp;\u0026amp; b % 2 == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; ln; return; } if (r % 2 == 0) { swap(r, b); swap(qwq[0], qwq[2]); } else if (g % 2 == 0) { swap(g, b); swap(qwq[1], qwq[2]); } // lambda 表达式，在外面写函数也可以 auto check = [\u0026amp;](vector\u0026lt;int\u0026gt; p, vector\u0026lt;int\u0026gt; q) -\u0026gt; int { //即min_diff函数 int point_p = 0, point_q = 0; int len_p = p.size(), len_q = q.size(); int ans = ll_inf; while (point_p \u0026lt; len_p \u0026amp;\u0026amp; point_q \u0026lt; len_q) { ans = min(ans, abs(p[point_p] - q[point_q])); if (p[point_p] \u0026lt; q[point_q]) { ++point_p; } else { ++point_q; } } return ans; }; int ans = check(qwq[0], qwq[1]); if (b \u0026gt; 2) { ans = min(ans, check(qwq[0], qwq[2]) + check(qwq[1], qwq[2])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import sys def solve(): n = int(input().strip()) qwq = [[] for _ in range(3)] for _ in range(2 * n): x, y = input().strip().split() x = int(x) if y == \u0026#39;R\u0026#39;: qwq[0].append(x) elif y == \u0026#39;G\u0026#39;: qwq[1].append(x) elif y == \u0026#39;B\u0026#39;: qwq[2].append(x) for lst in qwq: lst.sort() r, g, b = len(qwq[0]), len(qwq[1]), len(qwq[2]) if r % 2 == 0 and g % 2 == 0 and b % 2 == 0: print(0) return if r % 2 == 0: qwq[0], qwq[2] = qwq[2], qwq[0] elif g % 2 == 0: qwq[1], qwq[2] = qwq[2], qwq[1] def check(p, q): point_p, point_q = 0, 0 len_p, len_q = len(p), len(q) ans = sys.maxsize while point_p \u0026lt; len_p and point_q \u0026lt; len_q: ans = min(ans, abs(p[point_p] - q[point_q])) if p[point_p] \u0026lt; q[point_q]: point_p += 1 else: point_q += 1 return ans ans = check(qwq[0], qwq[1]) if len(qwq[2]) \u0026gt; 2: ans = min(ans, check(qwq[0], qwq[2]) + check(qwq[1], qwq[2])) print(ans) D 外卖小哥 我们从后往前看，在第m小时时，我们只能点0小时后结算的订单，m-1时，则可以点0到1小时的订单，依次类推,第0小时可以点0到m小时的订单。也就是我们从后向前遍历，每次取最大值接即可。 由于我们的时间复杂度被限制在$O(nlogn)$，所以必须用$logn$时间取得最大值，我们采用优先队列(最大堆)存储。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void solve() { int n, m, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; qwq; for (int i = 0; i \u0026lt; n; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; qwq[x].emplace_back(y); } priority_queue\u0026lt;int\u0026gt; que; for (int i = 0; i \u0026lt;= m; ++i) { if (qwq.count(i)) for (auto x : qwq[i]) que.push(x); if (!que.empty()) { int t = que.top(); que.pop(); ans += t; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import heapq def solve(): n, m = map(int, input().split()) qwq = {} for _ in range(n): x, y = map(int, input().split()) if x not in qwq: qwq[x] = [] qwq[x].append(y) que = [] ans = 0 for i in range(m + 1): if i in qwq: for val in qwq[i]: heapq.heappush(que, -val) if que: ans += -heapq.heappop(que) print(ans) E 西天取经 跑一遍 广度优先搜索(BFS) 即可，每次更新当前路的最短路径，并且为当前路存一个方案数，代表从东土大唐到该点有多少条方案，每次遇到最短路相同的情况将方案数相加，否则接着跑BFS即可\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void solve() { int n, m, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; qwq(n + 1); vector\u0026lt;int\u0026gt; dis(n + 1, ll_inf), num(n + 1); // bfs距离,方案数 for (int i = 0; i \u0026lt; m; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; qwq[x].emplace_back(y); qwq[y].emplace_back(x); } queue\u0026lt;int\u0026gt; que; que.push(1); dis[1] = 0; num[1] = 1; while (!que.empty()) { int t = que.front(); que.pop(); for (auto x : qwq[t]) { if (dis[x] \u0026gt; dis[t] + 1) { dis[x] = dis[t] + 1; num[x] = num[t]; que.push(x); } else if (dis[x] == dis[t] + 1) { num[x] = (num[x] + num[t]) % mod; } } } cout \u0026lt;\u0026lt; num[n] \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from collections import deque MOD = 10**9 + 7 def solve(): n, m = map(int, input().split()) qwq = [[] for _ in range(n + 1)] dis = [float(\u0026#39;inf\u0026#39;)] * (n + 1) num = [0] * (n + 1) for _ in range(m): x, y = map(int, input().split()) qwq[x].append(y) qwq[y].append(x) que = deque([1]) dis[1] = 0 num[1] = 1 while que: t = que.popleft() for x in qwq[t]: if dis[x] \u0026gt; dis[t] + 1: dis[x] = dis[t] + 1 num[x] = num[t] que.append(x) elif dis[x] == dis[t] + 1: num[x] = (num[x] + num[t]) % MOD print(num[n]) ","date":"2024-10-12T00:00:00Z","permalink":"https://allergy27.github.io/p/flashmen_solve_1/","title":"2024级新生第四次考核题解"},{"content":"Boyer-Moore算法介绍 概述 Boyer-Moore算法（BM算法）是由Robert S. Boyer和J Strother Moore在1977年提出的一种字符串匹配算法。该算法在查找一个子串在主串中首次出现的位置时表现非常出色，尤其在处理较长的文本时具有高效性。它之所以高效，是因为在匹配过程中可以跳过一些无意义的字符，从而减少比较次数。\nBM算法的核心思想是通过分析文本和模式串之间的关系，提前预测某些字符的匹配结果，并在可能的情况下进行大步跳跃，以尽量避免不必要的字符比较。BM算法主要通过两个启发式规则来实现跳跃：坏字符规则和好后缀规则。\n核心思想 1. 坏字符规则（Bad Character Rule） 坏字符规则主要是指在比较过程中，当模式串中的某个字符与主串中的字符不匹配时，可以根据主串中的不匹配字符跳过一些可能不会匹配的位置。其基本原理是将模式串向右移动，直到该不匹配字符在模式串中的下一个匹配位置出现，或者模式串完全移过该不匹配字符。坏字符规则可以避免逐一比较，提升算法效率。\n2. 好后缀规则（Good Suffix Rule） 好后缀规则是当模式串的一部分在主串中匹配时，如果发现有一部分匹配，接下来发生了不匹配的情况，那么可以利用已经匹配的部分（即好后缀）来判断模式串应如何继续向右移动。好后缀规则的目的是确保尽可能大幅度地移动模式串，而不是简单地一位一位地滑动。\n这两个规则的结合使得BM算法能够在大部分情况下避免逐字符比较，尤其是在长文本和较短模式串的情况下，效率尤为明显。\nBM算法的复杂度 BM算法的时间复杂度依赖于文本和模式串的具体内容。它在最坏情况下的时间复杂度为O(mn)，其中m是模式串的长度，n是主串的长度。但在实际使用中，由于它的跳跃特性，BM算法的平均时间复杂度接近于O(n/m)，这使得它在大多数实际应用场景中非常高效。\n应用场景 BM算法特别适用于文本搜索、DNA序列比对、编辑器中的查找替换功能等。其高效的匹配性能使它在处理大规模文本数据时，成为一种常用的字符串匹配算法之一。\n代码样例(rust实现) 该代码实现随机生成两段DNA序列并在找到可以匹配的部分后输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //@author Allergy //@workspace study/bm.rs //@data 2024/10/10 19:15:05 use rand::Rng; fn cin() -\u0026gt; String { let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() } fn main() { let t = 1; //let t = cin().parse::\u0026lt;i32\u0026gt;().unwrap(); let _ = (0..t).for_each(|_| solve()); } fn solve() { let (a, b) = cin() .split_whitespace() .fold((0, 0), |x, y| (x.1, y.parse::\u0026lt;usize\u0026gt;().unwrap())); let trans = |x: char| match x { \u0026#39;A\u0026#39; =\u0026gt; \u0026#39;T\u0026#39;, \u0026#39;T\u0026#39; =\u0026gt; \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39; =\u0026gt; \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39; =\u0026gt; \u0026#39;C\u0026#39;, _ =\u0026gt; \u0026#39; \u0026#39;, }; let show = |qwq: \u0026amp;Vec\u0026lt;char\u0026gt;| { qwq.iter().for_each(|x| print!(\u0026#34;{}\u0026#34;, x)); println!() }; let dna_init = random_dna(a); let dna = dna_init.iter().map(|x| trans(*x)).collect::\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;(); let pattern = random_dna(b); show(\u0026amp;dna_init); println!(\u0026#34;↓\u0026#34;); show(\u0026amp;pattern); boyer_moore(\u0026amp;dna, \u0026amp;pattern); } fn random_dna(length: usize) -\u0026gt; Vec\u0026lt;char\u0026gt; { let nucleotides = [\u0026#39;A\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;G\u0026#39;]; // DNA碱基 let mut rng = rand::thread_rng(); // 创建随机数生成器 // 随机生成指定长度的DNA序列 let sequence: String = (0..length) .map(|_| nucleotides[rng.gen_range(0..4)]) // 随机选择ATCG中的一个 .collect(); sequence.chars().collect() } fn boyer_moore(text: \u0026amp;Vec\u0026lt;char\u0026gt;, pattern: \u0026amp;Vec\u0026lt;char\u0026gt;) { // 坏字符规则：生成坏字符表 let bad_str = |pattern: \u0026amp;Vec\u0026lt;char\u0026gt;, qwq: \u0026amp;mut Vec\u0026lt;i32\u0026gt;| { qwq.iter_mut().for_each(|x| *x = -1); let m = pattern.len(); for i in 0..m { qwq[pattern[i] as usize] = i as i32; } }; // 好后缀规则 let good_suffix = |pattern: \u0026amp;Vec\u0026lt;char\u0026gt;,qwq:\u0026amp;mut Vec\u0026lt;i32\u0026gt;|{ } let n = text.len(); let m = pattern.len(); if m == 0 { println!(\u0026#34;模式串为空，返回0\u0026#34;); return; } // 坏字符表（ASCII字符集大小256） let mut bad_char = vec![-1; 256]; bad_str(\u0026amp;pattern, \u0026amp;mut bad_char); // 开始匹配 let mut i = 0; while i \u0026lt;= n - m { let mut j = m - 1; let mut check = false; //从末位开始判断 while pattern[j] == text[i + j] { if j == 0 { check = true; break; } j -= 1; } if check { println!(\u0026#34;成功匹配，索引位于{}\u0026#34;, i + 1); i += if i + m \u0026lt; n { (m as i32 - bad_char[text[i + m] as usize]) as usize } else { 1 }; } else { i += 1.max(j as i32 - bad_char[text[i + j] as usize]) as usize; } } } ","date":"2024-10-12T00:00:00Z","permalink":"https://allergy27.github.io/p/boyer-moore-algorithm/","title":"bm算法介绍"}]