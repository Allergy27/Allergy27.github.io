[{"content":"CodeForces Round 988 Div3 A-E 题解 比赛链接：https://codeforces.com/contest/2037\n题目类型 A：签到-哈希表 B：签到-哈希集合 C：思维-构造 D：优先队列 E：交互-观察\n说明 写给自己看的，全文Rust代码，善用GPT翻译 D做差了，E赛时没敲上 还是D题没发挥好导致的，节奏断了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 数组模拟哈希表即可\n做法:\n数组模拟哈希表，每个值$/2$后加入答案 点击展开代码\r1 2 3 4 5 6 7 8 9 10 fn solve() { let n = cin!(usize); let qwq = cin!([usize; n]); let mut qaq = vec![0; n + 1]; for i in 0..n { qaq[qwq[i]] += 1; } let ans = qaq.into_iter().map(|x| x / 2).sum::\u0026lt;usize\u0026gt;(); println!(\u0026#34;{ans}\u0026#34;) } B 哈希集合\n做法:\n类似Leetcode两数之和问题，一次遍历 每次没能找到相乘为目标值的放入集合 能找到就输出 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize) - 2; let qwq = cin!([usize; n + 2]); let mut qaq = std::collections::HashSet::new(); for i in \u0026amp;qwq { if n % i == 0 \u0026amp;\u0026amp; qaq.contains(\u0026amp;(n / *i)) { println!(\u0026#34;{} {}\u0026#34;, i, n / i); return; } qaq.insert(i); } } C 构造\n做法:\n偶数一定合数，构造偶数即可 奇偶分组，找最小的满足奇偶相加为合数的数 发现是 4 5 构造即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn solve() { let n = cin!(usize); if n \u0026lt; 5 { println!(\u0026#34;-1\u0026#34;); } else { for i in 1..=n { if i != 5 \u0026amp;\u0026amp; i % 2 == 1 { print!(\u0026#34;{} \u0026#34;, i); } } print!(\u0026#34;5 4 \u0026#34;); for i in 1..=n { if i != 4 \u0026amp;\u0026amp; i % 2 == 0 { print!(\u0026#34;{} \u0026#34;, i); } } println!() } } D 事件合并后放入优先队列\n做法:\n先合并事件，按坐标从小到大排序 增益记作 0 事件，障碍记作 1 事件 每次需要跨障碍从队列中取出最大的 若空则 -1 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 fn solve() { let (l, m, n) = cin!(usize, usize, usize); let mut qwq = Vec::with_capacity(l); for _ in 0..l { qwq.push(cin!(usize, usize)); } let mut qaq = Vec::with_capacity(m); for _ in 0..m { qaq.push(cin!(usize, usize)); } // 合并事件: 增益 障碍 结束 终点 let mut events = Vec::new(); for \u0026amp;(l, r) in \u0026amp;qwq { events.push((l, 1, r - l + 1)); } for \u0026amp;(x, v) in \u0026amp;qaq { events.push((x, 0, v)); } events.push((n, 2, 0)); // 终点 events.sort_unstable_by(|a, b| a.0.cmp(\u0026amp;b.0)); let mut k = 1; let mut heap = std::collections::BinaryHeap::new(); let mut ans = 0; for (_, t, v) in events { if t == 0 { heap.push(v); } else if t == 1 { while k \u0026lt;= v { if let Some(top) = heap.pop() { k += top; ans += 1; } else { println!(\u0026#34;-1\u0026#34;); return; } } } else { println!(\u0026#34;{ans}\u0026#34;); } } } E 交互题\n反思:\n依然是漏判情况导致出锅\n做法:\n先找第一个满足不为0的，找不到就输出 -1 再看这个值是多少，往前面填111100这样 接着后面的值更大说明是 1 相等说明是 0 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn solve() { let n = cin!(usize); let query = |l: usize, r: usize| { println!(\u0026#34;? {} {}\u0026#34;, l + 1, r + 1); std::io::Write::flush(\u0026amp;mut std::io::stdout()).unwrap(); cin!(i64) }; let mut qwq = Vec::new(); let mut zro = -1; for i in 1..n { let x = query(0, i); if zro == -1 { if x != 0 { qwq.resize((i as i64 - x) as usize, 1); qwq.resize(i, 0); zro = x; qwq.push(1); } } else if x == zro { qwq.push(0); } else { zro = x; qwq.push(1); } } if zro != -1 { print!(\u0026#34;! \u0026#34;); qwq.iter().for_each(|\u0026amp;x| print!(\u0026#34;{}\u0026#34;, x)); println!() } else { println!(\u0026#34;! IMPOSSIBLE\u0026#34;) } } ","date":"2024-11-17T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_988_div3/","title":"CodeForces_988_div3"},{"content":"CodeForces Round 988 Div3 A-E 题解 比赛链接：https://codeforces.com/contest/2037\n题目类型 A：签到-哈希表 B：签到-哈希集合 C：思维-构造 D：优先队列 E：交互-观察\n说明 写给自己看的，全文Rust代码，善用GPT翻译 D做差了，E赛时没敲上 还是D题没发挥好导致的，节奏断了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 数组模拟哈希表即可\n做法:\n数组模拟哈希表，每个值$/2$后加入答案 点击展开代码\r1 2 3 4 5 6 7 8 9 10 fn solve() { let n = cin!(usize); let qwq = cin!([usize; n]); let mut qaq = vec![0; n + 1]; for i in 0..n { qaq[qwq[i]] += 1; } let ans = qaq.into_iter().map(|x| x / 2).sum::\u0026lt;usize\u0026gt;(); println!(\u0026#34;{ans}\u0026#34;) } B 哈希集合\n做法:\n类似Leetcode两数之和问题，一次遍历 每次没能找到相乘为目标值的放入集合 能找到就输出 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize) - 2; let qwq = cin!([usize; n + 2]); let mut qaq = std::collections::HashSet::new(); for i in \u0026amp;qwq { if n % i == 0 \u0026amp;\u0026amp; qaq.contains(\u0026amp;(n / *i)) { println!(\u0026#34;{} {}\u0026#34;, i, n / i); return; } qaq.insert(i); } } C 构造\n做法:\n偶数一定合数，构造偶数即可 奇偶分组，找最小的满足奇偶相加为合数的数 发现是 4 5 构造即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn solve() { let n = cin!(usize); if n \u0026lt; 5 { println!(\u0026#34;-1\u0026#34;); } else { for i in 1..=n { if i != 5 \u0026amp;\u0026amp; i % 2 == 1 { print!(\u0026#34;{} \u0026#34;, i); } } print!(\u0026#34;5 4 \u0026#34;); for i in 1..=n { if i != 4 \u0026amp;\u0026amp; i % 2 == 0 { print!(\u0026#34;{} \u0026#34;, i); } } println!() } } D 事件合并后放入优先队列\n做法:\n先合并事件，按坐标从小到大排序 增益记作 0 事件，障碍记作 1 事件 每次需要跨障碍从队列中取出最大的 若空则 -1 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 fn solve() { let (l, m, n) = cin!(usize, usize, usize); let mut qwq = Vec::with_capacity(l); for _ in 0..l { qwq.push(cin!(usize, usize)); } let mut qaq = Vec::with_capacity(m); for _ in 0..m { qaq.push(cin!(usize, usize)); } // 合并事件: 增益 障碍 结束 终点 let mut events = Vec::new(); for \u0026amp;(l, r) in \u0026amp;qwq { events.push((l, 1, r - l + 1)); } for \u0026amp;(x, v) in \u0026amp;qaq { events.push((x, 0, v)); } events.push((n, 2, 0)); // 终点 events.sort_unstable_by(|a, b| a.0.cmp(\u0026amp;b.0)); let mut k = 1; let mut heap = std::collections::BinaryHeap::new(); let mut ans = 0; for (_, t, v) in events { if t == 0 { heap.push(v); } else if t == 1 { while k \u0026lt;= v { if let Some(top) = heap.pop() { k += top; ans += 1; } else { println!(\u0026#34;-1\u0026#34;); return; } } } else { println!(\u0026#34;{ans}\u0026#34;); } } } E 交互题\n反思:\n依然是漏判情况导致出锅\n做法:\n先找第一个满足不为0的，找不到就输出 -1 再看这个值是多少，往前面填111100这样 接着后面的值更大说明是 1 相等说明是 0 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn solve() { let n = cin!(usize); let query = |l: usize, r: usize| { println!(\u0026#34;? {} {}\u0026#34;, l + 1, r + 1); std::io::Write::flush(\u0026amp;mut std::io::stdout()).unwrap(); cin!(i64) }; let mut qwq = Vec::new(); let mut zro = -1; for i in 1..n { let x = query(0, i); if zro == -1 { if x != 0 { qwq.resize((i as i64 - x) as usize, 1); qwq.resize(i, 0); zro = x; qwq.push(1); } } else if x == zro { qwq.push(0); } else { zro = x; qwq.push(1); } } if zro != -1 { print!(\u0026#34;! \u0026#34;); qwq.iter().for_each(|\u0026amp;x| print!(\u0026#34;{}\u0026#34;, x)); println!() } else { println!(\u0026#34;! IMPOSSIBLE\u0026#34;) } } ","date":"2024-11-17T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_988_div3/","title":"CodeForces_988_div3"},{"content":"CodeForces Round 988 Div3 A-E 题解 比赛链接：https://codeforces.com/contest/2037\n题目类型 A：签到-哈希表 B：签到-哈希集合 C：思维-构造 D：优先队列 E：交互-观察\n说明 写给自己看的，全文Rust代码，善用GPT翻译 D做差了，E赛时没敲上 还是D题没发挥好导致的，节奏断了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 数组模拟哈希表即可\n做法:\n数组模拟哈希表，每个值$/2$后加入答案 点击展开代码\r1 2 3 4 5 6 7 8 9 10 fn solve() { let n = cin!(usize); let qwq = cin!([usize; n]); let mut qaq = vec![0; n + 1]; for i in 0..n { qaq[qwq[i]] += 1; } let ans = qaq.into_iter().map(|x| x / 2).sum::\u0026lt;usize\u0026gt;(); println!(\u0026#34;{ans}\u0026#34;) } B 哈希集合\n做法:\n类似Leetcode两数之和问题，一次遍历 每次没能找到相乘为目标值的放入集合 能找到就输出 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize) - 2; let qwq = cin!([usize; n + 2]); let mut qaq = std::collections::HashSet::new(); for i in \u0026amp;qwq { if n % i == 0 \u0026amp;\u0026amp; qaq.contains(\u0026amp;(n / *i)) { println!(\u0026#34;{} {}\u0026#34;, i, n / i); return; } qaq.insert(i); } } C 构造\n做法:\n偶数一定合数，构造偶数即可 奇偶分组，找最小的满足奇偶相加为合数的数 发现是 4 5 构造即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn solve() { let n = cin!(usize); if n \u0026lt; 5 { println!(\u0026#34;-1\u0026#34;); } else { for i in 1..=n { if i != 5 \u0026amp;\u0026amp; i % 2 == 1 { print!(\u0026#34;{} \u0026#34;, i); } } print!(\u0026#34;5 4 \u0026#34;); for i in 1..=n { if i != 4 \u0026amp;\u0026amp; i % 2 == 0 { print!(\u0026#34;{} \u0026#34;, i); } } println!() } } D 事件合并后放入优先队列\n做法:\n先合并事件，按坐标从小到大排序 增益记作 0 事件，障碍记作 1 事件 每次需要跨障碍从队列中取出最大的 若空则 -1 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 fn solve() { let (l, m, n) = cin!(usize, usize, usize); let mut qwq = Vec::with_capacity(l); for _ in 0..l { qwq.push(cin!(usize, usize)); } let mut qaq = Vec::with_capacity(m); for _ in 0..m { qaq.push(cin!(usize, usize)); } // 合并事件: 增益 障碍 结束 终点 let mut events = Vec::new(); for \u0026amp;(l, r) in \u0026amp;qwq { events.push((l, 1, r - l + 1)); } for \u0026amp;(x, v) in \u0026amp;qaq { events.push((x, 0, v)); } events.push((n, 2, 0)); // 终点 events.sort_unstable_by(|a, b| a.0.cmp(\u0026amp;b.0)); let mut k = 1; let mut heap = std::collections::BinaryHeap::new(); let mut ans = 0; for (_, t, v) in events { if t == 0 { heap.push(v); } else if t == 1 { while k \u0026lt;= v { if let Some(top) = heap.pop() { k += top; ans += 1; } else { println!(\u0026#34;-1\u0026#34;); return; } } } else { println!(\u0026#34;{ans}\u0026#34;); } } } E 交互题\n反思:\n依然是漏判情况导致出锅\n做法:\n先找第一个满足不为0的，找不到就输出 -1 再看这个值是多少，往前面填111100这样 接着后面的值更大说明是 1 相等说明是 0 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn solve() { let n = cin!(usize); let query = |l: usize, r: usize| { println!(\u0026#34;? {} {}\u0026#34;, l + 1, r + 1); std::io::Write::flush(\u0026amp;mut std::io::stdout()).unwrap(); cin!(i64) }; let mut qwq = Vec::new(); let mut zro = -1; for i in 1..n { let x = query(0, i); if zro == -1 { if x != 0 { qwq.resize((i as i64 - x) as usize, 1); qwq.resize(i, 0); zro = x; qwq.push(1); } } else if x == zro { qwq.push(0); } else { zro = x; qwq.push(1); } } if zro != -1 { print!(\u0026#34;! \u0026#34;); qwq.iter().for_each(|\u0026amp;x| print!(\u0026#34;{}\u0026#34;, x)); println!() } else { println!(\u0026#34;! IMPOSSIBLE\u0026#34;) } } ","date":"2024-11-17T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_988_div3/","title":"CodeForces_988_div3"},{"content":"CodeForces Round 988 Div3 A-E 题解 比赛链接：https://codeforces.com/contest/2037\n题目类型 A：签到-哈希表 B：签到-哈希集合 C：思维-构造 D：优先队列 E：交互-观察\n说明 写给自己看的，全文Rust代码，善用GPT翻译 D做差了，E赛时没敲上 还是D题没发挥好导致的，节奏断了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 数组模拟哈希表即可\n做法:\n数组模拟哈希表，每个值$/2$后加入答案 点击展开代码\r1 2 3 4 5 6 7 8 9 10 fn solve() { let n = cin!(usize); let qwq = cin!([usize; n]); let mut qaq = vec![0; n + 1]; for i in 0..n { qaq[qwq[i]] += 1; } let ans = qaq.into_iter().map(|x| x / 2).sum::\u0026lt;usize\u0026gt;(); println!(\u0026#34;{ans}\u0026#34;) } B 哈希集合\n做法:\n类似Leetcode两数之和问题，一次遍历 每次没能找到相乘为目标值的放入集合 能找到就输出 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize) - 2; let qwq = cin!([usize; n + 2]); let mut qaq = std::collections::HashSet::new(); for i in \u0026amp;qwq { if n % i == 0 \u0026amp;\u0026amp; qaq.contains(\u0026amp;(n / *i)) { println!(\u0026#34;{} {}\u0026#34;, i, n / i); return; } qaq.insert(i); } } C 构造\n做法:\n偶数一定合数，构造偶数即可 奇偶分组，找最小的满足奇偶相加为合数的数 发现是 4 5 构造即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn solve() { let n = cin!(usize); if n \u0026lt; 5 { println!(\u0026#34;-1\u0026#34;); } else { for i in 1..=n { if i != 5 \u0026amp;\u0026amp; i % 2 == 1 { print!(\u0026#34;{} \u0026#34;, i); } } print!(\u0026#34;5 4 \u0026#34;); for i in 1..=n { if i != 4 \u0026amp;\u0026amp; i % 2 == 0 { print!(\u0026#34;{} \u0026#34;, i); } } println!() } } D 事件合并后放入优先队列\n做法:\n先合并事件，按坐标从小到大排序 增益记作 0 事件，障碍记作 1 事件 每次需要跨障碍从队列中取出最大的 若空则 -1 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 fn solve() { let (l, m, n) = cin!(usize, usize, usize); let mut qwq = Vec::with_capacity(l); for _ in 0..l { qwq.push(cin!(usize, usize)); } let mut qaq = Vec::with_capacity(m); for _ in 0..m { qaq.push(cin!(usize, usize)); } // 合并事件: 增益 障碍 结束 终点 let mut events = Vec::new(); for \u0026amp;(l, r) in \u0026amp;qwq { events.push((l, 1, r - l + 1)); } for \u0026amp;(x, v) in \u0026amp;qaq { events.push((x, 0, v)); } events.push((n, 2, 0)); // 终点 events.sort_unstable_by(|a, b| a.0.cmp(\u0026amp;b.0)); let mut k = 1; let mut heap = std::collections::BinaryHeap::new(); let mut ans = 0; for (_, t, v) in events { if t == 0 { heap.push(v); } else if t == 1 { while k \u0026lt;= v { if let Some(top) = heap.pop() { k += top; ans += 1; } else { println!(\u0026#34;-1\u0026#34;); return; } } } else { println!(\u0026#34;{ans}\u0026#34;); } } } E 交互题\n反思:\n依然是漏判情况导致出锅\n做法:\n先找第一个满足不为0的，找不到就输出 -1 再看这个值是多少，往前面填111100这样 接着后面的值更大说明是 1 相等说明是 0 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn solve() { let n = cin!(usize); let query = |l: usize, r: usize| { println!(\u0026#34;? {} {}\u0026#34;, l + 1, r + 1); std::io::Write::flush(\u0026amp;mut std::io::stdout()).unwrap(); cin!(i64) }; let mut qwq = Vec::new(); let mut zro = -1; for i in 1..n { let x = query(0, i); if zro == -1 { if x != 0 { qwq.resize((i as i64 - x) as usize, 1); qwq.resize(i, 0); zro = x; qwq.push(1); } } else if x == zro { qwq.push(0); } else { zro = x; qwq.push(1); } } if zro != -1 { print!(\u0026#34;! \u0026#34;); qwq.iter().for_each(|\u0026amp;x| print!(\u0026#34;{}\u0026#34;, x)); println!() } else { println!(\u0026#34;! IMPOSSIBLE\u0026#34;) } } ","date":"2024-11-17T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_988_div3/","title":"CodeForces_988_div3"},{"content":"CodeForces Round 987 Div2 A-D 题解 比赛链接：https://codeforces.com/contest/2031\n题目类型 A：签到-LIS B：签到-思维 C：思维-构造 D：前后缀分解\n说明 写给自己看的，全文Rust代码，善用GPT翻译 发挥不够好，还是昏昏沉沉的，会的太少了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题-LIS\n反思:\n赛时看出是单调栈，没看出最长递增子序列难绷 签到没签上，意难平 做法:\n最长不下降子序列，有提前写好的二分+单调栈板子 找出最长不下降子序列长度，把其他部分变得和这个序列一样即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fn solve() { let n = cin!(usize); println!(\u0026#34;{}\u0026#34;, n - lis(cin!([usize; n])).len()); } fn lis\u0026lt;T: Ord + Copy\u0026gt;(nums: Vec\u0026lt;T\u0026gt;) -\u0026gt; Vec\u0026lt;T\u0026gt; { nums.iter().fold(vec![], |mut x, \u0026amp;y| { if x.is_empty() || *x.last().unwrap() \u0026lt;= y { x.push(y) } else { let i = x.partition_point(|\u0026amp;v| v \u0026lt;= y); x[i] = y; } x }) } B 签到-思维\n做法:\n索引和值相差超过1肯定就不行 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize); let p = cin!([i32; n]); let mut flag = \u0026#34;YES\u0026#34;; for (i, elem) in p.iter().enumerate() { if elem.abs_diff(i as i32 + 1) \u0026gt; 1 { flag = \u0026#34;NO\u0026#34;; break; } } println!(\u0026#34;{flag}\u0026#34;); } C 思维-构造\n做法:\n偶数只要一直1 1 2 2 ..即可 考虑最小的奇数情况： 找到三个数a b c，满足a*a+b*b=c*c即可 不难发现最小的时候即3 4 5，对应完全平方数9 16 25 但25时，一共26个数，为偶数，不满足条件，需要到27 我们构造1 2 2 .. 5 5 1 6 6 .. 11 11 12 13 13 1 12 即可 此时即为最小的满足条件的奇数情况 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn solve() { let n = cin!(usize); if n % 2 == 0 { for i in 0..n / 2 { print!(\u0026#34;{} {} \u0026#34;, i + 1, i + 1); } println!() } else if n \u0026lt; 27 { println!(\u0026#34;-1\u0026#34;); } else { print!(\u0026#34;1 2 2 3 3 4 4 5 5 1 6 6 7 7 8 8 9 9 10 10 11 11 12 13 13 1 12 \u0026#34;); for i in 14..=n / 2 { print!(\u0026#34;{} {} \u0026#34;, i, i); } println!() } } D 前后缀分解+前缀和\n做法:\n从前往后维护向前跳最高为多少 从后往前维护向后跳最矮为多少 接着进行一次遍历 每当遇到最小值，将前面的值全部初始化为最小值的向前跳最大值 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 fn solve() { let n = cin!(usize); let qwq = cin!([i32; n]); let mut pre = vec![-1; n + 1]; for i in 0..n { pre[i + 1] = pre[i].max(qwq[i]) } let mut suf = vec![n as i32 + 1; n + 1]; for i in (0..n).rev() { suf[i] = suf[i + 1].min(qwq[i]) } let mut ans = vec![-1; n]; let mut last = 0; for i in 1..=n { //往右找不到更小值，说明当前值最小 if pre[i] \u0026lt;= suf[i] { for elem in ans.iter_mut().take(i).skip(last) { *elem = pre[i]; } last = i; } } ans.iter().for_each(|x| print!(\u0026#34;{x} \u0026#34;)); println!() } ","date":"2024-11-15T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_987_div2/","title":"CodeForces_987_div2"},{"content":"Day 1. Number Theory 主要讲素数相关的一些内容\nLesson 课程内容部分\n分段筛法 Problem:\n题目大意：求区间 [L,R] 中的素数，$[L,R]$ 范围在 $10^{12}$ 左右，$R-L \\leq 10^{6}$\nSolution:\n分段筛法：\n先用线性筛筛出$[2,\\sqrt{R}]$区间内的素数\n再找到左右区间，区间内每个点检验是否是筛出的小区间的素数的倍数 左端点向上取整，右端点向下取整，避免超出索引\n莫比乌斯函数 核心思想：包含-排除思想，在容斥原理中有深刻应用\n算法核心:\n$\\mu(1) = 1$\n$\\mu(n) = (-1)^k$ n为k个质数的乘积\n$\\mu(n) = 0$ n含平方因子\n另外，稍微改改就变成欧拉函数了\nProblem:\n截图\n题目大意：\nSolution:\n莫比乌斯函数\nBurnside\u0026rsquo;s 引理 Problem:\n截图\n题目大意：\nSolution:\n-todo-\nPolya定理 Problem:\n截图\n题目大意：\nSolution:\n-todo-\nMiller-Robin 素性测试 Problem:\n截图\n题目大意：\nSolution:\n-todo-\nPollard-Rho 算法 Problem:\n截图\n题目大意：\nSolution:\n-todo-\nDay 2. FFT and FWHT 主要讲FFT相关的一些内容\nLesson 代办\n","date":"2024-11-15T00:00:00Z","permalink":"https://allergy27.github.io/p/camp_learning/","title":"训练营"},{"content":"CodeForces Round 986 Div2 A-C 题解 比赛链接：https://codeforces.com/contest/2028\n题目类型 A：签到-模拟 B：模拟、数学 C：前后缀分解、前缀和\n说明 写给自己看的，全文Rust代码，善用GPT翻译 发挥不够好，还是昏昏沉沉的，会的太少了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题-模拟\n做法:\n题目数据量小，考虑模拟，假设重复足够次数，然后看看会不会碰上即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 fn solve() { let (_, a, b) = cin!(usize, i64, i64); let s = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let mut tmp = (0, 0); for _ in 0..1000 { // 假设最多重复1000次 for i in \u0026amp;s { match i { \u0026#39;N\u0026#39; =\u0026gt; { tmp.1 += 1; } \u0026#39;E\u0026#39; =\u0026gt; { tmp.0 += 1; } \u0026#39;S\u0026#39; =\u0026gt; { tmp.1 -= 1; } \u0026#39;W\u0026#39; =\u0026gt; { tmp.0 -= 1; } _ =\u0026gt; unreachable!(), } if tmp == (a, b) { println!(\u0026#34;YES\u0026#34;); return; } } } println!(\u0026#34;NO\u0026#34;); } B 模拟+数学\n反思:\n赛时完全没想到怎么举特例，疯魔了 状态不是很好，什么都做不上 还在打草稿的时候把x-1写成x伏笔了 做法:\n先举特例，b=0: c\u0026gt;=n 答案即 n-2 c\u0026gt;=n-2 答案即 n-1 剩余情况无解，输出-1 以及 c\u0026gt;=n ,输出n 剩下为一般情况，需要在区间内找最大的x，使得b(x-1)+c在区间内 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn solve() { let (n, b, c) = cin!(i64, i64, i64); if b == 0 { if c \u0026gt;= n { println!(\u0026#34;{}\u0026#34;, n - 2); } else if c \u0026gt;= n - 2 { println!(\u0026#34;{}\u0026#34;, n - 1); } else { println!(\u0026#34;-1\u0026#34;); } } else if c \u0026gt;= n { println!(\u0026#34;{}\u0026#34;, n); } else { println!(\u0026#34;{}\u0026#34;, n - 0.max(1 + (n - c - 1) / b)); } } C 前后缀分解+前缀和\n做法:\n因为切成m+1份是固定的，所以枚举从前往后切i个的右端点，以及从右往左切i个的左端点，左右端点之间的值就是能拿到的蛋糕值 前缀和维护区间和，复杂度O(n) 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 fn solve() { let (n, m, v) = cin!(usize, usize, usize); let qwq = cin!([usize; n]); let mut qaq = vec![0; n + 1]; for i in 0..n { qaq[i + 1] = qaq[i] + qwq[i]; } let query = |l: usize, r: usize| qaq[r] - qaq[l]; // 从前往后切，第m的右端点（开 let mut f = vec![0; m + 1]; let mut tmp = 0; for i in 1..=m { while tmp as usize \u0026lt;= n \u0026amp;\u0026amp; query(f[i - 1] as usize, tmp as usize) \u0026lt; v { tmp += 1; } f[i] = tmp; } // 从后往前切，第m的左端点（闭 let mut g = vec![n as i32; m + 1]; tmp = n as i32; for i in 1..=m { while tmp \u0026gt;= 0 \u0026amp;\u0026amp; query(tmp as usize, g[i - 1] as usize) \u0026lt; v { tmp -= 1; } g[i] = tmp; } let mut ans = -1; for i in 0..=m { // 符合条件的区间计算能获得的蛋糕 if f[i] \u0026lt;= n as i32 \u0026amp;\u0026amp; g[m - i] \u0026gt;= 0 \u0026amp;\u0026amp; f[i] \u0026lt;= g[m - i] { ans = ans.max(query(f[i] as usize, g[m - i] as usize) as i32) } } println!(\u0026#34;{ans}\u0026#34;); } ","date":"2024-11-11T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_986_div2/","title":"CodeForces_986_div2"},{"content":"CodeForces Round 985 Div1+Div2 A-E 题解 比赛链接：https://codeforces.com/contest/2029\n题目类型 A：签到-二分 B：博弈论 C：动态规划 D：构造 E：构造\n说明 写给自己看的，全文Rust代码，善用GPT翻译 发挥不够好，还是昏昏沉沉的，会的太少了 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题-二分/数学\n做法:\n二分查找/数学 找第一个满足k倍\u0026gt;r的数是什么数即可，向下取整 超出的部分肯定是不能删的 二分容错率高，数学想到就好写 二分\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fn solve() { let (l, r, k) = cin!(i64, i64, i64); if k == 1 { println!(\u0026#34;{}\u0026#34;, r - l + 1); return; } let mut a = l; let mut b = r; while a \u0026lt; b { let mid = (a + b) / 2; if mid * k \u0026gt; r { b = mid; } else { a = mid + 1; } } println!(\u0026#34;{}\u0026#34;, a - l); } 数学\r1 2 3 4 fn solve() { let (l, r, k) = cin!(i64, i64, i64); println!(\u0026#34;{}\u0026#34;, ((r / k) - l + 1).max(0)) } B 博弈论\n反思:\n赛时代码太丑陋了 而且基本逻辑也没理清 浪费了好多时间 做法:\n注意到，0/1合并后为1/0，而只要还有另一种数字就可以合并 预处理出个数，跑一遍操作字符串，如果0/1不够说明跑不了 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn solve() { let n = cin!(usize); let a = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let b = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let mut cot = [0, 0]; for i in a { cot[(i as u8 - b\u0026#39;0\u0026#39;) as usize] += 1; } for i in b { let tmp = (i as u8 - b\u0026#39;0\u0026#39;) as usize; if cot[tmp] \u0026gt; 0 \u0026amp;\u0026amp; cot[tmp ^ 1] \u0026gt; 0 { cot[tmp ^ 1] -= 1; } else { println!(\u0026#34;NO\u0026#34;); return; } } println!(\u0026#34;YES\u0026#34;); } 丑陋的赛时代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 fn solve() { let _ = cin!(i64); let a = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let b = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let mut one = 0; let mut zero = 0; for i in a { if i == \u0026#39;0\u0026#39; { one += 1; } else { zero += 1; } } if zero == 0 || one == 0 { println!(\u0026#34;NO\u0026#34;); return; } for i in b { if i == \u0026#39;1\u0026#39; { if one == 0 || zero == 0 { println!(\u0026#34;NO\u0026#34;); return; } one -= 1; } else { if one == 0 || zero == 0 { println!(\u0026#34;NO\u0026#34;); return; } zero -= 1; } } println!(\u0026#34;YES\u0026#34;); } C dp\n做法:\n有最优子结构特征(某个区间跳过与不跳过)可以dp 每次维护未跳过、正跳过、已跳过 未跳过直接转移，正跳过更新为未跳过最大值，已跳过由正跳过和已跳过最大值转移 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(i64); let qwq = cin!([i64; n]); let (mut pre, mut skip, mut aft) = (0, -n, -n); let ck = |x: i64, y: i64| x + (y \u0026gt; x) as i64 - (x \u0026gt; y) as i64; for \u0026amp;x in \u0026amp;qwq { aft = ck(skip, x).max(ck(aft, x)); skip = skip.max(pre); pre = ck(pre, x); } println!(\u0026#34;{}\u0026#34;, aft.max(skip)); } D 构造\n做法:\n有多条边的直接删,每次操作都会使入度减一，所以最多m次可分为单独的点和边 将任取的一条边作为起点，若取不出则已经cool 将剩下的点和边加入这条边，最多n次 总计 n+m 左右，一定小于2*max(n,m) 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn solve() { let (n, m) = cin!(usize, usize); let mut qwq = vec![std::collections::HashSet::new(); n + 1]; for _ in 0..m { let (u, v) = cin!(usize, usize); qwq[u].insert(v); qwq[v].insert(u); } //记录操作 let mut ans = Vec::new(); for i in 1..=n { while qwq[i].len() \u0026gt;= 2 { let u = *qwq[i].iter().next().unwrap(); qwq[i].remove(\u0026amp;u); let v = *qwq[i].iter().next().unwrap(); qwq[i].remove(\u0026amp;v); qwq[u].remove(\u0026amp;i); qwq[v].remove(\u0026amp;i); ans.push((i, u, v)); if qwq[u].contains(\u0026amp;v) { qwq[u].remove(\u0026amp;v); qwq[v].remove(\u0026amp;u); } else { qwq[u].insert(v); qwq[v].insert(u); } } } //空组件 let mut zro = Vec::new(); //一条边组件 let mut one = Vec::new(); for (i, elem) in qwq.iter().enumerate().skip(1) { if elem.is_empty() { zro.push(i); } else if *elem.iter().next().unwrap() \u0026gt; i { one.push((i, *elem.iter().next().unwrap())); } } if !one.is_empty() { // println!(\u0026#34;{:?}\u0026#34;, one); let (u, mut v) = one.pop().unwrap(); for x in zro { ans.push((u, x, v)); v = x; } for (a, b) in one { ans.push((v, a, b)); } } println!(\u0026#34;{}\u0026#34;, ans.len()); ans.iter().for_each(|(a, b, c)| println!(\u0026#34;{} {} {}\u0026#34;, a, b, c)); } E 构造\n反思:\n没能注意到多个素数时一定没有答案\n做法:\n多个素数输出-1 有2用2 没2用其他的素数 说明：在主函数中预处理素数，减少不必要开销 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 fn main() { // let t = 1; let t = cin!(i64); const MAX_N: usize = 500_027; let mut pr = vec![0; MAX_N + 1]; let mut primes = Vec::new(); pr[1] = 1; for i in 2..=MAX_N { if pr[i] == 0 { primes.push(i); } for p in \u0026amp;primes { if p * i \u0026gt; MAX_N { break; } //维护最小公因子 pr[i * p] = *p; if i % p == 0 { break; } } } (0..t).for_each(|_| solve(\u0026amp;pr)); } fn solve(pr: \u0026amp;[usize]) { let n = cin!(usize); let qwq = cin!([usize; n]); let mut pf = 0; for i in \u0026amp;qwq { if pr[*i] == 0 { pf = *i; } } if pf == 0 { println!(\u0026#34;2\u0026#34;); } else { for i in qwq { if i == pf { continue; } if pr[i] == 0 { println!(\u0026#34;-1\u0026#34;); return; } else if (i \u0026amp; 1) == 1 { if i - pr[i] \u0026lt; 2 * pf { println!(\u0026#34;-1\u0026#34;); return; } } else if i \u0026lt; 2 * pf { println!(\u0026#34;-1\u0026#34;); return; } } println!(\u0026#34;{}\u0026#34;, pf) } } ","date":"2024-11-10T00:00:00Z","permalink":"https://allergy27.github.io/p/cf_985_glb/","title":"CodeForces_985_refact.ai_match"},{"content":"CodeForces Round 984 Div3 A-F 题解 比赛链接：https://codeforces.com/contest/2036\n题目类型 A：签到-字符串 B：签到-哈希表 C：签到—字符串 D：签到-字符串 E: 二分练习题 F: 数学-XOR\n说明 写给自己看的，全文Rust代码，善用GPT翻译 vp于 2024/11/05 最后排位大概300左右，这把大概1500水平 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题\n做法:\n遍历途中看差是不是5或7即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 fn solve() { let n = cin!(usize); let arr = cin!([i64; n]); for i in 1..n { let diff = arr[i].abs_diff(arr[i - 1]); if diff != 5 \u0026amp;\u0026amp; diff != 7 { println!(\u0026#34;NO\u0026#34;); return; } } println!(\u0026#34;YES\u0026#34;) } B 签到题\n做法:\n哈希表存每个品牌的总和，排序||存最大堆后取出前n大的和即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn solve() { let mut st = std::collections::HashMap::new(); let (n, m) = cin!(usize, usize); for _ in 0..m { let (x, y) = cin!(u64, u64); if st.contains_key(\u0026amp;x) { st.insert(x, st.get(\u0026amp;x).unwrap() + y); } else { st.insert(x, y); } } let mut qwq = std::collections::BinaryHeap::from_iter(st.values().cloned()); let mut ans = 0; let mut cot = 0; while let Some(x) = qwq.pop() { if cot == n { break; } ans += x; cot += 1; } println!(\u0026#34;{}\u0026#34;, ans) } C 预处理后即可O(1)处理查询\n做法:\n预处理一遍一开始有多少1100 看每次更改是否减少1100的个数 个数等于零说明不存在了 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn solve() { let mut s = cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;(); let mut i = 3; let n = s.len(); let mut cot = 0; let check = |s: \u0026amp;Vec\u0026lt;char\u0026gt;, i: usize| -\u0026gt; bool { i - 3 \u0026gt; 0 \u0026amp;\u0026amp; i \u0026lt; n \u0026amp;\u0026amp; s[i - 3..=i] == [\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;] }; while i \u0026lt; n { if check(\u0026amp;s, i - 3) { cot += 1; } i += 1; } let m = cin!(usize); for _ in 0..m { let (a, b) = cin!(usize, char); let i = a - 1; let checkf = |s: \u0026amp;Vec\u0026lt;char\u0026gt;| (i - 3..i + 1).fold(true, |ans, i| ans \u0026amp; check(s, i)); if checkf(\u0026amp;s) { cot -= 1; } s[i] = b; if checkf(\u0026amp;s) { cot += 1; } println!(\u0026#34;{}\u0026#34;, if cot \u0026gt; 0 { \u0026#34;YES\u0026#34; } else { \u0026#34;NO\u0026#34; }); } } D 输入练习\n做法:\n对循环读入数据的练习 每个环顺时针接在一起 循环判断是否出现1543即可 写起来还挺麻烦的，题意倒是清晰 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 fn solve() { let (n, m) = cin!(usize, usize); let mut qwq = Vec::with_capacity(n); for _ in 0..n { qwq.push(cin!().chars().collect::\u0026lt;Vec\u0026lt;_\u0026gt;\u0026gt;()) } let mut res = Vec::new(); let round = n.min(m) / 2; for rd in 0..round { let mut tmp = Vec::new(); // 上边界 for j in rd..m - rd { tmp.push(qwq[rd][j]); } // 右边界 for row in qwq.iter().skip(rd + 1).take(n - 2 * rd - 1) { tmp.push(row[m - rd - 1]); } // 下边界 if n - rd - 1 \u0026gt; rd { for j in (rd..m - rd - 1).rev() { tmp.push(qwq[n - rd - 1][j]); } } // 左边界 if m - rd - 1 \u0026gt; rd { for i in (rd + 1..n - rd - 1).rev() { tmp.push(qwq[i][rd]); } } res.push(tmp); } let mut ans = 0; for tmp in res { let ln = tmp.len(); for i in 0..ln { if tmp[i] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; tmp[(i + 1) % ln] == \u0026#39;5\u0026#39; \u0026amp;\u0026amp; tmp[(i + 2) % ln] == \u0026#39;4\u0026#39; \u0026amp;\u0026amp; tmp[(i + 3) % ln] == \u0026#39;3\u0026#39; { ans += 1; } } } println!(\u0026#34;{}\u0026#34;, ans); } E 二分练习题\n反思:\n题目条件没注意到，每个地区是不递减的，一开始没看到也就没做出来\n做法:\n先遍历求连通水渠之后的数组 再二分查找一下即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn solve() { let (n, m, q) = cin!(usize, usize, i64); let mut qwq = Vec::with_capacity(n); for _ in 0..n { qwq.push(cin!([i64; m])); } for i in 1..n { for j in 0..m { qwq[i][j] |= qwq[i - 1][j] } } for _ in 0..q { let p = cin!(i64); let (mut l, mut r) = (0, n as i64); for _ in 0..p { let (t, o, c) = cin!(usize, char, i64); if o == \u0026#39;\u0026gt;\u0026#39; { l = l.max(qwq.partition_point(|x| x[t - 1] \u0026lt;= c) as i64); } else { r = r.min(qwq.partition_point(|x| x[t - 1] \u0026lt; c) as i64) } } if l \u0026gt;= r { println!(\u0026#34;-1\u0026#34;); } else { println!(\u0026#34;{}\u0026#34;, l + 1); } } } F 数学\n做法:\n异或和有结论 首先每4个数一轮循环，即： x%4==0 -\u0026gt; x x%4==1 -\u0026gt; 1 x%4==2 -\u0026gt; x+1 x%4==3 -\u0026gt; 0 接着是求出任意区间异或和： 只需xor(r)^xor(l-1)即可 这里的xor()指的是上述操作 接着我们需要取模$2^i$后余数为 $k$ 的数的异或和 显然，这些数低i位就是k 而高位只需将[l,r]右移后计算区间和即可 计算完左移回去，根据奇偶判断是否加k即或上k 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn solve() { let xor = |x: i64| match x % 4 { 0 =\u0026gt; x, 1 =\u0026gt; 1, 2 =\u0026gt; x + 1, 3 =\u0026gt; 0, _ =\u0026gt; unreachable!(), }; let find = |l: i64, r: i64| xor(r) ^ xor(if l \u0026gt; 0 { l - 1 } else { 0 }); let (l, r, i, k) = cin!(i64, i64, i64, i64); let qwq = find(l, r); let stt = (l - k + ((1 \u0026lt;\u0026lt; i) - 1)) \u0026gt;\u0026gt; i; let end = (r - k) \u0026gt;\u0026gt; i; if stt \u0026gt; end { println!(\u0026#34;{}\u0026#34;, qwq); return; } let n = end - stt + 1; let res = (find(stt, end) \u0026lt;\u0026lt; i) | if n % 2 == 1 { k } else { 0 }; println!(\u0026#34;{}\u0026#34;, qwq ^ res); } ","date":"2024-11-05T00:00:00Z","permalink":"https://allergy27.github.io/p/vp_cf_984_div3/","title":"CodeForces_984_div3"},{"content":"CodeForces Round 983 Div2 A-D 题解 比赛链接：https://codeforces.com/contest/2032\n题目类型 A：签到-思维题 B：签到-思维题 C：前缀和+二分 D：模拟交互题\n说明 写给自己看的，全文Rust代码，善用GPT翻译 C题作为小测补充了C++和python代码 vp于 2024/11/04 ，做前两题忘记开歌发挥有限 最后排位大概5000左右，这把大概1300水平 Rust模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #[macro_export] macro_rules! cin { ()=\u0026gt;{{ let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() }}; ([$type:ty;$n:expr]) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; let mut arr = Vec::with_capacity($n as usize); for _ in 0..$n { arr.push((s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap()); } arr }}; ($type:ty) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; (s.next().unwrap()).parse::\u0026lt;$type\u0026gt;().unwrap() }}; ($($type:ty),*) =\u0026gt; {{ let mut input = String::new(); let mut s = loop{ input.clear(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); let s = input.trim(); if !s.is_empty() { break s.split_whitespace(); } }; ($(s.next().unwrap().parse::\u0026lt;$type\u0026gt;().unwrap()),*) }} } fn main() { // let t = 1; let t = cin!(i64); (0..t).for_each(|_| solve()); } fn solve(){ } A 签到题\n做法:\n00和11对应关灯，01和10对应开灯 记录下0个数a和1个数b，a%2|b%2即为最小，a.min(b)即为最大 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 fn solve() { let n = cin!(usize); let v = cin!([i64; n * 2]); let (mut a, mut b) = (0, 0); for i in v { if i == 0 { a += 1; } else { b += 1; } } println!(\u0026#34;{} {}\u0026#34;, (a % 2) | (b % 2), a.min(b)) } B 求出前缀和数组后，数学运算即得\n反思:\n题意没理解正确多花了大量无意义的时间在上面\n做法:\n先判断是否在边界，即是否等于1或n，可以用异或逻辑处理 由于中位数左右两边区间个数一定相同，我们可以一直扩展到边界 多余的部分合并到边界区间内即可 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fn solve() { let (n, k) = cin!(usize, usize); if (k == 1) ^ (k == n) { println!(\u0026#34;-1\u0026#34;); } else { let rd = (n - k).min(k - 1); // 代表中位数左右区间长度 println!(\u0026#34;{}\u0026#34;, 2 * rd + 1); match (k - 1).cmp(\u0026amp;(n - k)) { std::cmp::Ordering::Equal =\u0026gt; { (1..=n).for_each(|x| print!(\u0026#34;{} \u0026#34;, x)); } std::cmp::Ordering::Greater =\u0026gt; { print!(\u0026#34;1 \u0026#34;); // 1合并到k-rd (k - rd + 1..=n).for_each(|x| print!(\u0026#34;{} \u0026#34;, x)); } std::cmp::Ordering::Less =\u0026gt; { (k - rd..=k + rd).for_each(|x| print!(\u0026#34;{} \u0026#34;, x)); } } println!() } } C 预处理出前缀和再二分判断即可\n旧教学\r做法:\n只要保证$A+B\u003eC$，就保证了可以构造出三角形 预处理出$A+B$和$C$进行比较即可 比较过程遍历C,二分查找第一个满足条件的三角形，减得区间长度就是答案所求 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn solve() { let n = cin!(usize); let mut qwq = cin!([i64; n]); qwq.sort_unstable(); let mut qaq = Vec::with_capacity(n - 1); for i in 1..n { qaq.push(qwq[i] + qwq[i - 1]); } let mut ans = i64::MAX; for i in (0..n).rev() { ans = ans.min((qaq.partition_point(|\u0026amp;x| x \u0026lt;= qwq[i]) + (n - i - 1)) as i64); } println!(\u0026#34;{}\u0026#34;, ans); } 二分做法\r我们需要让答案满足$A+B\u003eC$，所以可以预处理出$A+B$，接着枚举$C$，看$C$在$A+B$为多少时可以满足$A+B\u003eC$\n也可以枚举$A+B$，看$A+B$在$C$为多少时满足 答案即为总长-枚举出来的合理区间长\n代码部分\n二分C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void solve() {//Solution A int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; sort(qwq.begin(), qwq.end()); vector\u0026lt;int\u0026gt; qaq;//预处理A+B，枚举C for (int i = 1; i \u0026lt; n; ++i) qaq.push_back(qwq[i] + qwq[i - 1]); int ans = n - 2; for (int i = n - 1; i \u0026gt;= 0; --i) ans = min(ans, upper_bound(qaq.begin(), qaq.end(), qwq[i]) - qaq.begin() + n - 1 - i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } void solve() {//Solution B int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; sort(qwq.begin(), qwq.end()); int ans = n - 2; for (int i = 1; i \u0026lt; n; ++i) ans = min(ans,qwq.begin()- lower_bound(qwq.begin(), qwq.end(), qwq[i]+qwq[i-1]) + n - 1 + i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } 二分py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solve():#Solution A n = int(input()) qwq = list(map(int, input().split())) qwq.sort() qaq = [qwq[i] + qwq[i - 1] for i in range(1, n)] ans = n - 2 for i in range(n - 1, -1, -1): ans = min(ans, len([x for x in qaq if x \u0026lt;= qwq[i]]) + n - 1 - i) print(ans) def solve():#Solution B n = int(input()) qwq = list(map(int, input().split())) qwq.sort() ans = n - 2 for i in range(1, n): ans = min(ans, len([x for x in qwq if x \u0026gt;= qwq[i] + qwq[i - 1]]) + n - 1 + i) print(ans) 双指针做法\r我们设置两个变量模拟两个指针，一个指向0位置，一个指向2位置\n如果我们移动右指针，则越来越不满足条件\n如果移动左指针，则越来越满足条件\n我们一边移动一边更新区间最长的值MAX\n答案即为总长-MAX\n代码部分\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 void solve() int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; sort(qwq.begin(), qwq.end()); int l = 0; int ans = n - 2; for (int r = 2; r \u0026lt; n; ++r) { while (r - l \u0026gt;= 2 \u0026amp;\u0026amp; qwq[r] \u0026gt;= qwq[l] + qwq[l + 1]) ++l; ans = min(ans, n - r + l - 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; Py代码\r1 2 3 4 5 6 7 8 9 10 11 def solve(): n = int(input()) qwq = list(map(int, input().split())) qwq.sort() l = 0 ans = n - 2 for r in range(2, n): while r - l \u0026gt;= 2 and qwq[r] \u0026gt;= qwq[l] + qwq[l + 1]: l += 1 ans = min(ans, n - r + l - 1) print(ans) D 交互思维题\n做法:\n理解完题意我们知道只有根节点有多个孩子，其他节点只有一个孩子 又题目已知1节点一定与两个点相连 我们从1开始向n遍历判断谁是1的孩子 判断完孩子后我们接着判断每个点都接在哪个孩子下面 依次遍历叶子，如果叶子和当前节点查询得0，则说明当前节点的直接父亲为该叶子 题目保证了可以找到，所以直接找就可以 点击展开代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 fn solve() { let n = cin!(usize); let mut fa = vec![0; n]; let mut qwq = std::collections::BTreeSet::new(); let ask = |l: usize, r: usize| -\u0026gt; bool { println!(\u0026#34;? {} {}\u0026#34;, l, r); stdout().flush().unwrap(); cin!(i32) == 0 }; let mut f = true; for (i, elem) in fa.iter_mut().enumerate().skip(2) { if f { if ask(1, i) { *elem = 1; f = false; } } else { while let Some(x) = qwq.pop_first() { if ask(x, i) { *elem = x; break; } } } qwq.insert(i); } print!(\u0026#34;! \u0026#34;); for i in fa.into_iter().skip(1) { print!(\u0026#34;{} \u0026#34;, i); } println!(); } ","date":"2024-11-04T00:00:00Z","permalink":"https://allergy27.github.io/p/vp_cf_983_div2/","title":"CodeForces_983_div2"},{"content":"2024级新生前缀和考核题解 考核链接：https://vjudge.net/contest/668380\n题目类型 A：前缀和+二分 B：前缀和+数学 C：前缀和+字符串 D：前缀和+思维 E：前缀和嵌套\n说明 Python代码全是由C++版本用GPT转译而来，逻辑上没有问题但不保证是在python下的最优实现 未提供C代码，请善用GPT等工具或尽快掌握C++的基础语法 C++模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln \u0026#39;\\n\u0026#39; #define int int64_t using namespace std; // NOLINT using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; void solve() { } signed main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); cin \u0026gt;\u0026gt; t; return 0; } Py模板\r1 2 3 4 5 6 def solve(): if __name__ == \u0026#34;__main__\u0026#34;: n = int(input()) for i in range(n): solve() A 只需要排序后预处理出前缀和数组并二分查找即可\n做法:\n最小的两个货物数之和肯定是最小的，我们每次取最小的肯定是最理想的情况，而题目中顺序不影响答案，先排序方便之后二分查找。 预处理出前缀和数组，此时数组的值代表需要多少头鹿，索引加一代表能拉的货物数量，只需判断给定的鹿的数量在数组中的哪个位置即可，所以我们利用二分查找得到答案。 C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;i : qwq) cin \u0026gt;\u0026gt; i; sort(qwq.begin(), qwq.end()); // 排序O(nlogn) for (int i = 1; i \u0026lt; n; i++) qwq[i] += qwq[i - 1]; // 预处理出前缀和 for (int i = 0; i \u0026lt; m; i++) { int x; cin \u0026gt;\u0026gt; x; // 二分查询O(logn) 共m次 O(mlogn) cout \u0026lt;\u0026lt; upper_bound(qwq.begin(), qwq.end(), x) - qwq.begin() \u0026lt;\u0026lt; ln; } } Py代码\r1 2 3 4 5 6 7 8 9 10 11 import bisect def solve(): n, m = map(int, input().split()) qwq = list(map(int, input().split())) qwq.sort() # 排序O(nlogn) for i in range(1, n): qwq[i] += qwq[i - 1] # 预处理出前缀和 for _ in range(m): x = int(input()) # 二分查询O(logn) 共m次 O(mlogn) print(bisect.bisect_right(qwq, x)) B 求出前缀和数组后，数学运算即得\n做法:\n预处理出前缀和数组，此时数组的值代表0到索引位置的和为多少，而每隔数组长度个数的和都是不变的，和为qaq[n]，所以计算出有几段并顺序查找到哪位时和超过x即可 记得开long long (我的模板是直接将int定义成long long，所以不用再手动开long long) C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void solve() { int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; qaq(n + 1); for (int i = 0; i \u0026lt; n; ++i) qaq[i + 1] = qaq[i] + qwq[i]; cin \u0026gt;\u0026gt; m; int ans = m / qaq[n] * n; // 计算有几段，直接添加到答案中 m %= qaq[n]; // 剩下的部分的大小 // 这里我用的二分去找，实际O(n)的查询也能过 ans += upper_bound(qaq.begin(), qaq.end(), m) - qaq.begin(); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 import bisect def solve(): n = int(input()) qwq = list(map(int, input().split())) qaq = [0] * (n + 1) for i in range(n): qaq[i + 1] = qaq[i] + qwq[i] m = int(input()) ans = m // qaq[n] * n # 计算有几段，直接添加到答案中 m %= qaq[n] # 剩下的部分的大小 # 这里我用的二分去找，实际O(n)的查询也能过 ans += bisect.bisect_right(qaq, m) print(ans) C 前缀和+字符串计数\n做法:\n记录到每个索引前有多少个\u0026quot;AC\u0026quot;，即前缀和预处理即可 预处理时注意先检查\u0026quot;C\u0026quot;会比较方便 C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string s; cin \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; qaq(n); // 前缀和数组 int idx = 1; while (idx \u0026lt; n) { qaq[idx] = qaq[idx - 1]; // 遇到AC就往后跳两步 if (s[idx - 1] == \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s[idx] == \u0026#39;C\u0026#39;) ++qaq[idx]; idx++; } // 前缀和处理查询 while (m--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; qaq[r - 1] - qaq[l - 1] \u0026lt;\u0026lt; ln; } } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solve(): n, m = map(int, input().split()) s = input() qaq = [0] * n # 前缀和数组 idx = 1 while idx \u0026lt; n: qaq[idx] = qaq[idx - 1] # 遇到AC就往后跳两步 if s[idx - 1] == \u0026#39;A\u0026#39; and s[idx] == \u0026#39;C\u0026#39;: qaq[idx] += 1 idx += 1 # 前缀和处理查询 for _ in range(m): l, r = map(int, input().split()) print(qaq[r - 1] - qaq[l - 1]) D 前缀和+思维\n做法:\n题目不是简单的前缀和，需要动脑子转换一下 我们拿m = 2举例子，如下图： 1 2 3 4 4 3 4 2 3 4 1 2 3 4 一开始是1和22，接着我们要求2和33，那怎么求呢？ 我们如果在转移的时候，加上333，再减去1到3的和，是否就是2+33？ 所以我们只要做前缀和得到任意区间和，再在转移的时候减去该部分前缀和即可 C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; vector\u0026lt;int\u0026gt; qaq(n + 1); // 前缀和 for (int i = 1; i \u0026lt;= n; ++i) qaq[i] = qaq[i - 1] + qwq[i - 1]; int tmp = 0; // 记录每一段长度 for (int i = 0; i \u0026lt; m; ++i) tmp += qwq[i] * (i + 1); int ans = tmp; for (int i = m; i \u0026lt; n; ++i) { tmp -= qaq[i + 1] - qaq[i - m] - qwq[i] * (m + 1); ans = max(ans, tmp); // 更新最大值 } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solve(): n, m = map(int, input().split()) qwq = list(map(int, input().split())) qaq = [0] * (n + 1) # 前缀和 for i in range(1, n + 1): qaq[i] = qaq[i - 1] + qwq[i - 1] tmp = 0 # 记录每一段长度 for i in range(m): tmp += qwq[i] * (i + 1) ans = tmp for i in range(m, n): tmp -= qaq[i + 1] - qaq[i - m] - qwq[i] * (m + 1) ans = max(ans, tmp) # 更新最大值 print(ans) E 前缀和的嵌套\n做法:\n和上题有些类似，但由于实在太不直观，这边需要拿一张图说明一下： 首先我们要计算绿色的部分（和橙色重叠的地方变成了黄色），也就是 a1-a1a2a3 这个三角形 这段长度为 B 中第一段的 1 到 3 的和，我们不妨记作t(1,3)，很显然，我们要计算B中任意区间和，必须求出t(l,r) 我们思考如何计算例如t(3,3)： 首先，每个独立的列s(l,r)可以通过对A做前缀和由 qaq 数组求出 其次，t(1,r)是可以预处理得到的，记为 h 数组 而橙色部分也可以预处理得到，记为 w 数组 我们计算t(l,r)无非是将绿色部分减去黄色部分 所以绿色部分（不算重叠）的和就是绿色部分（算上重叠）减橙色部分（算上重叠）加上橙色部分（不算重叠） 而单独计算橙色部分（不算重叠）即s(1,l-1)*(n-r) 那么得到t(l,r) = h[r] - w[l-1] + (n-r) * qaq[l - 1] 现在我们得到如何计算t(l,r)，还得处理查询 查询需要确定给定区间包括了多少段和，我们提前预处理出来tsum数组，代表从l段右端点到r段左端点和 如果l和r在同一段，可以直接计算 如果不在同一段，则需计算l到l右端点，tsum和，r到r左端点，接着加在一起 查询也可以用数学公式确定到底在哪段，做到$O(1)$查询，不过$O(\\log{n})$显然够用了 C++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void solve() { int n, m; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; // Step 1. O(n)预处理 vector\u0026lt;int\u0026gt; qaq(n + 1); // 前缀和 vector\u0026lt;int\u0026gt; h(n + 1); // 纵向前缀和 vector\u0026lt;int\u0026gt; w(n + 1); // 横向前缀和 vector\u0026lt;int\u0026gt; tsum(n + 1); // 前缀和总和的前缀和 for (int i = 1; i \u0026lt;= n; ++i) qaq[i] = qaq[i - 1] + qwq[i - 1]; for (int i = 1; i \u0026lt;= n; ++i) h[i] = h[i - 1] + qaq[i]; for (int i = 1; i \u0026lt;= n; ++i) w[i] = w[i - 1] + qwq[i - 1] * (n - i + 1); auto t = [\u0026amp;](int l, int r) -\u0026gt; int { // lambda表达式，等效一个函数 return h[r] - w[l - 1] + (n - r) * qaq[l - 1]; }; for (int i = 1; i \u0026lt;= n; ++i) tsum[i] = tsum[i - 1] + t(i, n); // Step 2. O(log n)查询 cin \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; nums(n + 1); for (int i = 1; i \u0026lt;= n; ++i) nums[i] = nums[i - 1] + n - i + 1; while (m--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; int lf = lower_bound(nums.begin(), nums.end(), l) - nums.begin(); int rf = lower_bound(nums.begin(), nums.end(), r) - nums.begin(); int nl = l - nums[lf - 1] - 1; int nr = r - nums[rf - 1] - 1; if (lf == rf) { // 在同一段直接求和 cout \u0026lt;\u0026lt; t(lf, lf + nr) - t(lf, lf + nl - 1) \u0026lt;\u0026lt; ln; } else { int ans = 0; ans += t(lf, n) - t(lf, lf + nl - 1); // l到l右端点和 ans += tsum[rf - 1] - tsum[lf]; // 中间段和 ans += t(rf, rf + nr); // r到r左端点和 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } } } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import bisect def solve(): n = int(input()) qwq = list(map(int, input().split())) # Step 1. O(n)预处理 qaq = [0] * (n + 1) # 前缀和 h = [0] * (n + 1) # 纵向前缀和 w = [0] * (n + 1) # 横向前缀和 tsum = [0] * (n + 1) # 前缀和总和的前缀和 for i in range(1, n + 1): qaq[i] = qaq[i - 1] + qwq[i - 1] for i in range(1, n + 1): h[i] = h[i - 1] + qaq[i] for i in range(1, n + 1): w[i] = w[i - 1] + qwq[i - 1] * (n - i + 1) def t(l, r): return h[r] - w[l - 1] + (n - r) * qaq[l - 1] for i in range(1, n + 1): tsum[i] = tsum[i - 1] + t(i, n) # Step 2. O(log n)查询 m = int(input()) nums = [0] * (n + 1) for i in range(1, n + 1): nums[i] = nums[i - 1] + n - i + 1 for _ in range(m): l, r = map(int, input().split()) lf = bisect.bisect_left(nums, l) rf = bisect.bisect_left(nums, r) nl = l - nums[lf - 1] - 1 nr = r - nums[rf - 1] - 1 if lf == rf: # 在同一段直接求和 print(t(lf, lf + nr) - t(lf, lf + nl - 1)) else: ans = 0 ans += t(lf, n) - t(lf, lf + nl - 1) # l到l右端点和 ans += tsum[rf - 1] - tsum[lf] # 中间段和 ans += t(rf, rf + nr) # r到r左端点和 print(ans) ","date":"2024-11-02T00:00:00Z","permalink":"https://allergy27.github.io/p/flashmen_solve_3/","title":"2024级新生前缀和测试"},{"content":"背包问题 写于2023年，码风较为丑陋，建议优先查看官方推荐题解\n背包问题一共分为三种,01背包，完全背包，多重背包。 其中多重背包要了解二进制优化。\n零一背包 问题介绍： 有一个有限容量的背包，要装n种n个物品，物品占不同容量、有不同价值，求出最大能装下的价值\n算法分析：\n首先我们知道01背包问题最核心的就是取还是不取，这个问题可以联系到最经典的捡芝麻丢西瓜小故事。而与之不同的是我们要做出正确的决策 我们来想想看，什么样的决策是正确的？ 在背包里没有东西的时候，我们见到一个东西就拿一个东西是对的 在背包里装不下新的东西的时候，我们就需要做一些取舍，丢掉一部分的物品，转而装下新东西（当然，新东西需要更有价值 于是我们就可以先遍历东西，再从背包是空的情况向满的情况开始遍历，如果这个东西放进来更有价值我们就让它放进来 那么我们理解了这个决策的方法后，就可以用更学术的语言来描述这个过程了 我们设出一个dp表记作背包对应容量下能获得的最大价值 接着我们开始遍历 外层遍历物品，内层遍历背包的容量，而遍历过程中的状态转移方程则为：$dp[j]=max(dp[j],dp[j-w[i]]+v[i])$ 写出这个状态转移方程之后其实就可以直接写代码了，但是初次接触这个概念可能显得比较抽象，我们用一些图片来辅助理解: 我自拟了一个简单的01背包问题，那么我们直接模拟一下上面那个策略的执行过程： 首先我们遇到了重量为2，价值为3的西瓜，没什么好说的这遍循环直接将其加入:图2 接着我们遇到了3 4的西瓜，我们开始判断了：图3 因为容量是7，所以7-3 （这个西瓜）=4是4的位置，我们判断容量为4的最大值也就是3加上这个新东西4是否比原先容量为7时的值大。而7很显然大于3，我们替换：图4 接着依次类推直到下面这种情况:图5 其实没必要单领出来，但是这时是有一点点不一样的，我们能发现这时左边的不是3而是0了，所以我们比较的是0+4和3的大小关系，显然4更大些，接着类推直到包已经满了:图6 这时我们就接着判断下一个物品了，那么中间过程交给大火自己写了，我这里贴出最终的状态以供验证:图7 代码部分：\n老规矩昂，只有主体部分\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void solve() { int n, v, i, j; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt;qwq(v + 1, 0); vector\u0026lt;int\u0026gt;qwqV(n + 1, 0); vector\u0026lt;int\u0026gt;qwqW(n + 1, 0); //输入物品及价值 for(i = 1;i \u0026lt;= n;++i)cin \u0026gt;\u0026gt; qwqW[i] \u0026gt;\u0026gt; qwqV[i]; //动态规划 for(i = 1;i \u0026lt;= n;++i) for(j = v;j \u0026gt;=qwqW[i];--j) qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]); cout \u0026lt;\u0026lt; qwq[v] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 理解完这个西瓜的题目之后，我们去洛谷做一下也是相当经典的采药问题 完全背包 问题介绍： 从n种n个物品改成了n种无限个物品。\n算法分析：\n那么相信大火已经把01背包搞懂了，我们来搞懂完全背包问题 其实这个问题就是01背包反过来做，我们原先是从后往前遍历的，现在我们从前往后遍历 就是指每当遇到一个东西，我们都用它塞满背包，最后塞满时的状态就是最后我们要的答案 理解起来应该不难，代码上也只需要改一点， 所以我们直接给出题目并且附赠一个题解： 疯狂的采药 题解：\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 void solve() { ll n, v, i, j; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt;qwq(v + 1, 0); vector\u0026lt;ll\u0026gt;qwqV(n + 1, 0); vector\u0026lt;ll\u0026gt;qwqW(n + 1, 0); //输入物品及价值 for(i = 1;i \u0026lt;= n;++i)cin \u0026gt;\u0026gt; qwqW[i] \u0026gt;\u0026gt; qwqV[i]; //动态规划 for(i = 1;i \u0026lt;= n;++i) for(j = qwqW[i];j\u0026lt;=v;++j) //保证了一定不越界 qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]); //要么取，要么不取，不考虑空间用完 cout \u0026lt;\u0026lt; qwq[v] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 多重背包 问题介绍： 从n种n个变成了n种m个，也就是每种可能有多个\n算法分析：\n其实就是一个01背包问题，试想一下，我们将每种的多个都拆出来，是不是直接转换成了01背包问题 但是我们还需要优化（试想一下，我有两个物品，其中一个是1 1 1000000，那我如果转化的话，是不是不止2个物品的讨论情况了 但是也许你也注意到了，1000000个的话，我的背包可能根本装不完 是的，这样我们就转换成了完全背包+01背包问题 不过我们采取别的方法优化（主要是为了有东西可以写……） 我们来考虑一下将一个物品的数量分解： 如果是1 1 20，那我们可以拆成$(1+2+4+8)+5$ 为什么不是$4+16$呢？ 这是因为，前面括号括起来的数全是2的n次幂，我们可以用\u0026lt;\u0026lt;来实现轻松枚举，而4 16则没有明显的枚举关系（你可能会说4^1 4^2,总之因为位运算是二进制，符合2的n次都是可以的(不过取这些也许会得到错误的答案，不妨尝试一下)） 那么我们直接用一道宝物筛选来巩固一下吧\n题解：\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void solve() { int n, v, i, j, num, cnt = 0, a, b; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v; vector\u0026lt;int\u0026gt;qwq(1000005, 0); vector\u0026lt;int\u0026gt;qwqV(1000005, 0); vector\u0026lt;int\u0026gt;qwqW(1000005, 0); //输入物品及价值(二进制优化) for(i = 1;i \u0026lt;= n;++i) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; num; for(j = 1;j \u0026lt;= num;j \u0026lt;\u0026lt;= 1) { qwqV[++cnt] = j * a; qwqW[cnt] = j * b; num -= j; } if(num)qwqV[++cnt] = a * num, qwqW[cnt] = b * num; } //动态规划 for(i = 1;i \u0026lt;= cnt;++i) for(j = v;j \u0026gt;= qwqW[i];--j) //保证了一定不越界 qwq[j] = max(qwq[j], qwq[j - qwqW[i]] + qwqV[i]); //要么取，要么不取，不考虑空间用完 cout \u0026lt;\u0026lt; qwq[v] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":"2024-10-30T00:00:00Z","permalink":"https://allergy27.github.io/p/easy-dp-bag/","title":"简单线性dp-背包问题"},{"content":"2024级新生语言基础考核题解 考核链接：https://vjudge.net/contest/666653\n题目类型 A：签到题 B：思维 C：思维 D：思维 E：数学 F：滑动窗口 G：思维\n说明 Python代码全是由C++版本用GPT转译而来，逻辑上没有问题但不保证是在python下的最优实现 未提供C代码，请善用GPT等工具或尽快掌握C++的基础语法 C++模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x) \u0026amp; (-(x))) #define ln \u0026#39;\\n\u0026#39; #define int int64_t using namespace std; // NOLINT using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; void solve() { } signed main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); cin \u0026gt;\u0026gt; t; return 0; } Py模板\r1 2 3 4 5 6 def solve(): if __name__ == \u0026#34;__main__\u0026#34;: n = int(input()) for i in range(n): solve() A 签到题\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 void solve() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; if (a \u0026lt; b \u0026amp;\u0026amp; b \u0026lt; c) { cout \u0026lt;\u0026lt; \u0026#34;STAIR\\n\u0026#34;; } else if (a \u0026lt; b \u0026amp;\u0026amp; b \u0026gt; c) { cout \u0026lt;\u0026lt; \u0026#34;PEAK\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;NONE\\n\u0026#34;; } } Py代码\r1 2 3 4 5 6 7 8 def solve(): a, b, c = map(int, input().split()) if a \u0026lt; b \u0026lt; c: print(\u0026#34;STAIR\u0026#34;) elif a \u0026lt; b \u0026gt; c: print(\u0026#34;PEAK\u0026#34;) else: print(\u0026#34;NONE\u0026#34;) B 思维题\n想明白Kosuke获胜n一定是奇数，就好做了\nC++代码\r1 2 3 4 5 6 7 8 9 void solve() { int n, m; cin \u0026gt;\u0026gt; n; if (n \u0026amp; 1) { cout \u0026lt;\u0026lt; \u0026#34;Kosuke\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;Sakurako\\n\u0026#34;; } } Py代码\r1 2 3 4 5 6 def solve(): n = int(input()) if n % 2 == 1: print(\u0026#34;Kosuke\u0026#34;) else: print(\u0026#34;Sakurako\u0026#34;) C 思维题\n想清楚最多只要一次就行，假如B个数已经为k则为0次，否则B多了就0到i变A,B少了0到i变B。\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void solve() { // 解题部分 int n, m, i, f = 0, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;char\u0026gt; s(n); for (auto \u0026amp;x : s) { cin \u0026gt;\u0026gt; x; if (x == \u0026#39;B\u0026#39;) ++ans; } if (ans \u0026lt; m) { f += 2; for (i = 0; i \u0026lt; n \u0026amp;\u0026amp; ans != m; ++i) if (s[i] == \u0026#39;A\u0026#39;) ++ans; } else if (ans \u0026gt; m) { f += 1; for (i = 0; i \u0026lt; n \u0026amp;\u0026amp; ans != m; ++i) if (s[i] == \u0026#39;B\u0026#39;) --ans; } cout \u0026lt;\u0026lt; (f ? \u0026#34;1\\n\u0026#34; : \u0026#34;0\\n\u0026#34;); if (f != 0) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; \u0026#34;AB\u0026#34;[f - 1] \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def solve(): n, m = map(int, input().split()) s = list(input().strip()) ans = sum(1 for x in s if x == \u0026#34;B\u0026#34;) f = 0 i = 0 if ans \u0026lt; m: f += 2 while i \u0026lt; n: if ans == m: break if s[i] == \u0026#34;A\u0026#34;: ans += 1 i += 1 elif ans \u0026gt; m: f += 1 while i \u0026lt; n: if ans == m: break if s[i] == \u0026#34;B\u0026#34;: ans -= 1 i += 1 print(\u0026#34;1\u0026#34; if f else \u0026#34;0\u0026#34;) if f != 0: print(i, \u0026#34;AB\u0026#34;[f - 1]) D 思维题\n题目翻译有点问题，但是能看出来比赛想要结束一定是由某个人赢了来结束，也就是输出最后一个\nC++代码\r1 2 3 4 5 6 void solve() { string s; cin \u0026gt;\u0026gt; s; cin \u0026gt;\u0026gt; s; cout \u0026lt;\u0026lt; s.back() \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 def solve(): input() s = input().strip() print(s[-1]) E 数学\n先计算2*2的方块，每有两个都会产生7个空位，有剩余就多4个 再看空位够不够，把1*1个数减去空位再/15即可，不要忘记向上取整\nC++代码\r1 2 3 4 5 6 7 8 9 void solve() { int n, m, res = 0; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; res += (n % 2) * 4 + ((n + 1) / 2) * 7; if (res \u0026gt; m) cout \u0026lt;\u0026lt; (n + 1) / 2 \u0026lt;\u0026lt; ln; else cout \u0026lt;\u0026lt; (n + 1) / 2 + (m - res + 14) / 15 \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 def solve(): m, n = map(int, input().split()) res = (n % 2) * 4 + ((n + 1) // 2) * 7 if res \u0026gt; m: print((n + 1) // 2) else: print((n + 1) // 2 + (m - res + 14) // 15) F 滑动窗口\n不定长的滑动窗口，每次扩展右端点，扩展到:\n右端点不等于上一个数+1 右端点减左端点大于k 则移动左端点\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; qwq(n); for (auto \u0026amp;x : qwq) cin \u0026gt;\u0026gt; x; sort(qwq.begin(), qwq.end()); int l = 0, r = 0; int l_ans = qwq[0], r_ans = qwq[0]; int ans = 1; while (r \u0026lt; n) { if (++r == n) break; if (qwq[r] \u0026gt; r_ans + 1) { ans = max(ans, r - l); l = r; l_ans = qwq[r]; } r_ans = qwq[r]; while (r_ans - l_ans + 1 \u0026gt; m) { l_ans = qwq[++l]; } ans = max(ans, r - l + 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def solve(): n, m = map(int, input().split()) qwq = list(map(int, input().split())) qwq.sort() l, r = 0, 0 l_ans = r_ans = qwq[0] ans = 1 while r \u0026lt; n: r += 1 if r == n: break if qwq[r] \u0026gt; r_ans + 1: ans = max(ans, r - l) l = r l_ans = qwq[r] r_ans = qwq[r] while r_ans - l_ans + 1 \u0026gt; m: l += 1 l_ans = qwq[l] ans = max(ans, r - l + 1) print(ans) G 思维题\n每一位的计算是独立的，而由于是减法运算，也不会出现进位,又$a|b \\geq a\\\u0026c$,不会出现借位，所以对每一位单独考虑就行，我们列出真值表:\nb c d a 0 0 0 0 0 0 1 1 0 1 0 1\\0 1 0 1 1\\0 1 1 0 1 1 1 1 0 需要注意，不会有(b,c,d) = (1,0,0) or (b,c,d) = (0,1,1)的情况，所以一旦出现就证明构造不出\nC++代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void solve() { int a = 0, b, c, d, bit = 1, f = 1; cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; for (int i = 0; i \u0026lt; 62; ++i) { int bit_b = (b \u0026amp; bit) ? 1 : 0; int bit_c = (c \u0026amp; bit) ? 1 : 0; int bit_d = (d \u0026amp; bit) ? 1 : 0; if (bit_b \u0026amp;\u0026amp; (!bit_c) \u0026amp;\u0026amp; (!bit_d) || (!bit_b) \u0026amp;\u0026amp; bit_c \u0026amp;\u0026amp; bit_d) { f = 0; break; } a |= (bit_b \u0026amp;\u0026amp; bit_c) ? bit * (1ll - bit_d) : bit * bit_d; bit \u0026lt;\u0026lt;= 1; } cout \u0026lt;\u0026lt; (f ? a : -1) \u0026lt;\u0026lt; ln; } Py代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def solve(): a, b, c, d = 0, *map(int, input().split()) bit, f = 1, 1 for i in range(62): bit_b = 1 if (b \u0026amp; bit) else 0 bit_c = 1 if (c \u0026amp; bit) else 0 bit_d = 1 if (d \u0026amp; bit) else 0 if (bit_b and not bit_c and not bit_d) or (not bit_b and bit_c and bit_d): f = 0 break a |= (bit * (1 - bit_d)) if (bit_b and bit_c) else bit * bit_d bit \u0026lt;\u0026lt;= 1 print(a if f else -1) ","date":"2024-10-26T00:00:00Z","permalink":"https://allergy27.github.io/p/flashmen_solve_2/","title":"2024级新生语言基础测试"},{"content":"转自 源地址：https://studyingfather.com/archives/841 源仓库地址：https://github.com/SFOI-Team/luogu-problem-list star截图： 转载前言 从luogu上copy来的，因为用luogu的那个找题有些不方便干脆转过来了。 仅供本人自己练习使用，原作者源码都在上方，如转载请勿转载我的版本，转载原作者的。\n新版本食用指南 本次版本更新变更较大，建议您仔细阅读下面的内容！\n在刚刚更新的 2.0 版本中，我们改变了原来按知识难度排列知识点的目录结构，改为按照专题大类组织目录结构。\n为了方便按知识难度刷题的用户，这里给出一些建议：\n对于初学者，建议先完成 Part 1,2 两部分内容，为接下来的学习打好基础。 对于要参加 CSP-S 的选手，建议在前面的基础上优先完成 Part 3.1-3.4, 4.1-4.4, 6.1-6.5, 7.1-7.8, 8.1-8.7 的内容（具体内容见下），在此基础上继续完成其他内容。 每个专题下的题目先给出模板，剩下的题目均按照难度递增顺序排序，部分难度较高的综合性题目建议达到一定能力后再尝试解决。 Part 0 试机题 三道试机题目。\nP1000 超级玛丽游戏 - Accept P1001 A+B Problem - Accept P1008 三连击 - Accept Part 1 入门阶段 本部分内容针对入门 OIer ，主要是语言基础内容。\nPart 1.1 从零开始 语言基础题。\nP1421 小玉买文具 - Accept P1909 买铅笔 - Accept P1089 津津的储蓄计划 - Accept P1085 不高兴的津津 - Accept P1035 级数求和 - Accept P1980 计数问题 - Accept P1014 Cantor表 - Accept P1307 数字反转 - Accept Part 1.2 数组基础 数组可以用于存储大量的信息。\nP1046 陶陶摘苹果 - Accept P1047 校门外的树 - Accept P1427 小鱼的数字游戏 - Accept P2141 珠心算测验 - Accept P5594 【XR-4】模拟赛 - Accept Part 1.3 字符串基础 字符串是特殊的数组，但它也有很多自身的特点。\nP5015 标题统计 - Accept P1055 ISBN号码 - Accept P1308 统计单词数 - Accept P2010 回文日期 - Accept P1012 拼数 - Accept P5587 打字练习 - Accept Part 1.4 函数，递归及递推 这是初学者最难理解的部分，建议画出递归图来理解递归的过程。\nP1028 数的计算 - Accept P1036 选数 - Accept P1464 Function - Accept P5534 【XR-3】等差数列 - Accept P1192 台阶问题 - Accept P1025 数的划分 - Accept P4994 终于结束的起点 - Accept Part 2 基础算法 这一部分的内容包含了 OI 中的基础算法，供各位巩固基础。\n当然，这里面也有一些难度比较高的题目。\nPart 2.1 模拟 模拟，顾名思义就是题目要求你做什么你就做什么，这样的题目很考验选手的代码组织能力。\n这里不仅仅有非常基础的模拟，也有一些非常复杂的题目。\nP1003 铺地毯 - Accept P1067 多项式输出 - Accept P1328 生活大爆炸版石头剪刀布 - Accept P1563 玩具谜题 - Accept P1042 乒乓球 - Accept P1179 数字统计 P2615 神奇的幻方 - Accept P3952 时间复杂度 P2482 [SDOI2010]猪国杀 P5380 [THUPC2019]鸭棋 Part 2.2 排序算法 通过排序，我们可以将数据有序化，这让我们对数据的处理方便了很多。\nP1177 【模板】快速排序 - Accept P1059 明明的随机数 - Accept P1068 分数线划定 - Accept P1051 谁拿了最多奖学金 P1309 瑞士轮 - Accept P1908 逆序对 - Accept Part 2.3 二分答案 对一个满足单调性质的问题，我们可以采用二分答案的方法来解决。\nP1024 一元三次方程求解 P2678 跳石头 P1824 进击的奶牛 P1902 刺杀大使 P1314 聪明的质监员 P1083 借教室 P4343 [SHOI2015]自动刷题机 Part 2.4 分治 分治，即分而治之，将大问题分解为小问题，分别求解，最后合并结果。\nP1226 【模板】快速幂||取余运算 - Accept P1010 幂次方 - Accept P1429 平面最近点对（加强版） P3612 [USACO17JAN]Secret Cow Code Part 2.5 贪心 贪心，指的是决策时都采取当前最优解的算法。有的时候，这样做确实可以获得最优解。\nP1208 [USACO1.3]Mixing Milk P4995 跳跳！ - Accept P1094 纪念品分组 - Accept P1199 三国游戏 P2672 推销员 - Accept P1080 国王游戏 - Accept P2123 皇后游戏 P5521 [yLOI2019]梅深不见冬 Part 2.6 构造 构造题是一种形式灵活多样的题型。正是因为这个特点，使得构造题没有一种通用的方法。\nP3599 Koishi Loves Construction P5441 【XR-2】伤痕 P5595 【XR-4】歌唱比赛 Part 2.7 高精度 在 C++ 中，long long 都无法表示我们需要的整数时怎么办？那就用高精度吧！\nP1601 A+B Problem（高精） - Accept P2142 高精度减法 P1303 A*B Problem - Accept P1480 A/B Problem P1009 阶乘之和 - Accept Part 2.8 前缀和 \u0026amp; 差分 前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。\nP3131 [USACO16JAN]Subsequences Summing to Sevens P1387 最大正方形 P3397 地毯 - Accept P2280 [HNOI2003]激光炸弹 P4552 [Poetize6] IncDec Sequence Part 3 搜索 搜索其实就是高级的枚举，很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。\nPart 3.1 深度优先搜索 深度优先搜索（DFS），即按照深度优先的顺序搜索的算法。\n深度优先搜索一般使用栈来实现。\nP1219 八皇后 - Accept P1019 单词接龙 - Accept P5194 [USACO05DEC]Scales P5440 【XR-2】奇迹 P1378 油滴扩展 Part 3.2 广度优先搜索 广度优先搜索（BFS），即优先扩展浅层节点，逐渐深入的搜索算法。\n广度优先搜索一般使用队列来实现。\nP1162 填涂颜色 P1443 马的遍历 - Accept P3956 棋盘 P1032 字串变换 P1126 机器人搬重物 Part 3.3 记忆化搜索 通过将已经遍历的状态记录下来，从而减少重复的搜索量，这就是记忆化搜索。\n动态规划的时候，记忆化搜索也是一种高效简洁的实现方式。\nP1514 引水入城 P1535 游荡的奶牛 P1434 [SHOI2002]滑雪 P3953 逛公园 Part 3.4 搜索的剪枝 对于一些不必要搜索的部分，我们可以避免访问这些状态，从而提高搜索效率。\nP1120 小木棍 ［数据加强版］ P1312 Mayan游戏 P1074 靶形数独 Part 3.5 双向搜索 在搜索时，如果能从初态和终态出发，同时进行搜索，就可以减小搜索树的规模，提高时间效率。\nP3067 [USACO12OPEN]Balanced Cow Subsets P4799 [CEOI2015 Day2]世界冰球锦标赛 P5195 [USACO05DEC]Knights of Ni Part 3.6 A* 在 BFS 中，如果能设计一个合理的估价函数，就可以更快扩展到最优解。这就是 A*算法。\nP1379 八数码难题 Part 3.7 IDA* 像 BFS 那样，每次只扩展一层节点，却采用 DFS 方式来遍历搜索树，这就是迭代加深搜索。\n再加上一个估价函数来减小搜索量，就是 IDA*了。\nP2324 [SCOI2005]骑士精神 P2534 [AHOI2012]铁盘整理 Part 3.8 DLX 算法 X 是通过回溯法求解精确覆盖问题的算法，而删除列这一操作可以使用舞蹈链加速。\nP4929 【模板】舞蹈链（DLX） P4205 [NOI2005]智慧珠游戏 Part 4 动态规划 动态规划是一种重要的思维方法，通过利用已有的子问题信息高效求出当前问题的最优解。\nPart 4.1 线性动态规划 线性动态规划，即具有线性阶段划分的动态规划。\nP1216 数字三角形 - Accept P1020 导弹拦截 - Accept P1091 合唱队形 - Accept P1095 守望者的逃离 - Accept P1541 乌龟棋 - Accept P1868 饥饿的奶牛 - Accept P2679 子串 - Accept P2501 [HAOI2006]数字序列 P3336 [ZJOI2013]话旧 P3558 [POI2013]BAJ-Bytecomputer P4158 [SCOI2009]粉刷匠 P5301 [GXOI/GZOI2019]宝牌一大堆 Part 4.2 背包动态规划 背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。\nP1048 采药 - Accept P1060 开心的金明 - Accept P1855 榨取kkksc03 - Accept P5020 货币系统 P1757 通天之分组背包 P1064 金明的预算方案 P2946 [USACO09MAR]Cow Frisbee Team P1156 垃圾陷阱 P5322 [BJOI2019]排兵布阵 P5289 [十二省联考2019]皮配 Part 4.3 区间动态规划 区间动态规划一般以区间作为动态规划的阶段。\nP1880 [NOI1995]石子合并 P3146 [USACO16OPEN]248 P1063 能量项链 P1005 矩阵取数游戏 - Accept P4170 [CQOI2007]涂色 P4302 [SCOI2003]字符串折叠 P2466 [SDOI2008]Sue的小球 Part 4.4 树形动态规划 树形动态规划，即在树上进行的动态规划。\n因为树的递归性质，树形动态规划一般都是递归求解的。\nP1352 没有上司的舞会 P1040 加分二叉树 P1122 最大子树和 P1273 有线电视网 P2014 选课 P2585 [ZJOI2006]三色二叉树 P3047 [USACO12FEB]Nearby Cows P3698 [CQOI2017]小Q的棋盘 P5658 括号树 P2607 [ZJOI2008]骑士 P3177 [HAOI2015]树上染色 P4395 [BOI2003]Gem P4516 [JSOI2018]潜入行动 Part 4.5 状态压缩动态规划 将一个状态压缩为一个整数（通常为二进制数），就可以在更为方便地进行状态转移的同时，达到节约空间的目的。\nP2704 [NOI2001]炮兵阵地 P1879 [USACO06NOV]Corn Fields P1896 [SCOI2005]互不侵犯 P3092 [USACO13NOV]No Change P3694 邦邦的大合唱站队 P4925 [1007]Scarlet的字符串不可能这么可爱 P2157 [SDOI2009]学校食堂 P2167 [SDOI2009]Bill的挑战 P2396 yyy loves Maths VII P4363 [九省联考2018]一双木棋 P5005 中国象棋 - 摆上马 P2150 [NOI2015]寿司晚宴 Part 4.6 倍增优化动态规划 利用倍增的方式，我们可以将状态转移的效率大大提高。\nP1613 跑路 P1081 开车旅行 P5024 保卫王国 Part 4.7 数据结构优化动态规划 利用数据结构来维护已有信息，也可以达到优化状态转移的目的。\nP4719 【模板】动态dp P4751 动态dp【加强版】 P3287 [SCOI2014]方伯伯的玉米田 P2605 [ZJOI2010]基站选址 Part 4.8 单调队列优化动态规划 借助单调队列，排除不可能的决策，可以起到优化状态转移的效果。\nP1776 宝物筛选 - Accept P3089 [USACO13NOV]Pogo-Cow P3572 [POI2014]PTA-Little Bird P3522 [POI2011]TEM-Temperature P4544 [USACO10NOV]Buying Feed P5665 划分 P1973 [NOI2011]Noi嘉年华 P2569 [SCOI2010]股票交易 P4852 yyf hates choukapai Part 4.9 斜率优化动态规划 通过用单调队列维护一个凸壳，来达到优化转移的目的。\nP2900 [USACO08MAR]Land Acquisition P3195 [HNOI2008]玩具装箱 P3628 [APIO2010]特别行动队 P3648 [APIO2014]序列分割 P4027 [NOI2007]货币兑换 P4360 [CEOI2004]锯木厂选址 P5468 [NOI2019]回家路线 P2305 [NOI2014]购票 Part 4.10 决策单调性优化动态规划 利用决策间的递变规律，也能实现优化状态转移的目的。\nP3515 [POI2011]Lightning Conductor P4767 [IOI2000]邮局 P1912 [NOI2009]诗人小G P1973 [NOI2011]Noi嘉年华 P3724 [AH2017/HNOI2017]大佬 P5574 [CmdOI2019]任务分配问题 Part 4.11 数位统计类动态规划 统计一个区间中满足条件的数有多少，就是数位统计类动态规划。\nP2602 [ZJOI2010]数字计数 P3281 [SCOI2013]数数 P2518 [HAOI2010]计数 P2657 [SCOI2009]windy数 P3286 [SCOI2014]方伯伯的商场之旅 P4124 [CQOI2016]手机号码 P4999 烦人的数学作业 P2606 [ZJOI2010]排列计数 P4798 [CEOI2015 Day1]卡尔文球锦标赛 Part 4.12 轮廓线动态规划 轮廓线动态规划（即常说的插头 DP）是一种特殊的状压动态规划，通过以轮廓线为状态来实现状态转移。\nP5056 【模板】插头dp P2289 [HNOI2004]邮递员 P2337 [SCOI2012]喵星人的入侵 P5347 【XR-1】俄罗斯方块 Part 5 字符串 字符串问题有很多自己的特点。\nPart 5.1 字符串哈希 字符串哈希通过牺牲很小的准确率，达到快速进行字符串匹配的效果。\nP3370 【模板】字符串哈希 P5270 无论怎样神树大人都会删库跑路 P5537 【XR-3】系统设计 Part 5.2 KMP KMP 算法可以用来解决模式串匹配问题。\nP3375 【模板】KMP字符串匹配 - Accept P4391 [BOI2009]Radio Transmission P3435 [POI2006]OKR-Periods of Words P4824 [USACO15FEB]Censoring (Silver) P2375 [NOI2014]动物园 P3426 [POI2005]SZA-Template P3193 [HNOI2008]GT考试 Part 5.3 Manacher Manacher 可以在线性时间内求出一个字符串的最长回文子串。\nP3805 【模板】manacher算法 P4555 [国家集训队]最长双回文串 P1659 [国家集训队]拉拉队排练 Part 5.4 Trie树 Trie树可以像查字典一样把多个字符串组织到一棵树上。\nP3879 [TJOI2010]阅读理解 P2292 [HNOI2004]L语言 P2922 [USACO08DEC]Secret Message P3065 [USACO12DEC]First! P3294 [SCOI2016]背单词 P4407 [JSOI2009]电子字典 P4551 最长异或路径 P4683 [IOI2008]Type Printer P3783 [SDOI2017]天才黑客 Part 5.5 AC自动机 AC自动机可以看成是 KMP 和 Trie 的结合体，用于解决多字符串匹配问题。\nP3808 【模板】AC自动机（简单版） P3796 【模板】AC自动机（加强版） P5357 【模板】AC自动机（二次加强版） P3121 [USACO15FEB]Censoring (Gold) P2414 [NOI2011]阿狸的打字机 P3966 [TJOI2013]单词 P2444 [POI2000]病毒 P3311 [SDOI2014]数数 P4052 [JSOI2007]文本生成器 P5599 【XR-4】文本编辑器 Part 5.6 回文自动机 回文自动机是解决回文串问题的有力工具。\nP5496 【模板】回文自动机（PAM） P3649 [APIO2014]回文串 P4287 [SHOI2011]双倍回文 P4762 [CERC2014]Virus synthesis Part 5.7 后缀数组 后缀数组可以解决很多字符串匹配的问题。\nP3809 【模板】后缀排序 P5353 【模板】树上后缀排序 P2336 [SCOI2012]喵星球上的点名 P2463 [SDOI2008]Sandy的卡片 P2852 [USACO06DEC]Milk Patterns P4051 [JSOI2007]字符加密 P1117 [NOI2016]优秀的拆分 P2178 [NOI2015]品酒大会 P5346 【XR-1】柯南家族 P5576 [CmdOI2019]口头禅 Part 5.8 后缀自动机 后缀自动机是一种处理字符串问题的强大工具。\nP3804 【模板】后缀自动机 P3649 [APIO2014]回文串 P3975 [TJOI2015]弦论 P4248 [AHOI2013]差异 P5341 [TJOI2019]甲苯先生和大中锋的字符串 P4770 [NOI2018]你的名字 P5284 [十二省联考2019]字符串问题 P5319 [BJOI2019]奥术神杖 Part 6 数学 OI 中的数学知识很多，也有些杂乱。\nPart 6.1 位运算 将十进制整数转换为二进制后，有很多按位运算的运算符。\n如果能善于利用位运算的一些性质，往往能达到事半功倍的效果。\nP5657 格雷码 P5514 [MtOI2019]永夜的报应 P5538 【XR-3】Namid[A]me P5539 【XR-3】Unknown Mother-Goose P5523 [yLOI2019]珍珠 Part 6.2 整除相关 与整除相关的概念有很多，比较常用的有素数，最大公约数和欧拉函数。\nPart 6.2.1 素数 素数，指的是除 1 和它本身之外没有其他约数的数。\nP4718 【模板】Pollard-Rho算法 P1075 质因数分解 - Accept P2441 角色属性树 P5535 【XR-3】小道消息 Part 6.2.2 最大公约数 如果两个数有一个共同的约数，那么这个约数就被称为公约数。最大公约数就是指这两个数的所有公约数中，最大的一个。\n求解两个数的最大公约数，可以采用欧几里得算法解决。\nP5435 【模板】快速 GCD P5436 【XR-2】缘分 P1029 最大公约数和最小公倍数问题 - Accept P1414 又是毕业季II P2152 [SDOI2009]SuperGCD P1072 Hankson 的趣味题 Part 6.2.3 欧拉函数 欧拉函数 $ \\varphi (x) $ 表示了小于 $ x $ 的数字中，与 $ x $ 互质的数字个数。\nP2158 [SDOI2008]仪仗队 P2568 GCD P2398 GCD SUM P4139 上帝与集合的正确用法 Part 6.3 同余方程 求解同余方程往往可以引出不少话题。\nPart 6.3.1 线性同余方程\u0026amp;乘法逆元 线性同余方程是同余方程中最基础的内容。\nP4549 【模板】裴蜀定理 P2613 【模板】有理数取余 P3811 【模板】乘法逆元 P5431 【模板】乘法逆元2 P1082 同余方程 P3951 小凯的疑惑 P1516 青蛙的约会 Part 6.3.2 中国剩余定理 中国剩余定理可以快速解一元线性同余方程组。\nP4777 【模板】扩展中国剩余定理（EXCRT） P3868 [TJOI2009]猜数字 P2480 [SDOI2010]古代猪文 P4774 [NOI2018]屠龙勇士 P5345 【XR-1】快乐肥宅 Part 6.3.3 高次同余方程 BSGS 算法可以高效计算离散对数。\n而高次剩余的求解更加复杂，其中二次剩余作为高次剩余中比较特殊的情况，可以使用 Cipolla 法求解。\nP4195 【模板】exBSGS P5491 【模板】二次剩余 P3306 [SDOI2013]随机数生成器 P2485 [SDOI2011]计算器 Part 6.4 博弈论 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。\nP2197 【模板】nim游戏 P1288 取数游戏II P1290 欧几里德的游戏 P1247 取火柴游戏 P2252 取石子游戏 Part 6.5 概率与期望 概率和期望是紧密相连的，OI 中往往会出现和概率期望相关的动态规划问题。\nP5104 红包发红包 P1850 换教室 P3830 [SHOI2012]随机树 P4564 [CTSC2018]假面 P2473 [SCOI2008]奖励关 P2221 [HAOI2012]高速公路 P3239 [HNOI2015]亚瑟王 P3750 [六省联考2017]分手是祝愿 P4284 [SHOI2014]概率充电器 P5249 [LnOI2019]加特林轮盘赌 P2081 [NOI2012]迷失游乐园 P3343 [ZJOI2015]地震后的幻想乡 P3600 随机数生成器 P5326 [ZJOI2019]开关 Part 6.6 组合数学 组合数学常常与计数问题，概率期望紧密相连。\nPart 6.6.1 排列组合 排列组合是组合数学的基础。\nP3807 【模板】卢卡斯定理 P2822 组合数问题 P5520 [yLOI2019]青原樱 P3197 [HNOI2008]越狱 P2290 [HNOI2004]树的计数 P4981 父子 P4769 [NOI2018]冒泡排序 P4931 情侣？给我烧了！（加强版） P5596 【XR-4】题 P5598 【XR-4】混乱度 Part 6.6.2 卡特兰数\u0026amp;斯特林数 卡特兰数和斯特林数是两类常见的组合递推数列。\nP5395 第二类斯特林数·行 P5396 第二类斯特林数·列 P5408 第一类斯特林数·行 P5409 第一类斯特林数·列 P1655 小朋友的球 P2532 [AHOI2012]树屋阶梯 P3200 [HNOI2009]有趣的数列 P3978 [TJOI2015]概率论 P4091 [HEOI2016/TJOI2016]求和 P4827 [国家集训队]Crash 的文明世界 Part 6.6.3 容斥原理 容斥原理常常用于解决集合的计数问题。\nP5664 Emiya 家今天的饭 P1450 [HAOI2008]硬币购物 P3214 [HNOI2011]卡农 P3270 [JLOI2016]成绩比较 P4336 [SHOI2016]黑暗前的幻想乡 P4448 [AHOI2018初中组]球球的排列 P4491 [HAOI2018]染色 P5339 [TJOI2019]唱、跳、rap和篮球 P5400 [CTS2019]随机立方体 Part 6.7 线性代数 线性代数主要用于解决线性关系问题。\nPart 6.7.1 矩阵 利用矩阵优化数列递推，可以实现复杂度从线性到对数级的转变。\nP3390 【模板】矩阵快速幂 P1939 【模板】矩阵加速（数列） P4783 【模板】矩阵求逆 P1962 斐波那契数列 P1349 广义斐波那契数列 P4000 斐波那契数列 P3758 [TJOI2017]可乐 P4967 黑暗打击 P5343 【XR-1】分块 P5337 [TJOI2019]甲苯先生的字符串 P5303 [GXOI/GZOI2019]逼死强迫症 Part 6.7.2 高斯消元 高斯消元可以用来求解方程组。\nP3389 【模板】高斯消元法 P2447 [SDOI2010]外星千足虫 P4035 [JSOI2008]球形空间产生器 P5516 [MtOI2019]小铃的烦恼 P4111 [HEOI2015]小Z的房间 P4457 [BJOI2018]治疗之雨 Part 6.7.3 线性基 线性基可以求解最大异或和的一类问题。\nP3812 【模板】线性基 P3857 [TJOI2008]彩灯 P4570 [BJWC2011]元素 P4301 [CQOI2013]新Nim游戏 P3292 [SCOI2016]幸运数字 P4151 [WC2011]最大XOR和路径 Part 6.8 多项式 对多项式的运算进行优化，从而能够解决规模更大的问题。\nP3803 【模板】多项式乘法（FFT） P4238 【模板】多项式求逆 P4245 【模板】任意模数NTT P4512 【模板】多项式除法 P4717 【模板】快速沃尔什变换 P4721 【模板】分治 FFT P4725 【模板】多项式对数函数 P4726 【模板】多项式指数函数 P4781 【模板】拉格朗日插值 P5050 【模板】多项式多点求值 P5158 【模板】多项式快速插值 P5205 【模板】多项式开根 P5245 【模板】多项式快速幂 P5273 【模板】多项式幂函数 (加强版) P5282 【模板】快速阶乘算法 P5373 【模板】多项式复合函数 P5394 【模板】下降幂多项式乘法 P3338 [ZJOI2014]力 P3723 [AH2017/HNOI2017]礼物 P5437 【XR-2】约定 P5293 [HNOI2019]白兔之舞 P5432 A/B Problem (加强版) P5472 [NOI2019]斗主地 P5577 [CmdOI2019]算力训练 Part 6.9 莫比乌斯反演 运用莫比乌斯反演，我们可以将一些函数转化，从而降低计算难度。\nP3172 [CQOI2015]选数 P2522 [HAOI2011]Problem b P3455 [POI2007]ZAP-Queries P3327 [SDOI2015]约数个数和 P1829 [国家集训队]Crash的数字表格 / JZPTAB P4619 [SDOI2018]旧试题 P3704 [SDOI2017]数字表格 P5518 [MtOI2019]幽灵乐团 Part 6.10 筛法 利用数列的性质，有多种筛法可以求出我们想要的信息。\nP3383 【模板】线性筛素数 P4213 【模板】杜教筛（Sum） P5325 【模板】Min_25筛 P1865 A % B Problem P1621 集合 P3768 简单的数学题 P5438 【XR-2】记忆 Part 6.11 线性规划 线性规划是研究线性约束条件下线性目标函数极值问题的方法。\nP3980 [NOI2008]志愿者招募 P4232 无意识之外的捉迷藏 Part 6.12 数值方法 在算法领域，有很多求近似值的数值方法。\nPart 6.12.1 三分法 三分法可以求出一个单峰 / 单谷函数的极值。\nP3382 【模板】三分法 P1883 函数 Part 6.12.2 自适应辛普森法 自适应辛普森法可以高效求出给定函数的数值积分。\nP4525 【模板】自适应辛普森法1 P4526 【模板】自适应辛普森法2 P3779 [SDOI2017]龙与地下城 Part 6.13 置换群 置换群通常用来解决一些涉及“本质不同”的计数问题。\nP4980 【模板】Polya定理 P1446 [HNOI2008]Cards P2561 [AHOI2002]黑白瓷砖 P4128 [SHOI2006]有色图 P4727 [HNOI2009]图的同构记数 Part 7 数据结构 灵活地运用数据结构可以高效地查询并处理需要的信息。\nPart 7.1 链表 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。\nP1996 约瑟夫问题 P1160 队列安排 Part 7.2 栈 栈，是一种后进先出（FILO）的数据结构。\nP1449 后缀表达式 P1739 表达式括号匹配 P1981 表达式求值 P1175 表达式的转换 Part 7.3 队列 队列，是一种先进先出（FIFO）的数据结构。\nP1540 机器翻译 Part 7.4 并查集 并查集常用于处理一些不相交集合的合并和查询问题。\nP1111 修复公路 - Accept P3958 奶酪 - Accept P1525 关押罪犯 - Accept P4185 [USACO18JAN]MooTube G P2024 [NOI2001]食物链 P1197 [JSOI2008]星球大战 P1196 [NOI2002]银河英雄传说 P1955 [NOI2015]程序自动分析 Part 7.5 二叉堆 二叉堆是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。\nP3378 【模板】堆 P1090 合并果子 - Accept P1168 中位数 - Accept P2085 最小函数值 P2827 蚯蚓 P3045 [USACO12FEB]Cow Coupons Part 7.6 ST表 ST表可以离线查询区间最值。\nP3865 【模板】ST表 - Accept P2251 质量检测 P1816 忠诚 P1198 [JSOI2008]最大数 P2880 [USACO07JAN]Balanced Lineup P5012 水の数列 P5344 【XR-1】逛森林 P2048 [NOI2010]超级钢琴 Part 7.7 树状数组 树状数组是一种简洁高效的树形数据结构。\nP3374 【模板】树状数组 1 P3368 【模板】树状数组 2 P1908 逆序对 - Accept P1966 火柴排队 P3605 [USACO17JAN]Promotion Counting P1972 [SDOI2009]HH的项链 P3586 [POI2015]LOG P4054 [JSOI2009]计数问题 P4113 [HEOI2012]采花 P3960 列队 Part 7.8 线段树 线段树的通用性比树状数组更强，可以处理更多涉及区间操作的题目。\nP3372 【模板】线段树 1 - Accept P3373 【模板】线段树 2 P5490 【模板】扫描线 P4588 [TJOI2018]数学计算 P1502 窗口的星星 P2471 [SCOI2007]降雨量 P2824 [HEOI2016/TJOI2016]排序 P3722 [AH2017/HNOI2017]影魔 P4097 [HEOI2013]Segment P4198 楼房重建 P4513 小白逛公园 P4556 [Vani有约会]雨天的尾巴 P5324 [BJOI2019]删数 P5327 [ZJOI2019]语言 Part 7.9 分块 分块是一种非常通用的暴力方法，虽然效率不如线段树和树状数组，但可以解决很多线段树和树状数组处理不了的问题。\nP3870 [TJOI2009]开关 P3396 哈希冲突 P3863 序列 P1975 [国家集训队]排队 P3710 方方方的数据结构 P3992 [BJOI2017]开车 P4168 [Violet]蒲公英 P4119 [Ynoi2018]未来日记 Part 7.10 可并堆 可并堆分为左偏树和配对堆两种，它们都具有堆的性质，且可以高效合并。\nP3377 【模板】左偏树（可并堆） P2713 罗马游戏 P1456 Monkey King P1552 [APIO2012]派遣 P3261 [JLOI2015]城池攻占 P3273 [SCOI2011]棘手的操作 P4331 [BOI2004]Sequence Part 7.11 主席树 主席树，即可持久化权值线段树。\nP2468 [SDOI2010]粟粟的书架 P3302 [SDOI2013]森林 P3168 [CQOI2015]任务查询系统 P4559 [JSOI2018]列队 P2633 Count on a tree P3293 [SCOI2016]美味 P4618 [SDOI2018]原题识别 Part 7.12 平衡树 二叉搜索树可以用来维护有序序列。\n为了保证查询效率，有多种使二叉搜索树保持平衡的实现方法。\nP3369 【模板】普通平衡树 P3391 【模板】文艺平衡树（Splay） P3850 [TJOI2007]书架 P4008 [NOI2003]文本编辑器 P5338 [TJOI2019]甲苯先生的滚榜 P2042 [NOI2005]维护数列 P1110 [ZJOI2007]报表统计 P3644 [APIO2015]八邻旁之桥 P1486 [NOI2004]郁闷的出纳员 P2710 数列 P3224 [HNOI2012]永无乡 P3285 [SCOI2014]方伯伯的OJ P5321 [BJOI2019]送别 Part 7.13 树链剖分 树链剖分可以将任意一条树上路径划分成若干条连续的链，并用线段树等数据结构高效维护链上信息。\nP3384 【模板】树链剖分 P3313 [SDOI2014]旅行 P2590 [ZJOI2008]树的统计 P1505 [国家集训队]旅游 P2486 [SDOI2011]染色 P3258 [JLOI2014]松鼠的新家 P4069 [SDOI2016]游戏 P4211 [LNOI2014]LCA P4592 [TJOI2018]异或 P5305 [GXOI/GZOI2019]旧词 P5354 [Ynoi2017]由乃的OJ P5499 [LnOI2019]Abbi并不想研学 Part 7.14 树套树 树套树可以用来维护多维度信息。\nP3380 【模板】二逼平衡树（树套树） P1975 [国家集训队]排队 P3332 [ZJOI2013]K大数查询 P4278 带插入区间K小值 P1903 [国家集训队]数颜色 / 维护队列 P3759 [TJOI2017]不勤劳的图书管理员 P3242 [HNOI2015]接水果 P3248 [HNOI2016]树 P5445 [APIO2019]路灯 Part 7.15 动态树 Link-Cut Tree 可以用来解决动态树一类问题。\nP3690 【模板】Link Cut Tree （动态树） P3203 [HNOI2010]弹飞绵羊 P4338 [ZJOI2018]历史 P4312 [COCI2009]OTOCI P1501 [国家集训队]Tree II P2387 [NOI2014]魔法森林 P3348 [ZJOI2016]大森林 P3703 [SDOI2017]树点涂色 P4172 [WC2006]水管局长 P4219 [BJOI2014]大融合 P5489 EntropyIncreaser 与 动态图 Part 7.16 可持久化数据结构 可持久化数据结构实现了在更新信息的时候保留历史版本。\nP3919 【模板】可持久化数组（可持久化线段树/平衡树） P3834 【模板】可持久化线段树 1（主席树） P3402 【模板】可持久化并查集 P3835 【模板】可持久化平衡树 P5055 【模板】可持久化文艺平衡树 P5283 [十二省联考2019]异或粽子 Part 7.17 K-D Tree K-D Tree 是一种高效处理 $ k $ 维信息的数据结构。\nP4357 [CQOI2016]K远点对 P4148 简单题 P2479 [SDOI2010]捉迷藏 P3769 [CH弱省胡策R2]TATT P4169 [Violet]天使玩偶/SJY摆棋子 P4390 [BOI2007]Mokia P4475 巧克力王国 P2093 [国家集训队]JZPFAR P5471 [NOI2019]弹跳 Part 7.18 珂朵莉树 珂朵莉树，是一种基于 std::set 的暴力数据结构，在数据随机的情况下表现优秀。\nP5251 [LnOI2019]第二代图灵机 P5350 序列 Part 8 图论 图论是数学的一个分支，它以图为研究的对象。\nPart 8.1 图的存储与遍历 这里的图论内容都比较简单，涉及图的存储以及遍历图的方式。\nP2661 信息传递 P2921 [USACO08DEC]Trick or Treat on the Farm Part 8.2 最短路问题 很多题目都可以转化为最短路的模型。因此，掌握最短路算法非常重要。\nP3371 【模板】单源最短路径（弱化版） - Accept P4779 【模板】单源最短路径（标准版） - Accept P5905 【模板】Johnson 全源最短路 P1144 最短路计数 P1462 通往奥格瑞玛的道路 P1522 Cow Tours P1266 速度限制 P4001 [ICPC-Beijing 2006]狼抓兔子 P4568 [JLOI2011]飞行路线 P3238 [HNOI2014]道路堵塞 P5304 [GXOI/GZOI2019]旅行者 Part 8.3 树上问题 作为一种特殊的图，树上的问题具有很多鲜明的特点。\nPart 8.3.1 二叉树 二叉树是一种特殊的树，它有很多特殊的性质。\nP1087 FBI树 P1030 求先序排列 P1305 新二叉树 P1229 遍历问题 P5018 对称二叉树 P5597 【XR-4】复读 Part 8.3.2 树的直径 树的直径被定义为树上最远的两点间的距离。\n计算树的直径，可以通过两遍 DFS 解决。\nP2195 HXY造公园 P3629 [APIO2010]巡逻 P5536 【XR-3】核心城市 P1099 树网的核 P4408 [NOI2003]逃学的小孩 Part 8.3.3 最近公共祖先 两个点的最近公共祖先，即两个点的所有公共祖先中，离根节点最远的一个节点。\n求解最近公共祖先，常用的方法是树上倍增或者树链剖分。\nP3379 【模板】最近公共祖先（LCA） P3938 斐波那契 P4281 [AHOI2008]紧急集合 / 聚会 Part 8.4 生成树 用 $ n-1 $ 条边将图上的 $ n $ 个点连接起来，形成的树就被称为生成树。\nP3366 【模板】最小生成树 P4180 【模板】严格次小生成树[BJWC2010] P2872 [USACO07DEC]Building Roads P1991 无线通讯网 P1967 货车运输 P4047 [JSOI2010]部落划分 Part 8.5 拓扑排序 将一个有向无环图排序，使得所有排在前面的节点不能依赖于排在后面的节点，这就是拓扑排序。\nP1113 杂务 P1983 车站分级 P1038 神经网络 Part 8.6 差分约束 差分约束要解决的问题是：求出一组 $ n $ 元不等式的一组解，使得所有约束关系都能得到满足。\nP5960 【模板】差分约束算法 P3275 [SCOI2011]糖果 P2294 [HNOI2005]狡猾的商人 P4926 [1007]倍杀测量者 P5590 赛车游戏 Part 8.7 图的连通性相关 利用 Tarjan 算法，我们可以解决很多与图的连通性相关的问题。\nP3387 【模板】缩点 P3388 【模板】割点（割顶） P2341 [HAOI2006]受欢迎的牛 P2863 [USACO06JAN]The Cow Prom P2746 [USACO5.3]Network of Schools P1407 [国家集训队]稳定婚姻 P2272 [ZJOI2007]最大半连通子图 P3225 [HNOI2012]矿场搭建 P5058 [ZJOI2004]嗅探器 P2515 [HAOI2010]软件安装 Part 8.8 二分图 二分图上的不少问题都可以转化成网络流解决，当然也有独特的其他方法。\nP3386 【模板】二分图匹配 P2756 飞行员配对方案问题 P1129 [ZJOI2007]矩阵游戏 P1559 运动员最佳匹配问题 P2423 [HEOI2012]朋友圈 P2764 最小路径覆盖问题 P2825 [HEOI2016/TJOI2016]游戏 P3033 [USACO11NOV]Cow Steeplechase P3731 [HAOI2017]新型城市化 P4014 分配问题 P4617 [COCI2017-2018#5] Planinarenje Part 8.9 网络流 网络流是图论中一个重要的分支，很多题目都可以通过建立网络流的模型来解决。\nPart 8.9.1 最大流 最大流，即求网络中最大的流量。\nP3376 【模板】网络最大流 P4722 【模板】最大流 加强版 / 预流推进 P2065 [TJOI2011]卡片 P2763 试题库问题 P2472 [SCOI2007]蜥蜴 P2754 [CTSC1999]家园 P2765 魔术球问题 P2766 最长不下降子序列问题 P2805 [NOI2009]植物大战僵尸 P3749 [六省联考2017]寿司餐厅 Part 8.9.2 最小割 最小割，即求一个边权最小的边集，使得源点和汇点不再连通。\n可以证明，最大流=最小割。\nP1345 [USACO5.4]Telecowmunication P2057 [SHOI2007]善意的投票 P2598 [ZJOI2009]狼和羊的故事 P2774 方格取数问题 P4126 [AHOI2009]最小割 P5039 [SHOI2010]最小生成树 Part 8.9.3 费用流 在网络流中给边加上一个参数——费用，就出现了费用流。\nP3381 【模板】最小费用最大流 P4016 负载平衡问题 P4452 [国家集训队]航班安排 P2045 方格取数加强版 P2050 [NOI2012]美食节 P2053 [SCOI2007]修车 P2604 [ZJOI2010]网络扩容 P2770 航空路线问题 P3159 [CQOI2012]交换棋子 P3356 火星探险问题 P3358 最长k可重区间集问题 P4013 数字梯形问题 P4015 运输问题 P5331 [SNOI2019]通信 Part 8.9.4 上下界网络流 在网络流问题中给每条边的流量增加一个下界，就有了上下界网络流。\nP3980 [NOI2008]志愿者招募 P4043 [AHOI2014/JSOI2014]支线剧情 P4553 80人环游世界 P4843 清理雪道 Part 8.10 2-SAT k-SAT 问题的目标是对一些布尔变量赋值，满足限定的条件。\n在 k-SAT 问题中，2-SAT 问题属于较为容易解决的一类。\nP4782 【模板】2-SAT 问题 P4171 [JSOI2010]满汉全席 P3825 [NOI2017]游戏 P5332 [JSOI2019]精准预测 Part 8.11 点分治 点分治是一种可以高效统计树上路径信息的算法。\nP3806 【模板】点分治1 P2634 [国家集训队]聪聪可可 P2664 树上游戏 P3714 [BJOI2017]树的难题 P4149 [IOI2011]Race P3241 [HNOI2015]开店 P4075 [SDOI2016]模式字符串 P4183 [USACO18JAN]Cow at Large P P4292 [WC2010]重建计划 P5306 [COCI2019]Transport Part 8.12 虚树 将一些无用的点从树上删去，从而达到降低树的规模的效果。\nP2495 [SDOI2011]消耗战 P3233 [HNOI2014]世界树 P5360 [SDOI2019]世界地图 P5439 【XR-2】永恒 Part 8.13 矩阵树定理 矩阵树定理可以解决图的生成树计数问题。\nP4111 [HEOI2015]小Z的房间 P2144 [FJOI2007]轮状病毒 P3317 [SDOI2014]重建 P4208 [JSOI2008]最小生成树计数 Part 9 计算几何 试着用计算机来解决几何问题吧！\nPart 9.1 凸包 凸包指在平面上能包含所有给定点的最小凸多边形。\nP2742 【模板】二维凸包 P2287 [HNOI2004]最佳包裹 P3829 [SHOI2012]信用卡凸包 P4680 [Ynoi2018]末日时在做什么?有没有空?可以来拯救吗? P4557 [JSOI2018]战争 P5403 [CTS2019]田野 Part 9.2 旋转卡壳 旋转卡壳是一种求出凸包所有对踵点对的算法。\nP1452 Beauty Contest P3187 [HNOI2007]最小矩形覆盖 Part 9.3 半平面交 多个半平面的交集称之为半平面交。\nP3256 [JLOI2013]赛车 P2600 [ZJOI2008]瞭望塔 P4196 [CQOI2006]凸多边形 P3297 [SDOI2013]逃考 P4250 [SCOI2015]小凸想跑步 P5328 [ZJOI2019]浙江省选 Part 10 杂项 这里的专题，有很多都难以纳入前面的类别中，故将他们单独列入了杂项。\nPart 10.1 模拟退火 模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。\nP1337 [JSOI2004]平衡点 / 吊打XXX P2503 [HAOI2006]均分数据 P3878 [TJOI2010]分金币 Part 10.2 0/1 分数规划 0/1 分数规划用来求一个分式的极值。\nP4377 [USACO18OPEN]Talent Show P3199 [HNOI2009]最小圈 P3288 [SCOI2014]方伯伯运椰子 P3705 [SDOI2017]新生舞会 P4322 [JSOI2016]最佳团体 Part 10.3 离线算法 当题目不要求强制在线时，我们可以一次性读入所有询问来处理。\nPart 10.3.1 CDQ 分治 CDQ 分治是一个基于分治思想的离线算法。\nP3810 【模板】三维偏序（陌上花开） P3157 [CQOI2011]动态逆序对 P2487 [SDOI2011]拦截导弹 P4690 [Ynoi2016]镜中的昆虫 P3206 [HNOI2010]城市建设 Part 10.3.2 整体二分 整体二分，顾名思义就是把多个查询一起二分解决。\nP1527 [国家集训队]矩阵乘法 P2617 Dynamic Rankings P3527 [POI2011]MET-Meteors P4602 [CTSC2018]混合果汁 Part 10.3.3 莫队 莫队算法可以解决不少离线区间询问问题。\nP1494 [国家集训队]小Z的袜子 /【模板】莫队 P1903 [国家集训队]数颜色 / 维护队列 /【模板】带修莫队 P5906 【模板】回滚莫队 P4887 【模板】莫队二次离线（第十四分块(前体)） P2709 小B的询问 P3674 小清新人渣的本愿 P3709 大爷的字符串题 P4074 [WC2013]糖果公园 P5501 [LnOI2019]来者不拒，去者不追 Part 10.4 奇怪的题目 OI 界中有一些非常规套路的题目，这里放出来分享。\nP4920 [WC2015]未来程序 P5042 [国家集训队]丢失的题面（ydc的题面） P5285 [十二省联考2019]骗分过样例 P5246 [集训队互测2016]消失的源代码 Part 10.5 非传统题 在 NOI 等比赛中，非传统题正越来越频繁出现。\n非传统题主要包括以下几类：提交答案题，交互题，通信题。\nPart 10.5.1 提交答案题 给你一些输入，你只需要提交这些输入对应的答案，即为提交答案题。\nP1335 [NOI2013]小Q的修炼 P1737 [NOI2016]旷野大计算 P3614 yyy棋 II P3640 [APIO2013]出题人 P3782 [WC2017]排序 P3836 Nowruz P4920 [WC2015]未来程序 P5402 [CTS2019]无处安放 P5418 [CTSC2016]NOIP十合一 P5600 【XR-4】尺规作图 Part 10.5.2 交互题 在交互题中，选手程序需要通过与测评程序交互来完成任务。\nP1733 猜数（IO交互版） P1947 猜数 P5208 [WC2019]I 君的商店 P5473 [NOI2019]I 君的探险 P6541 [WC2018]即时战略 P6558 [APIO2017]考拉的游戏 ","date":"2024-10-24T00:00:00Z","permalink":"https://allergy27.github.io/p/problem_list/","title":"luogu题单"},{"content":"2024级新生第四次考核题解 考核链接：https://vjudge.net/contest/663008\n题目类型 A：签到题 B：暴力 C：模拟、排序 D：优先队列 E：BFS\n说明：\nPython代码全是由C++版本用GPT转译而来，逻辑上没有问题但不保证是在python下的最优实现 B题暴力并非最优解，但是可行解，且在比赛过程中能做上就是最好的 未提供C代码，请善用GPT等工具或尽快掌握C++的基础语法 C++代码统一模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Copyright 2024 Allergy /* @author Allergy * @email Allergy527@gmail.com * @workspace Atcoder\\10.13New\\a.cpp * @date 2024/10/13 17:21:44 */ #include\u0026lt;bits/stdc++.h\u0026gt; #define lowbit(x) ((x)\u0026amp;(-(x))) // #define int int64_t using namespace std; // NOLINT using ll = int64_t; int inf = 0x3f3f3f3f; ll ll_inf = 0x3f3f3f3f3f3f3f3f; void solve(){ } signed main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); cin \u0026gt;\u0026gt; t; return 0; } Python代码统一模板 1 2 3 4 5 6 7 def solve(): pass if __name__ == \u0026#34;__main__\u0026#34;: t = 1 # t = int(input().strip()) for _ in range(t): solve() A 因为Taffy很 本质上是一道模拟题，按题意从高到低走一遍即可，检测到比前一位小就返回NO\nC++代码 1 2 3 4 5 6 7 8 9 10 11 void solve() { string s; cin \u0026gt;\u0026gt; s; for (int i = 1; i \u0026lt; s.size(); ++i) { if (s[i] \u0026gt;= s[i - 1]) { cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; return; } } cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; } Python代码 1 2 3 4 5 6 7 def solve(): s = input().strip() for i in range(1, len(s)): if s[i] \u0026gt;= s[i - 1]: print(\u0026#34;No\u0026#34;) return print(\u0026#34;Yes\u0026#34;) B 回合制 假设我们从小到大遍历，那么算法时间复杂度为$O(n^2)$，显然跑题目的 $10^{18}$ 会超。 不妨换个想法，我们从最大值开始跑，也就是先检查 $R-L$ 是否满足题意，接着检查 $R-L-1$ ，以此类推\n诶，有同学会问为什么这样就不会超呢？ 我们可以简单思考一下，一开始质数的间隔小，接着间隔越来越大： 2 3 5 7 11 13 17 19 23 29 31 37 41 43 49 我们可以大胆猜测每隔 $5000$ 个肯定有两个是质数，而即便是 $5000$ ，$5000*5000\\approx10^7 $ ，这个数量级肯定是不会超的。至于详细证明见维基百科： https://en.wikipedia.org/wiki/Prime_gap C++代码 1 2 3 4 5 6 7 8 9 10 11 12 void solve() { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int w = r - l; w \u0026gt; 0; w--) { //从最宽的情况遍历 for (int j = l; j \u0026lt; r - w + 1; ++j) { if (__gcd(j, j + w) == 1) { //调用库函数求最大公约数 cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } } } } Python代码 1 2 3 4 5 6 7 8 9 import math def solve(): l, r = map(int, input().split()) for w in range(r - l, 0, -1): #从最宽的情况遍历 for j in range(l, r - w + 1): if math.gcd(j, j + w) == 1: #调用库函数求最大公约数 print(w) return C 可爱狗 首先，两个颜色相同的狗不会摸头，而题目保证了给定输入是偶数，那么如果每种颜色都为偶数个，则可以两两分组而不产生摸头。 接着我们讨论有颜色不为偶数的情况，由容斥原理，只会有两种颜色为奇数。 不妨假设 R 和 G 为奇数，那么取得最小摸头速度的情况只会是取min_diff(R,G)或min_diff(R,B)+min_diff(G,B)，比较后取较小者 (这里的min_diff并非库函数，仅是举例)\n有同学可能会问，为什么 R 和 G 不会取 B 中的同一个值？ 这点也不难理解，如果最优解时R和G取同一个B值，那答案是一定取min_diff(R,G)的，证明不困难，就留给各位了 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; qwq(3); for (int i = 0; i \u0026lt; 2 * n; i++) { int x; char y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; switch (y) { case \u0026#39;R\u0026#39;: qwq[0].emplace_back(x); break; case \u0026#39;G\u0026#39;: qwq[1].emplace_back(x); break; case \u0026#39;B\u0026#39;: qwq[2].emplace_back(x); break; default: break; } } for (auto \u0026amp;x : qwq) sort(x.begin(), x.end()); int r = qwq[0].size(), g = qwq[1].size(), b = qwq[2].size(); if (r % 2 == 0 \u0026amp;\u0026amp; g % 2 == 0 \u0026amp;\u0026amp; b % 2 == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; ln; return; } if (r % 2 == 0) { swap(r, b); swap(qwq[0], qwq[2]); } else if (g % 2 == 0) { swap(g, b); swap(qwq[1], qwq[2]); } // lambda 表达式，在外面写函数也可以 auto check = [\u0026amp;](vector\u0026lt;int\u0026gt; p, vector\u0026lt;int\u0026gt; q) -\u0026gt; int { //即min_diff函数 int point_p = 0, point_q = 0; int len_p = p.size(), len_q = q.size(); int ans = ll_inf; while (point_p \u0026lt; len_p \u0026amp;\u0026amp; point_q \u0026lt; len_q) { ans = min(ans, abs(p[point_p] - q[point_q])); if (p[point_p] \u0026lt; q[point_q]) { ++point_p; } else { ++point_q; } } return ans; }; int ans = check(qwq[0], qwq[1]); if (b \u0026gt; 2) { ans = min(ans, check(qwq[0], qwq[2]) + check(qwq[1], qwq[2])); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import sys def solve(): n = int(input().strip()) qwq = [[] for _ in range(3)] for _ in range(2 * n): x, y = input().strip().split() x = int(x) if y == \u0026#39;R\u0026#39;: qwq[0].append(x) elif y == \u0026#39;G\u0026#39;: qwq[1].append(x) elif y == \u0026#39;B\u0026#39;: qwq[2].append(x) for lst in qwq: lst.sort() r, g, b = len(qwq[0]), len(qwq[1]), len(qwq[2]) if r % 2 == 0 and g % 2 == 0 and b % 2 == 0: print(0) return if r % 2 == 0: qwq[0], qwq[2] = qwq[2], qwq[0] elif g % 2 == 0: qwq[1], qwq[2] = qwq[2], qwq[1] def check(p, q): point_p, point_q = 0, 0 len_p, len_q = len(p), len(q) ans = sys.maxsize while point_p \u0026lt; len_p and point_q \u0026lt; len_q: ans = min(ans, abs(p[point_p] - q[point_q])) if p[point_p] \u0026lt; q[point_q]: point_p += 1 else: point_q += 1 return ans ans = check(qwq[0], qwq[1]) if len(qwq[2]) \u0026gt; 2: ans = min(ans, check(qwq[0], qwq[2]) + check(qwq[1], qwq[2])) print(ans) D 外卖小哥 我们从后往前看，在第m小时时，我们只能点0小时后结算的订单，m-1时，则可以点0到1小时的订单，依次类推,第0小时可以点0到m小时的订单。也就是我们从后向前遍历，每次取最大值接即可。 由于我们的时间复杂度被限制在$O(nlogn)$，所以必须用$logn$时间取得最大值，我们采用优先队列(最大堆)存储。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void solve() { int n, m, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; qwq; for (int i = 0; i \u0026lt; n; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; qwq[x].emplace_back(y); } priority_queue\u0026lt;int\u0026gt; que; for (int i = 0; i \u0026lt;= m; ++i) { if (qwq.count(i)) for (auto x : qwq[i]) que.push(x); if (!que.empty()) { int t = que.top(); que.pop(); ans += t; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import heapq def solve(): n, m = map(int, input().split()) qwq = {} for _ in range(n): x, y = map(int, input().split()) if x not in qwq: qwq[x] = [] qwq[x].append(y) que = [] ans = 0 for i in range(m + 1): if i in qwq: for val in qwq[i]: heapq.heappush(que, -val) if que: ans += -heapq.heappop(que) print(ans) E 西天取经 跑一遍 广度优先搜索(BFS) 即可，每次更新当前路的最短路径，并且为当前路存一个方案数，代表从东土大唐到该点有多少条方案，每次遇到最短路相同的情况将方案数相加，否则接着跑BFS即可\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void solve() { int n, m, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; qwq(n + 1); vector\u0026lt;int\u0026gt; dis(n + 1, ll_inf), num(n + 1); // bfs距离,方案数 for (int i = 0; i \u0026lt; m; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; qwq[x].emplace_back(y); qwq[y].emplace_back(x); } queue\u0026lt;int\u0026gt; que; que.push(1); dis[1] = 0; num[1] = 1; while (!que.empty()) { int t = que.front(); que.pop(); for (auto x : qwq[t]) { if (dis[x] \u0026gt; dis[t] + 1) { dis[x] = dis[t] + 1; num[x] = num[t]; que.push(x); } else if (dis[x] == dis[t] + 1) { num[x] = (num[x] + num[t]) % mod; } } } cout \u0026lt;\u0026lt; num[n] \u0026lt;\u0026lt; ln; } Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from collections import deque MOD = 10**9 + 7 def solve(): n, m = map(int, input().split()) qwq = [[] for _ in range(n + 1)] dis = [float(\u0026#39;inf\u0026#39;)] * (n + 1) num = [0] * (n + 1) for _ in range(m): x, y = map(int, input().split()) qwq[x].append(y) qwq[y].append(x) que = deque([1]) dis[1] = 0 num[1] = 1 while que: t = que.popleft() for x in qwq[t]: if dis[x] \u0026gt; dis[t] + 1: dis[x] = dis[t] + 1 num[x] = num[t] que.append(x) elif dis[x] == dis[t] + 1: num[x] = (num[x] + num[t]) % MOD print(num[n]) ","date":"2024-10-12T00:00:00Z","permalink":"https://allergy27.github.io/p/flashmen_solve_1/","title":"2024级新生第四次考核题解"},{"content":"Boyer-Moore算法介绍 概述 Boyer-Moore算法（BM算法）是由Robert S. Boyer和J Strother Moore在1977年提出的一种字符串匹配算法。该算法在查找一个子串在主串中首次出现的位置时表现非常出色，尤其在处理较长的文本时具有高效性。它之所以高效，是因为在匹配过程中可以跳过一些无意义的字符，从而减少比较次数。\nBM算法的核心思想是通过分析文本和模式串之间的关系，提前预测某些字符的匹配结果，并在可能的情况下进行大步跳跃，以尽量避免不必要的字符比较。BM算法主要通过两个启发式规则来实现跳跃：坏字符规则和好后缀规则。\n核心思想 1. 坏字符规则（Bad Character Rule） 坏字符规则主要是指在比较过程中，当模式串中的某个字符与主串中的字符不匹配时，可以根据主串中的不匹配字符跳过一些可能不会匹配的位置。其基本原理是将模式串向右移动，直到该不匹配字符在模式串中的下一个匹配位置出现，或者模式串完全移过该不匹配字符。坏字符规则可以避免逐一比较，提升算法效率。\n2. 好后缀规则（Good Suffix Rule） 好后缀规则是当模式串的一部分在主串中匹配时，如果发现有一部分匹配，接下来发生了不匹配的情况，那么可以利用已经匹配的部分（即好后缀）来判断模式串应如何继续向右移动。好后缀规则的目的是确保尽可能大幅度地移动模式串，而不是简单地一位一位地滑动。\n这两个规则的结合使得BM算法能够在大部分情况下避免逐字符比较，尤其是在长文本和较短模式串的情况下，效率尤为明显。\nBM算法的复杂度 BM算法的时间复杂度依赖于文本和模式串的具体内容。它在最坏情况下的时间复杂度为O(mn)，其中m是模式串的长度，n是主串的长度。但在实际使用中，由于它的跳跃特性，BM算法的平均时间复杂度接近于O(n/m)，这使得它在大多数实际应用场景中非常高效。\n应用场景 BM算法特别适用于文本搜索、DNA序列比对、编辑器中的查找替换功能等。其高效的匹配性能使它在处理大规模文本数据时，成为一种常用的字符串匹配算法之一。\n代码样例(rust实现) 该代码实现随机生成两段DNA序列并在找到可以匹配的部分后输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //@author Allergy //@workspace study/bm.rs //@data 2024/10/10 19:15:05 use rand::Rng; fn cin() -\u0026gt; String { let mut input = String::new(); std::io::stdin().read_line(\u0026amp;mut input).unwrap(); input.trim().to_string() } fn main() { let t = 1; //let t = cin().parse::\u0026lt;i32\u0026gt;().unwrap(); let _ = (0..t).for_each(|_| solve()); } fn solve() { let (a, b) = cin() .split_whitespace() .fold((0, 0), |x, y| (x.1, y.parse::\u0026lt;usize\u0026gt;().unwrap())); let trans = |x: char| match x { \u0026#39;A\u0026#39; =\u0026gt; \u0026#39;T\u0026#39;, \u0026#39;T\u0026#39; =\u0026gt; \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39; =\u0026gt; \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39; =\u0026gt; \u0026#39;C\u0026#39;, _ =\u0026gt; \u0026#39; \u0026#39;, }; let show = |qwq: \u0026amp;Vec\u0026lt;char\u0026gt;| { qwq.iter().for_each(|x| print!(\u0026#34;{}\u0026#34;, x)); println!() }; let dna_init = random_dna(a); let dna = dna_init.iter().map(|x| trans(*x)).collect::\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;(); let pattern = random_dna(b); show(\u0026amp;dna_init); println!(\u0026#34;↓\u0026#34;); show(\u0026amp;pattern); boyer_moore(\u0026amp;dna, \u0026amp;pattern); } fn random_dna(length: usize) -\u0026gt; Vec\u0026lt;char\u0026gt; { let nucleotides = [\u0026#39;A\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;G\u0026#39;]; // DNA碱基 let mut rng = rand::thread_rng(); // 创建随机数生成器 // 随机生成指定长度的DNA序列 let sequence: String = (0..length) .map(|_| nucleotides[rng.gen_range(0..4)]) // 随机选择ATCG中的一个 .collect(); sequence.chars().collect() } fn boyer_moore(text: \u0026amp;Vec\u0026lt;char\u0026gt;, pattern: \u0026amp;Vec\u0026lt;char\u0026gt;) { // 坏字符规则：生成坏字符表 let bad_str = |pattern: \u0026amp;Vec\u0026lt;char\u0026gt;, qwq: \u0026amp;mut Vec\u0026lt;i32\u0026gt;| { qwq.iter_mut().for_each(|x| *x = -1); let m = pattern.len(); for i in 0..m { qwq[pattern[i] as usize] = i as i32; } }; // 好后缀规则 let good_suffix = |pattern: \u0026amp;Vec\u0026lt;char\u0026gt;,qwq:\u0026amp;mut Vec\u0026lt;i32\u0026gt;|{ } let n = text.len(); let m = pattern.len(); if m == 0 { println!(\u0026#34;模式串为空，返回0\u0026#34;); return; } // 坏字符表（ASCII字符集大小256） let mut bad_char = vec![-1; 256]; bad_str(\u0026amp;pattern, \u0026amp;mut bad_char); // 开始匹配 let mut i = 0; while i \u0026lt;= n - m { let mut j = m - 1; let mut check = false; //从末位开始判断 while pattern[j] == text[i + j] { if j == 0 { check = true; break; } j -= 1; } if check { println!(\u0026#34;成功匹配，索引位于{}\u0026#34;, i + 1); i += if i + m \u0026lt; n { (m as i32 - bad_char[text[i + m] as usize]) as usize } else { 1 }; } else { i += 1.max(j as i32 - bad_char[text[i + j] as usize]) as usize; } } } ","date":"2024-10-12T00:00:00Z","permalink":"https://allergy27.github.io/p/boyer-moore-algorithm/","title":"bm算法介绍"}]